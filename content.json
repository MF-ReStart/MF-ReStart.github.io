{"meta":{"title":"荒原饮露","subtitle":"青春不是隔岸观火啊","description":"","author":"荒原饮露","url":"https://www.missf.top","root":"/"},"pages":[{"title":"","date":"2020-04-15T12:15:19.830Z","updated":"2020-04-13T10:37:51.000Z","comments":false,"path":"categories/index.html","permalink":"https://www.missf.top/categories/index.html","excerpt":"","text":""},{"title":"","date":"2020-04-15T12:15:19.829Z","updated":"2020-04-13T10:37:41.000Z","comments":false,"path":"tags/index.html","permalink":"https://www.missf.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Python基础day03","slug":"Python基础day03","date":"2020-04-24T10:14:29.000Z","updated":"2020-04-25T05:36:32.361Z","comments":true,"path":"2020/04/24/Python基础day03/","link":"","permalink":"https://www.missf.top/2020/04/24/Python%E5%9F%BA%E7%A1%80day03/","excerpt":"","text":"十年太长，什么都会变。一辈子太短，一件事也有可能做不完。回忆永远站在背后，你无法抛弃，只能拥抱。 验证码# 代入验证码项目，输入姓名密码之后有空格也不会报错 username = input(\"请输入姓名:\").strip() passworrd = input(\"请输入密码:\").strip() code = 'AeTrd'.upper() your_code = input(\"请输入验证码:\").upper() if your_code == code: if username == 'alex' and passworrd == 'sb': print('登录成功') else: print('用户名或者密码错误') else: print('验证码不正确') 将一行字符串竖着打印# while循环 t = '荒原饮露cchkskhdiqwuey' s = len(t) # 先统计字符串的长度 # print(s) index = 0 # 设定一个索引值 while index &lt; s: # 如果索引值小于变量s则进入循环 print(t[index]) # 从0开始打印字符串的索引，直到index&lt;s不成立退出循环 index += 1 # index每次自增1 # for循环 t = '荒原饮露cchkskhdiqwuey' for i in t: print(i) # 还可以进行拼接，print(i+'lo') 猜数字# 猜数字,只有猜对了才会退出 num = 66 while True: cai = int(input(\"请输入你要猜的数字:\")) if cai > num: print(\"猜的数字大了！\") elif cai &lt; num: print(\"猜的数字小了\") else: print(\"猜对了！\") break # 三次猜测不对就退出 num = 66 i = 0 while i &lt; 3: j = int(input(\"请输入数字:\")) if j > num: print(\"数字大了!\") elif j &lt; num: print(\"数字小了!\") else: print(\"猜对了!\") break i += 1 计算器# 方式一 content = input(\"请输入内容:\").strip() # 将输入的字符串，去掉前后两端的空格 plus_index = content.find('+') # 找到加号位置，并返回加号的索引数 num1 = content[:plus_index].strip() # 取加号前面的区域并且去掉空格 num2 = content[plus_index+1:] # 取加号后面的区域也去掉空格 sum3 = int(num1) + int(num2) # 将取到的无空格值相加 print(sum3) # 方式二 content = input(\"请输入内容:\").strip() # 将输入的字符串，进行去前后两端的空格 li = content.split('+') # 将字符串转换为列表，指定以+进行分割 print(li) ['15 ', ' 16'] # 将得到的元素相加 sum1 = int(li[0]) + int(li[1]) # 将字符串类型的两个元素强制转换为int，会去掉空格 print(sum1) 列表为什么需要列表 字符串如果长度过于长取值时会很费劲，取出来的数据是字符串类型，使用不方便 字符串有长度限制(只能存储少量的字符串类型的数据) 基于以上原因Python提供了一个另外的数据类型:容器类数据类型 什么是列表 列表能存储大量的、不同的数据类型，列表存放什么数据类型，取出来之后还是什么数据类型 列表可以存放的数据类型:数字，字符串，布尔值，小列表，元组，字典，集合，对象 32位Python的限制是 536870912 64位Python的限制是 1152921504606846975 列表是有序的、有索引值的、可切片、方便取值 列表取值# 取第一个元素 sl = ['alex','荒原','154'] sl1 = print(sl[0],type(sl)) # 输出索引和索引类型 print(sl1) # alex &lt;class 'list'> 定义列表时是字符串 sl = ['alex','荒原','154'] sl1 = print(sl[0:2]) # 0 1 2，顾首不顾尾，只取前两个元素 print(sl1) # ['alex', '荒原'] # 反向取值 sl = ['alex','荒原','154'] sl1 = print(sl[-1:-4:-1]) print(sl1) # ['154', '荒原', 'alex'] 列表的增加sl.append(\"abc\") # 增加abc元素 print(sl) sl.append(True) # 增加布尔值 print(sl) name_list = [] # 空列表 while True: # 如果不执行break,则一直执行while True username = input(\"请输入姓名:\").strip() # 用户输入字符串 if username.upper() == 'Q':break # 如果输入是q，无论大小写都执行break name_list.append(username) # 判断到不是q则增加到列表 print(name_list) # 插入 lk = ['mjk','ctr','tpo',100] lk.insert(1,'yu') # 在索引1的位置，插入'yu',索引从零开始 print(lk) ['mjk', 'yu', 'ctr', 'tpo', 100] # 迭代者追加 lk = ['mjk','ctr','tpo',100] lk.extend('abc') print(lk) ['mjk', 'ctr', 'tpo', 100, 'a', 'b', 'c'] lk = ['mjk','ctr','tpo',100] lk.extend(['asd','cvf','cdd']) print(lk) ['mjk', 'ctr', 'tpo', 100, 'asd', 'cvf', 'cdd'] 列表的删除# 按照索引去删除 lk = ['mjk','ctr','tpo',100] ret = lk.pop(1) # 删除索引为1的元素 print(lk) ['mjk', 'tpo', 100] # 按照元素去删除 lk = ['mjk','ctr','tpo',100] lk.remove('tpo') # 指定删除那个 print(lk) ['mjk','ctr',100]. # 清空列表 lk = ['mjk','ctr','tpo',100] lk.clear() print(lk) [] # del 1.按照索引删除单个元素 lk = ['mjk','ctr','tpo',100] del lk[0] print(lk) ['ctr','tpo',100] 2.按照切片删除一部分元素 lk = ['mjk','ctr','tpo',100] del lk[:2] print(lk) ['tpo', 100] 3.按照切片（步长）删除一部分元素 lk = ['mjk','ctr','tpo',100,'cff','ioo','tyy'] s = lk[:5:2] # 取区域为0-5，步长为2 print(s) ['mjk', 'tpo', 'cff'] del lk[:5:2] # 取区域为0-5，步长为2，这些元素全部删除 print(lk) ['ctr', 100, 'ioo', 'tyy'] 列表的修改# 利用索引修改 lk = ['mjk','ctr','tpo',100,'cff','ioo','tyy'] lk[0] = 'we' # 利用索引定义要修改的元素的位置 print(lk) # 利用切片修改 lk = ['mjk','ctr','tpo',100,'cff','ioo','tyy'] lk[:2] = 'op' print(lk) ['o', 'p', 'tpo', 100, 'cff', 'ioo', 'tyy'] # 利用切片+步长修改 lk = ['mjk','ctr','tpo',100,'cff','ioo','tyy'] lk[:4:2] = 'op' # 注意步长的个数和修改后的字符串个数 print(lk) ['o', 'ctr', 'p', 100, 'cff', 'ioo', 'tyy'] 列表的查询# 按照索引查询 lk = ['mjk','ctr','tpo',100,'cff','ioo','tyy'] print(lk[1]) # 打印一个 # for 循环 for i in lk: print(i) # 输出列表所有元素 列表的其他操作# 计算列表元素的总个数 lk = ['mjk','ctr','tpo',100,'cff','ioo','tyy','cff'] print(len(lk)) 8 # 计算某个元素出现的个数 print(lk.count('cff')) 2 # 通过元素找索引，找到第一个返回，找不到就报错 print(lk.index('ctr')) 1 # 从小到大排列 fg = [2,9,4,6,7,1,8] fg.sort() print(fg) [1, 2, 4, 6, 7, 8, 9] # 从大到小排列 fg.sort(reverse=True) print(fg) [9, 8, 7, 6, 4, 2, 1] # 列表翻转 fg = [2,9,4,6,7,1,8] fg.reverse() print(fg) # 英文字符排序，按照元素首字母的ASCLL码的大小排序 fg = ['dfg','arfd','wer','fgv'] fg.sort() print(fg) ['arfd', 'dfg', 'fgv', 'wer'] 列表的嵌套ll = [1,2,'taibai',[1,'alex',3,]] # 列表里面有嵌套的小列表 # 将taibai改成大写 ll[2] = ll[2].upper() print(ll) # 往小列表追加元素'老男孩教育' ll[3] = ll.append('老男孩教育') print(ll) # 将alex改成alexsb ll[3][1] = ll[3][1] + 'sb' print(ll) # 打印嵌套列表元素 lj = ['wedi','lko','cjd',['dkd','oto'],'top'] for i in lj: if type(i) == list: # 加个判断如果某个元素类型为list，则再循环一遍，打印出来 for o in i: print(o) else: # 否则正常打印 print(i) 元组用来存放一些重要的信息，放在列表中不安全，需要一个容器类的数据类型，比如：个人信息，密码等。元组不能修改，但是元组里面的列表可以修改。 tu = (1,'alex',True,[1,2,3]) # 定义一个元组 tu[-1][2] = '12' # 往列表里面追加元素 print(tu) (1, 'alex', True, [1, 2, '12']) # 存放一些重要数据时，需要用元组存放 字典列表如果存储大量的数据，查询速度相对较慢，因为列表存储的数据一般没有什么关联性。针对这个问题，Python提供了一个基础数据类型：字典(dict) 回顾数据类型 分类 数据类型 容器型数据类型 list，tuple，dict，set 非容器型数据类型 str，bool，int 可变数据类型（不可哈希） list，dict，set 不可变数据类型（可哈希） str，bool，int，tuple 字典是由键值对形式存储的数据类型，字典的键必须是不可变的数据类型，唯一不重复的，字典的值可以是任意数据类型或者对象。基于字典的键是不可变的，字典的键会通过一种哈希算法，将键的值换算成内存地址，所以字典的查询速度非常快。字典在Python3.6之前是无序的，在3.6及以后字典会按照字典创建时的顺序排列。字典可以存储大量关联性数据。 字典的增加dic = {'name':'barry','age':18,'sex':'man'} # 用字典定义三个键值对 dic['dfgh'] = 150 # 没有则添加这个键值对 dic['age'] = 28 # 有age这个键就将值覆盖为28 print(dic) {'name': 'barry', 'age': 28, 'sex': 'man', 'dfgh': 150} dic.setdefault('port') # 没有这个键值对就会添加并赋值为空 dic.setdefault('name','yiyi') # 有name这个值则不修改，没有则增加 print(dic) {'name': 'barry', 'age': 18, 'sex': 'man', 'port': None} 字典的删除# pop 通过键去删除键值对 dic = {'name':'barry','age':18,'sex':'man'} ret = dic.pop('sex') print(dic) {'name': 'barry', 'age': 18} # 删除一个不存在的键就会报错 dic = {'name':'barry','age':18,'sex':'man'} ret1 = dic.pop('name2') # 为了程序能执行下去，想要不报错的话，可以添加一个返回值 dic = {'name':'barry','age':18,'sex':'man'} ty = dic.pop('re','没有此键') print(ty) 没有此键 # clear 清空 dic = {'name':'barry','age':18,'sex':'man'} dic.clear() print(dic) {} # popitem 删除最后一个键值对，3.5之前是随机删除，3.6删除最后一个键值对 dic = {'name':'barry','age':18,'sex':'man'} lo = dic.popitem() print(dic) {'name': 'barry', 'age': 18} # 删除整个字典 dic = {'name':'barry','age':18,'sex':'man'} del dic print(dic) 字典的修改# 改 dic = {'name':'barry','age':18,'sex':'man'} dic['age'] = 28 #重新定义age键的值 print(dic) # update 更新 dic1 = {'name':'barry','age':18,'sex':'man'} dic2 = {'name':'nji','age':'18','id':'001'} dic2.update(dic1) #将dic1字典中的键值对覆盖添加到dic2，dic1不变 print(dic2) {'name': 'barry', 'age': 18, 'id': '001', 'sex': 'man'} # update 正常添加 dic = {'name':'barry','age':18,'sex':'man'} dic.update(weight=150,high=175) #一次添加多个键值对 print(dic) {'name': 'barry', 'age': 18, 'sex': 'man', 'weight': 150, 'high': 175} 字典的查询# 查 dic = {'name':'barry','age':18,'sex':'man'} print(dic['name']) # 按键查对应的值，没有此键会报错 barry tr = dic.get('age1','没有此键') # 定义没有此键时的返回值 print(tr) 没有此键 字典的其他操作dic = {'name':'barry','age':18,'sex':'man'} print(dic.keys()) dict_keys(['name', 'age', 'sex']) print(dic.values()) dict_values(['barry', 18, 'man']) print(dic.items()) dict_items([('name', 'barry'), ('age', 18), ('sex', 'man')]) # for循环得到的是keys值 for i in dic: print(i) name age sex 字典的嵌套联系# 字典的嵌套练习 dic = { 'l1':['alex', '太白'], 'id':3, 1:{ 'data': 20181225, 'place': '深圳校区', 'class': 'python3期', 'name_list': ['awq', 'xx'], } } # 1.给小列表['alex', '太白'] alex后面插入一个字符串，'aaa' dic['l1'].insert(1,'aaa') print(dic) # 2.将id对应的3变成1 dic['id'] = 1 # 3.将1对应的字典的data的值变成20181224 dic[1]['data'] = 20181224 print(dic) # 4.将name_list对应的awq全部变成大写 dic[1]['name_list'][0] = dic[1]['name_list'][0].swapcase() print(dic) # 5.将name_list对应的xx删除 dic[1]['name_list'].pop(1) print(dic) 将字典数据格式化输出# 格式化输出 msg = '我叫%s,我身高%s，年龄%s' % ('ed',180,23) print(msg) # 将字典数据格式化输出 dic = {'name':'barry','age':18,'sex':'男'} mk = '我叫%(name)s,今年%(age)s,性别%(sex)s' % dic print(mk) 返回一个新的字典# 返回一个新的字典，键从可迭代对象里面获取，值不变 dic1 = dict.fromkeys('top','ed') dic2 = dict.fromkeys(['lop'],'努力') print(dic1) {'t': 'ed', 'o': 'ed', 'p': 'ed'} print(dic2) {'lop': '努力'} dicu = dict.fromkeys([1,2,3],['alex']) print(dicu) {1: ['alex'], 2: ['alex'], 3: ['alex']} # 坑:值如果是一个可变的数据类型，那么所有的值都是一个内存地址 dicu[1].append(000) print(dicu) {1: ['alex', 0], 2: ['alex', 0], 3: ['alex', 0]} # 给dicu[1]这个列表赋值000，所有列表的值都是000，因为列表所有的值都指向一个内存地址 数据类型的补充# 数据类型的补充 str ---> list split list ---> str join 0,'',[],{},(),set() ---> bool:false # 列表和元组的互换 # list &lt;---> tuple jk = [1,2,3] yu = tuple(jk) print(yu) uy = list(yu) print(uy) # dict ---> list dico = {'name':'kasha','ui':'io'} print(list(dico)) ['name', 'ui'] # dict ---> tuple dich = {'name':'yu','age':15} print(tuple(dich)) ('name', 'age') # 元组中只有一个元素并且没有逗号，则它不是元组，它与元素数据类型相同 t1 = (1,) t2 = ('al',) t3 = ([1,2,3],) print(t1,t2,t3) (1,) ('al',) ([1, 2, 3],) t1 = (1) t2 = ('al') t3 = ([1,2,3]) print(t1,t2,t3) 1 al [1, 2, 3] 将索引为奇数位的元素删除# 将索引为奇数位的元素删除,列表是不等长的 # 方法一 li = [11,36,56,48,79,45,21,65] del li[1::2] # 1-所有，步长为2 print(li) # 方法二 li = [11,36,56,48,79,45,21,65] new_li = [] # 定义一个空列表 for index in range(len(li)): # 循环 if index % 2 == 0: # 如果能被2整除 new_li.append(li[index]) # 如果能整除，就加入到new_li列表里面，这样索引是奇数位的元素就被删除了 li = new_li print(li) # 方法三 li = [11,36,56,48,79,45,21,65] for index in range(len(li)-1,-1,-1): if index % 2 == 1: li.pop(index) print(li) 将字典中键含有k元素的键值对删除# 将字典中键含有k元素的键值对删除 dict = {'ko':'ty','df':54,'13k':'hu','jl':'lp'} # 循环列表时不能改变字典的大小 lo = [] # 定义一个空的列表 for i in dict: # 将字典循环给i，赋值时是只将key赋值 if 'k' in i: # 如果k存在于i中 lo.append(i) # 则把这些有k元素的键值对添加到lo这个空字典 for y in lo: # 将lo字典循环给y dict.pop(y) # 通过键去删除键值对 print(dict) enumerate()# enumerate() 函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中 s1 = \"Hello\" for i,y in enumerate(s1,start=1): print(i,y) 1 H 2 e 3 l 4 l 5 o s2 = [\"top\",\"jun\",\"mid\",\"adc\",\"sup\"] for i,j in enumerate(s2,start=1): print(i,j) 1 top 2 jun 3 mid 4 adc 5 su","categories":[{"name":"Python","slug":"Python","permalink":"https://www.missf.top/categories/Python/"}],"tags":[{"name":"Python基础","slug":"Python基础","permalink":"https://www.missf.top/tags/Python%E5%9F%BA%E7%A1%80/"}]},{"title":"Python基础day02","slug":"Python基础day02","date":"2020-04-24T04:14:29.000Z","updated":"2020-04-24T13:04:24.896Z","comments":true,"path":"2020/04/24/Python基础day02/","link":"","permalink":"https://www.missf.top/2020/04/24/Python%E5%9F%BA%E7%A1%80day02/","excerpt":"","text":"格式化输出# 格式化输出 name = input(\"请输入姓名：\") age = input(\"请输入年龄：\") job = input(\"请输入职业：\") hobby = input(\"请输入爱好\") msg = \"\"\"------ info of %s ------ Name : %s Age : %s job : %s Hobbie : %s ------ end ------\"\"\" % (name,name,age,job,hobby) print(msg) # 坑:单个%号默认被当成一个占位符，如果想单纯的表示%号，请使用%% msg = '我叫%s,今年%s岁,python入门1%%.' % ('荒原饮露','23') print(msg) 运算符 运算符 描述 实例 = 简单的赋值运算符 c = a + b 将 a + b 的运算结果赋值给c += 加法赋值运算符 c += a 等效于 c = c + a -= 减法赋值运算符 c -= a 等效于 c = c - a *= 乘法赋值运算符 c *= a 等效于 c = c * a /= 除法赋值运算符 c /= a 等效于 c = c / a %= 取模赋值运算符 c %= a 等效于 c = c % a **= 幂赋值运算符 c *= a 等效于 c = c * a //= 取整赋值运算符 c //= a 等效于 c = c // a and “与”，如果 x 为False，x and y 返回False，否则返回y的计算值 两边为True才为True or “或”， 如果 x 为True，返回True，否则它返回y的计算值 一边为True则为True not “非”， 如果 x 为True，返回False，如果 x 为False，返回True True则False，反之 逻辑运算符的优先级() > not > and > or and 两个条件必须同时成立才为True or 两个条件有一个成立则为True not 条件为True则结果为False，条件为False则结果为True 运算符的不等式计算print(2 > 1 and 3 > 4) 两边式子同时成立，才会为True，否则为False print(2 > 1 and 3 > 4 or 4 &lt; 5 and 6 &lt; 7) 先计算and，式子为False or True，结果则为True print(1 > 2 and 3 &lt; 4 or 4 > 5 and 2 > 1 or 9 &lt; 8) 先计算and，式子为False or False or False，结果为False 运算符数字计算x or y # if x is True，return x else return y.如果x为True则返回X，否则返回y print(1 or 2) 1 print(3 or 2) 3 print(0 or 2) 2 # x and y和x or y是相反的 print(1 and 2) 2 print(8 and 0) 0 print(-100 and 2) 2 print(1 and 2 or 3 and 5) == print(2 or 5) 2 编码初识ASCII ASCII:早期的密码本，只包含英文字母，数字，特殊字符与01的对应关系 采用 8位比特（bit） == 1byte（字节） 在ascll编码中 8位比特表示一个字节表示一个字符 h e l l o = 01101000 01100101 01100111 0110011 01100101 缺点:只为英文使用者考虑，不能处理中文和其他国家的文字 GBK 由于ASCII编码，于是每个国家都提出了不同的编码来适应自己的语言 GBK 只包含本国文字（以及英文字母，数字，特殊字符）与01对应关系 GBK是采用单双字节变长编码，英文使用单字节编码，完全兼容ASCII字符编码，中文部分采用双字节编码 a 太 白 = 01101000 01100101 01100111 0110011 01100101 # 1个英文占1个字节，1个中文字符占2个字节，共5字节 UNICODE 由于ASCII编码的局限性，unicode应运而生 unicode:万国码，将全世界所有的文字都统一到一套编码里面 采用32位比特(bit)== 4byte 在unicode编码中 32位比特表示4个字节表示一个字符 a：00000000 00010010 00000000 00010010 中：00000000 10010010 00000000 10010010 缺点:如果使用unicode编码来存储英文，这会大量浪费空间，因为我们知道一个英文字符只占一个字节，而另外三个字节就浪费掉了，这样在存储和传输上非常不划算 UTF-8 utf-8:包含全世界所有的文字与二进制01的对应关系,最少用8位表示一个字符 utf-8是一种针对Unicode的可变长度字符编码,是对Unicode编码的压缩和优化，将所有的字符和符号进行分类 英文: 00000010 8位表示一个字节表示一个字符 欧洲文字: 00000010 00100000 16位表示两个字节表示一个字符 中国(亚洲): 00000010 00000010 00000010 24位表示三个字节表示一个字符 例子 'old男孩' GBK:7个字节 utf-8:9个字节 十进制转换为二进制关键要点:除二取余，倒序排列，高位补零。 将十进制数42不断除以2，得到的余数非别是:010101，然后倒序排列，42所对应的二进制就是101010，然后高位补零就是:00101010 负整数转换为二进制，以-42为例，先得到42的二进制，然后取反(0变1，1变0)再加一，就是11010101 + 1，结果为11010110 二进制转换成十进制 1 0 0 1 0 1 1 0 1 * 2^7 0 * 2^6 0 * 2^5 1 * 2^4 0 * 2^3 1 * 2^2 1 * 2^1 0 * 2^0 将这些数相加，得到的就是10010110这个二进制数的十进制数 128 + 0 + 0 + 16 + 0 + 4 + 2 + 0 = 150 数据类型之间的转换int（整数） --> bool（布尔值） 非零即True bool（布尔值） --> int（整数） True 1 False 0 str（字符串） --> bool（布尔值） 非空即True str（字符串） --> int（整数） str（13 ）转换为整数，会强制去掉空格变成int（13） bool（布尔值） --> str（字符串） 还是True，但是str类型的True，失去True的意义 y = True u = str(y) print(u,type(u)) True &lt;class 'str'> # 由于是str数据类型的True，下面的3 + u会报错，如果是bool数据类型的True可以与数字相加 print(3 + u) 字符串的切片字符串索引示意图请记住切片原则:顾首不顾尾 按照索引取值s = 'python骑士计划第三期' s1 = s[0] s2 = s[-1] print(s1) # p print(s2) # 期 按照切片取值s = 'python骑士计划第三期' # 照切片取值，顾首不顾尾，s5 = s[6:-3] 6就是第六个字符以后，-3就是倒数第三个字符以前 s3 = s[0:6] # 是从零开始数。取整个字符串可以写成s3 = s[:6],取整个字符串是s3 = s[:] print(s3) # python s4 = s[:6] # 相当于s[0:6]，0可以不写，默认从零开始 print(s4) # python s5 = s[6:-3] print(s5) # 骑士计划 s6 = s[6:10] print(s6) # 骑士计划 切片加步长取值# 步长就是每一步的长度，取pto字符串，要先划分区域，再定义隔几个字符去取 s = 'python骑士计划第三期' s7 = s[:6:2] # 划分区域为 0-6（区域为:python，从首个字符串开始取），步长为2 print(s7) # pto s8 = s[7::2] # 划分区域为 7-最后（区域为:士计划第三期，从第七个字符之后开始取），步长为2 print(s8) # 士划三 s9 = s[-1:-4:-1] # 倒叙取值要加上反向步长 print(s9) # 期三第 print(s[:5:-1]) # 后面是-1所以是反向取值，区域定义为 0-5（python），但是区域也是反向的，所以是从期到n的区域里面取 骑士计划第三期 字符串的常用操作capitalize() 首字母大写s = 'faker' s1 = s.capitalize() print(s) # faker print(s1) # Faker center() 将字符串居中s = 'missf.top' s1 = s.center(50) print(s1) missf.top # 设置50的长度并把字符串居中 s2 = s.center(50,'*') print(s2) ********************missf.top********************* # 设置50的长度定义填充物并把字符串居中 swapcase() 大小写翻转sr = 'KubeRnEteS' print(sr.swapcase()) kUBErNeTEs title() 非字母隔开单词的首字母大写s = 'tpshow9nohup@mid' # 注意：第一个字母也会变成大写 print(s.title()) Tpshow9Nohup@Mid upper() 不区分大小写# 用途:验证码不区分大小写 username = input(\"请输入姓名:\") passworrd = input(\"请输入密码:\") code = 'AeTrd'.upper() your_code = input(\"请输入验证码:\").upper() if your_code == code: if username == 'alex' and passworrd == 'sb': print('登录成功') else: print('用户名或者密码错误') else: print('验证码不正确') startswich() endswith() 判断以什么为开头和结尾s = 'mowenjieadcarry' print(s.startswith('o')) False # 字符串不是以o开头，结果为False print(s.startswith('mo')) True # 字符串以mo开头，结果为True print(s.startswith('j',5)) # 切割五个字符之后是否是j开头，结果为True True print(s.endswith('ry')) # 判断以什么为结尾 True find() index() 通过元素找索引s = 'mowenjieadcarry' print(s.find('a')) 8 # 返回a元素前面的索引数 print(s.find('a',9,)) 11 # 从第九个字符后面开始找，找到的是第二个a # find和index功能几乎一样，区别只有find找不到会返回-1,index会报错 strip() 默认去除字符串前后的空格/换行符/制表符# strip() 默认去除字符串前后两端的空格，换行符，制表符 s = '\\n barry \\t \\n' print(s.strip()) # barry # strip 去除字符串两边的字符 s = 'kkohuang yuan yin lure' print(s.strip('kore')) # 会把kore切割成最小单位，从前后两边逐个去除 huang yuan yin lu # lstrip 只从前面去除 print(s.lstrip('k')) ohuang yuan yin lure # rstrip() 只从后面去除 print(s.rstrip('re')) kkohuang yuan yin lu split() 将字符串转化为列表s = 'kkohuang yuan yin lure' print(s.split()) # 默认以空格分割元素 ['kkohuang', 'yuan', 'yin', 'lure'] t = 'top:mid:adc' print(t.split(':')) # 指定以冒号进行分割 ['top', 'mid', 'adc'] print(t.split(':',1)) # 指定以冒号进行分割,分割一次 ['top', 'mid:adc'] t = ':mid:adc' # 只有两个分割符，但是转换成列表之后参数个数是n+1 print(t.split(':')) ['', 'mid', 'adc'] join() 列表转化为字符串t = ':mid:adc' s9 = '-'.join(t) # 将每个字符通过指定的连接符连接在一起 print(s9) :-m-i-d-:-a-d-c t1 = ['liz','zsd','awa'] s10 = ' '.join(t1) # 以空格为分隔符 print(s10) liz zsd awa # 将列表的多个元素转换回字符串 replace() 字符串替换t = 'faker是世界第一中单，faker也是一个屌丝，faker' s11 = t.replace('faker','55开',2) # 可以指定替换的次数，不指定次数则全部替换 print(s11) 55开是世界第一中单，55开也是一个屌丝，faker format() 格式化输出# 第一种 s = '我叫{}，我玩{}，我主玩的位置是{}'.format('bang','英雄联盟','adc') print(s) # 我叫bang，我玩英雄联盟，我主玩的位置是adc # 第二种 s = '我叫{0}，今年{1}，性别{2}，我依然叫{0}'.format('小明','20','女') print(s) # 我叫小明，今年20，性别女，我依然叫小明 # 第三种 s = \"\"\" 我叫{name}，今年{age}，性别{sex}，我依然叫{name} \"\"\".format(age=20,sex='女',name='小明') print(s) # 我叫小明，今年20，性别女，我依然叫小明 is 判断字符串和数字组成name ='huanyuan135' print(name.isalnum()) # 判断字符串由字母或数字组成 True print(name.isalpha()) # 判断字符串只由字母组成 False print(name.isdigit()) # 判断字符串只由数字组成 False count 计算字符串中某个字符出现的次数s = 'cdcdcdcdcdjvnjfnvjfn:jsvnsvpojwpd' print(s.count('f')) # 计算这个字符串f字符出现的次数 2 print(s.count('d')) 6 print(s.count('d',0,8)) # 切片，顾首不顾尾，从零开始到第八个字符的前面截断 4 print(s.count('d',8)) # 从零开始数，第八个字符到结束 2 len 统计字符串长度s = 'cdcdcdcdcdjvnjfnvjfn:jsvnsvpojwpd' print(len(s)) # 内置函数 33","categories":[{"name":"Python","slug":"Python","permalink":"https://www.missf.top/categories/Python/"}],"tags":[{"name":"Python基础","slug":"Python基础","permalink":"https://www.missf.top/tags/Python%E5%9F%BA%E7%A1%80/"}]},{"title":"Python基础day01","slug":"Python基础day01","date":"2020-04-23T04:14:29.000Z","updated":"2020-04-24T13:03:27.391Z","comments":true,"path":"2020/04/23/Python基础day01/","link":"","permalink":"https://www.missf.top/2020/04/23/Python%E5%9F%BA%E7%A1%80day01/","excerpt":"","text":"Python发展史 创始人:Guido，国人叫龟叔，在1989年的圣诞节写出来的 2005 - 2012，龟叔去了谷歌工作，谷歌大量使用Python 2005年国内第一家使用Python的公司—豆瓣 2012年国内兴起云计算的热潮，Python借助OpenStack又火了一把 2014年AI兴起，大量的公司使用Python去写算法 直到2017年Python才真正进入大众的视野 Python的应用领域 WEB开发:最火的Python web框架Django，还有支持异步高并发的Tornado，短小精悍的flask 网络编程:支持高并发的Twisted网络框架 爬虫:Python在爬虫领域几乎是霸主地位，具有非常多的爬虫模块支持 云计算:著名的云计算框架OpenStack就是用Python写的 人工智能和数据分析:Python是目前人工智能和数据分析领域公认的必备语言 自动化运维:在Linux运维领域，Python能做很多事情，特别是处理数据的能力非常出色 游戏开发:Python能做游戏开发，但是使用Python开发游戏的公司可能没有这么多 编译型语言核心:通过编译器将人类写出来的代码一次性全部编译成机器语言让计算机可以识别和执行 代表语言：c，c++，golang，java 优点:执行效率高 缺点:开发效率低，不可以跨平台 一般多用于研究所、研究院，对执行效率要求高，大数据的计算、底层的开发 解释型语言核心:解释器逐行解释代码，再逐行执行（python是解释器，java中叫虚拟机） 代表语言:Python，php，Java，ruby 优点:开发效率高，可以跨平台，可移植性强 缺点:执行效率相对编译型语言慢 Python的优缺点优点 Python是一门高级语言，不用关心底层内存指针等等 由于Python开源的本质，Python已经被移植到许多平台，具备非常高的可移植性 Python可以嵌入c语言的代码，c语言也可以嵌入Python的代码，具备可嵌入性 大量现有的第三方库和模块的支持，使得开发效率大大提高 缺点 执行速度比编译型语言慢，如果运行Python花了0.1s，同样的代码c语言花了0.01秒，这样c就比Python快了十倍 Python源码是以明文形式存放的，如果项目要求源代码必须是加密的，一开始就不应该选择Python 线程不能利用多核CPU的问题，这也是Python被人诟病最多的一个缺点 变量官方解释:将程序中一些中间结果暂时存到内存中，供后面程序调用 变量命名规则 变量必须由数字，字母，下划线任意组合 不能是数字开头 不能使用Python中的关键字（具体关键字后面再介绍） 变量要具有描述性 变量不能过长 变量不能使用中文 尽量使用驼峰体 定义Python变量age1 = 12 age2 = age1 age3 = age2 age2 = 24 print (age1,age2,age3) 12 24 12 # 注意：程序中会大量的出现和使用变量，变量中会暂存一些少量的数据，给其他变量代指 Python常量常量，用于定义不变的值。例如:身份证号，圆周率，历史记载，新中国成立时间:1949101 使用常量Python中的常量可以改变（不像c改变常量会报错），但约定俗成Python中将变量全部变成大写，就是表示常量，将一些不想让别人改变的量设置成常量，放在文件最上面 Python注释对某一段代码做解释说明，一般是精简的代码，别人可能看不懂，需要做简单的解释 单行注释#好好学习，天天向上 多行注释'''被注释的内容''' \"\"\" 被注释的内容 \"\"\" 基础数据类型初识int 整型i1 = 10 i2 = 20 print (i1 * i2) # 200 str 字符串python中凡是用引号引起来的内容就是字符串数据类型 ret1 = '荒原饮露' ret2 = \"荒原饮露\" ret3 = \"\"\"荒原饮露\"\"\" ret4 = '''荒原饮露''' print (ret1,ret2,ret3,ret4) bool 布尔值true # 真 false # 假 用于判断条件，逻辑语句真假 单双引号搭配使用msg = \"I' m huangyuanyinlu,18 year\" print (msg) # I' m huangyuanyinlu,18 year 字符串相加相乘a1 = 'Alex' a2 = 'sb' print (a1 + a2) # Alexsb print (a1 * 10) # AlexAlexAlexAlexAlexAlexAlexAlexAlexAlex input 用户交互让用户输入用户名密码，得到用户输入的数据，起到了人与程序的交互作用 name = input(\"请输入你的名字：\") age = input(\"请输入你的年龄：\") sex = input(\"请输入你的性别：\") print (name,age,sex) # 这里注意一点:凡是input得到的值，都是字符串数据类型 将用户输入的变量进行拼接name = input(\"请输入你的名字：\") age = input(\"请输入你的年龄：\") sex = input(\"请输入你的性别：\") msg = '我的姓名是' + name + ',' + '我的年龄是' + age + ',' + '我的性别是' + sex + '.' print (msg) # 我的姓名是荒原饮露,我的年龄是23,我的性别是男 if 流程控制语句if 单分支age = input (\"请输入年龄:\") age = int(age) # Python3x之后，input得到的数据都是字符串类型 print (age,type(age)) # 输出变量的数据类型 if age > 10: print('你已经不是10岁的小孩了'） if 多分支jineng = input('请输入你的技能:') if jineng == '三分球': print('可以参加三分球大赛') elif jineng == '中投': print('可以参加中距离投篮') elif jineng == '突破': print('可以参加1V1对抗赛') else: print('买票进场吧') if 嵌套# 登陆示例 username = input('请输入用户名：') password = input('请输入密码：') if username == '荒原饮露': if password == '123': print('登录成功') else: print('密码错误') else: print('用户名不存在') # 买票示例 has_ticket = int(input('请输入车票号码:')) knife_length = int(input('请输入刀的长度:')) if has_ticket == 23: print('车票检查通过，准备开始安检') if knife_length &lt; 20: print('刀不超过20厘米，允许上车') else: print('刀超过20厘米，不允许上车') else: print(\"没有车票\") while 循环单次循环flag = True while flag: print('麦迪') print('科比') print('杜兰特') flag = False print('詹姆斯') # flag = False后面的依然会输出，因为运行到最后才会重新回到while 打印1到100# 方法一 count = 1 flag = True while flag: print(count) count = count + 1 if count == 101: flag = False # 方法二 count = 1 while count &lt; 101: print(count) count = count + 1 # 不要见方法二代码少就不去理解方法一，因为方法一包含flag = True的编程思想 计算1加到100count = 1 sum = 0 while count &lt;= 101: sum = sum + count count = count + 1 if count == 101: break print(sum) # break是直接终止循环 continue打印1到10，但是跳过7 count = 0 while count &lt; 10: count = count + 1 if count == 7: continue # continue是跳出本次循环，继续执行下一个循环 print(count) count = 0 while count &lt; 10: count = count + 1 if count == 7: # 判断count的值，直接+1 count = count + 1 print(count) 打印100以内的偶数# 利用对2取余去判断是否偶数 count = 0 while count &lt; 101: if count % 2 == 0: print(count) count = count + 1 # 每次自加2去打印偶数，虽然这样的做法不专业，但是也是体现灵活编程思维的一种方式 count = 0 while count &lt; 101: print(count) count = count + 2 while else# while else :只有在while循环被break打断时，才不会执行else程序，否则循环完之后一定会执行else程序 count = 0 while count &lt;= 5: count = count + 1 if count == 3:break print(\"Loop\",count) else: print(\"循环正常执行\") count = 0 while count &lt;= 5: count = count + 1 print(\"Loop\",count) else: print(\"循环正常执行\") # while循环没有被打断，打印完Loop1-6之后还是会打印循环正常执行","categories":[{"name":"Python","slug":"Python","permalink":"https://www.missf.top/categories/Python/"}],"tags":[{"name":"Python基础","slug":"Python基础","permalink":"https://www.missf.top/tags/Python%E5%9F%BA%E7%A1%80/"}]},{"title":"Hello World","slug":"Hello-World","date":"2020-04-21T04:14:29.000Z","updated":"2020-04-22T16:00:12.549Z","comments":true,"path":"2020/04/21/Hello-World/","link":"","permalink":"https://www.missf.top/2020/04/21/Hello-World/","excerpt":"","text":"所有无法深入问题本质的那些人，最终都将离开这个行业。","categories":[{"name":"Hello-World","slug":"Hello-World","permalink":"https://www.missf.top/categories/Hello-World/"}],"tags":[{"name":"Hello-World","slug":"Hello-World","permalink":"https://www.missf.top/tags/Hello-World/"}]}],"categories":[{"name":"Python","slug":"Python","permalink":"https://www.missf.top/categories/Python/"},{"name":"Hello-World","slug":"Hello-World","permalink":"https://www.missf.top/categories/Hello-World/"}],"tags":[{"name":"Python基础","slug":"Python基础","permalink":"https://www.missf.top/tags/Python%E5%9F%BA%E7%A1%80/"},{"name":"Hello-World","slug":"Hello-World","permalink":"https://www.missf.top/tags/Hello-World/"}]}