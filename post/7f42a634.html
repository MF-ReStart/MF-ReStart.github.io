<!DOCTYPE html>
<html>
<head>
    

    

    



    <meta name="chinaz-site-verification" content="EC6F7C888ADBF24B">
    <meta charset="utf-8">
    
    
    
    
    <title>Kubernetes 学习笔记 | 荒原饮露 | 可能是未来的架构师，也可能送外卖。</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="Kubernetes">
    <meta name="description" content="概述 此文档仅为个人的学习笔记，记录下来是为了以后遗忘时可以翻阅。最好的 Kubernetes 文档在 kubernetes.io，请大家去官网学习！  Kubernetes 是什么？Kubernetes 是一个可移植的、可扩展的开源平台，用于管理容器化的工作负载和服务，可促进声明式配置和自动化。Kubernetes 拥有一个庞大且快速增长的生态系统。Kubernetes 的服务、支持和工具广泛可">
<meta property="og:type" content="article">
<meta property="og:title" content="Kubernetes 学习笔记">
<meta property="og:url" content="https://www.missf.top/post/7f42a634.html">
<meta property="og:site_name" content="荒原饮露">
<meta property="og:description" content="概述 此文档仅为个人的学习笔记，记录下来是为了以后遗忘时可以翻阅。最好的 Kubernetes 文档在 kubernetes.io，请大家去官网学习！  Kubernetes 是什么？Kubernetes 是一个可移植的、可扩展的开源平台，用于管理容器化的工作负载和服务，可促进声明式配置和自动化。Kubernetes 拥有一个庞大且快速增长的生态系统。Kubernetes 的服务、支持和工具广泛可">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-03-08T10:46:59.000Z">
<meta property="article:modified_time" content="2021-03-09T10:37:41.560Z">
<meta property="article:author" content="荒原饮露">
<meta property="article:tag" content="Kubernetes">
<meta name="twitter:card" content="summary">
    
        <link rel="alternate" type="application/atom+xml" title="荒原饮露" href="/atom.xml">
    
    <link rel="shortcut icon" href="https://pic.imgdb.cn/item/5e9e7910c2a9a83be54641d1.png">
    <link rel="stylesheet" href="/css/style.css">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

<meta name="generator" content="Hexo 4.2.0"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(https://pic.imgdb.cn/item/5e9e78fbc2a9a83be5463167.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="https://pic.imgdb.cn/item/5e9e78b6c2a9a83be545fef2.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">荒原饮露</h5>
          <a href="mailto:mf_2013@163.com" title="mf_2013@163.com" class="mail">mf_2013@163.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                Archives
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                Tags
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                Categories
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/MF-ReStart" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">Kubernetes 学习笔记</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入你要搜索的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">Kubernetes 学习笔记</h1>
        <h5 class="subtitle">
            
                <time datetime="2021-03-08T10:46:59.000Z" itemprop="datePublished" class="page-time">
  2021-03-08
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Kubernetes/">Kubernetes</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#概述"><span class="post-toc-number">1.</span> <span class="post-toc-text">概述</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Kubernetes-是什么？"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">Kubernetes 是什么？</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#时光回溯"><span class="post-toc-number">1.1.1.</span> <span class="post-toc-text">时光回溯</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Kubernetes-能做什么？"><span class="post-toc-number">1.1.2.</span> <span class="post-toc-text">Kubernetes 能做什么？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Kubernetes-不是什么？"><span class="post-toc-number">1.1.3.</span> <span class="post-toc-text">Kubernetes 不是什么？</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Kubernetes-组件"><span class="post-toc-number">1.2.</span> <span class="post-toc-text">Kubernetes 组件</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#控制平面组件（Control-Plane-Components）"><span class="post-toc-number">1.2.1.</span> <span class="post-toc-text">控制平面组件（Control Plane Components）</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#kube-apiserver"><span class="post-toc-number">1.2.1.1.</span> <span class="post-toc-text">kube-apiserver</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#etcd"><span class="post-toc-number">1.2.1.2.</span> <span class="post-toc-text">etcd</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#kube-scheduler"><span class="post-toc-number">1.2.1.3.</span> <span class="post-toc-text">kube-scheduler</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#kube-controller-manager"><span class="post-toc-number">1.2.1.4.</span> <span class="post-toc-text">kube-controller-manager</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Node-组件"><span class="post-toc-number">1.2.2.</span> <span class="post-toc-text">Node 组件</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#kubelet"><span class="post-toc-number">1.2.2.1.</span> <span class="post-toc-text">kubelet</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#kube-proxy"><span class="post-toc-number">1.2.2.2.</span> <span class="post-toc-text">kube-proxy</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#容器运行时（Container-Runtime）"><span class="post-toc-number">1.2.2.3.</span> <span class="post-toc-text">容器运行时（Container Runtime）</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#插件（Addons）"><span class="post-toc-number">1.2.3.</span> <span class="post-toc-text">插件（Addons）</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#DNS"><span class="post-toc-number">1.2.3.1.</span> <span class="post-toc-text">DNS</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Web-界面（仪表盘）"><span class="post-toc-number">1.2.3.2.</span> <span class="post-toc-text">Web 界面（仪表盘）</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Ingress-Controller"><span class="post-toc-number">1.2.3.3.</span> <span class="post-toc-text">Ingress Controller</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#容器资源监控"><span class="post-toc-number">1.2.3.4.</span> <span class="post-toc-text">容器资源监控</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#集群层面日志"><span class="post-toc-number">1.2.3.5.</span> <span class="post-toc-text">集群层面日志</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Kubernetes-API"><span class="post-toc-number">1.3.</span> <span class="post-toc-text">Kubernetes API</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#使用-Kubernetes-对象"><span class="post-toc-number">1.4.</span> <span class="post-toc-text">使用 Kubernetes 对象</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#理解-Kubernetes-对象"><span class="post-toc-number">1.4.1.</span> <span class="post-toc-text">理解 Kubernetes 对象</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#理解-Kubernetes-对象-1"><span class="post-toc-number">1.4.1.1.</span> <span class="post-toc-text">理解 Kubernetes 对象</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#对象规约（Spec）与状态（Status）"><span class="post-toc-number">1.4.1.2.</span> <span class="post-toc-text">对象规约（Spec）与状态（Status）</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#描述-Kubernetes-对象"><span class="post-toc-number">1.4.1.3.</span> <span class="post-toc-text">描述 Kubernetes 对象</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#必需字段"><span class="post-toc-number">1.4.1.4.</span> <span class="post-toc-text">必需字段</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Kubernetes-对象管理"><span class="post-toc-number">1.4.2.</span> <span class="post-toc-text">Kubernetes 对象管理</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#命令式命令"><span class="post-toc-number">1.4.2.1.</span> <span class="post-toc-text">命令式命令</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#命令式对象配置"><span class="post-toc-number">1.4.2.2.</span> <span class="post-toc-text">命令式对象配置</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#对象名称和-IDs"><span class="post-toc-number">1.4.3.</span> <span class="post-toc-text">对象名称和 IDs</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#名字空间"><span class="post-toc-number">1.4.4.</span> <span class="post-toc-text">名字空间</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#何时使用多个名字空间"><span class="post-toc-number">1.4.4.1.</span> <span class="post-toc-text">何时使用多个名字空间</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#使用名字空间"><span class="post-toc-number">1.4.4.2.</span> <span class="post-toc-text">使用名字空间</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#查看名字空间"><span class="post-toc-number">1.4.4.2.1.</span> <span class="post-toc-text">查看名字空间</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#为请求设置名字空间"><span class="post-toc-number">1.4.4.2.2.</span> <span class="post-toc-text">为请求设置名字空间</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#设置名字空间偏好"><span class="post-toc-number">1.4.4.2.3.</span> <span class="post-toc-text">设置名字空间偏好</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#名字空间和-DNS"><span class="post-toc-number">1.4.4.3.</span> <span class="post-toc-text">名字空间和 DNS</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#并非所有对象都在名字空间中"><span class="post-toc-number">1.4.4.4.</span> <span class="post-toc-text">并非所有对象都在名字空间中</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#标签和选择算符"><span class="post-toc-number">1.4.5.</span> <span class="post-toc-text">标签和选择算符</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#动机"><span class="post-toc-number">1.4.5.1.</span> <span class="post-toc-text">动机</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#语法和字符集"><span class="post-toc-number">1.4.5.2.</span> <span class="post-toc-text">语法和字符集</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#标签选择算符"><span class="post-toc-number">1.4.5.3.</span> <span class="post-toc-text">标签选择算符</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#基于等值的需求"><span class="post-toc-number">1.4.5.3.1.</span> <span class="post-toc-text">基于等值的需求</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#基于集合的需求"><span class="post-toc-number">1.4.5.3.2.</span> <span class="post-toc-text">基于集合的需求</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#注解"><span class="post-toc-number">1.4.6.</span> <span class="post-toc-text">注解</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#为对象附加元数据"><span class="post-toc-number">1.4.6.0.1.</span> <span class="post-toc-text">为对象附加元数据</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#语法和字符集-1"><span class="post-toc-number">1.4.6.0.2.</span> <span class="post-toc-text">语法和字符集</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#字段选择器"><span class="post-toc-number">1.4.7.</span> <span class="post-toc-text">字段选择器</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#支持的字段"><span class="post-toc-number">1.4.7.0.1.</span> <span class="post-toc-text">支持的字段</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#链式选择器"><span class="post-toc-number">1.4.7.0.2.</span> <span class="post-toc-text">链式选择器</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#多种资源类型"><span class="post-toc-number">1.4.7.0.3.</span> <span class="post-toc-text">多种资源类型</span></a></li></ol></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Kubernetes-架构"><span class="post-toc-number">1.5.</span> <span class="post-toc-text">Kubernetes 架构</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#节点"><span class="post-toc-number">1.5.1.</span> <span class="post-toc-text">节点</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#管理"><span class="post-toc-number">1.5.1.1.</span> <span class="post-toc-text">管理</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#控制面到节点通信"><span class="post-toc-number">1.5.2.</span> <span class="post-toc-text">控制面到节点通信</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#节点到控制面"><span class="post-toc-number">1.5.2.1.</span> <span class="post-toc-text">节点到控制面</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#控制面到节点"><span class="post-toc-number">1.5.2.2.</span> <span class="post-toc-text">控制面到节点</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#API-服务器到-kubelet"><span class="post-toc-number">1.5.2.2.1.</span> <span class="post-toc-text">API 服务器到 kubelet</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#apiserver-到节点、Pod-和服务"><span class="post-toc-number">1.5.2.2.2.</span> <span class="post-toc-text">apiserver 到节点、Pod 和服务</span></a></li></ol></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#工作负载"><span class="post-toc-number">1.6.</span> <span class="post-toc-text">工作负载</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#pods"><span class="post-toc-number">1.6.1.</span> <span class="post-toc-text">pods</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#工作负载资源"><span class="post-toc-number">1.6.2.</span> <span class="post-toc-text">工作负载资源</span></a></li></ol></li></ol></li></ol>
        </nav>
    </aside>


<article id="post-Kubernetes 学习笔记"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">Kubernetes 学习笔记</h1>
        <div class="post-meta">
            <time class="post-time" title="2021-03-08 18:46:59" datetime="2021-03-08T10:46:59.000Z"  itemprop="datePublished">2021-03-08</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Kubernetes/">Kubernetes</a></li></ul>



            
<!--<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>-->
<!--    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>-->
<!--</span>-->


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><blockquote>
<p>此文档仅为个人的学习笔记，记录下来是为了以后遗忘时可以翻阅。最好的 Kubernetes 文档在 <a href="https://kubernetes.io/zh/docs/home/" target="_blank" rel="noopener">kubernetes.io</a>，请大家去官网学习！</p>
</blockquote>
<h2 id="Kubernetes-是什么？"><a href="#Kubernetes-是什么？" class="headerlink" title="Kubernetes 是什么？"></a>Kubernetes 是什么？</h2><p>Kubernetes 是一个可移植的、可扩展的开源平台，用于管理容器化的工作负载和服务，可促进声明式配置和自动化。Kubernetes 拥有一个庞大且快速增长的生态系统。Kubernetes 的服务、支持和工具广泛可用。</p>
<p>名称 Kubernetes 源于希腊语，意为“舵手”或“飞行员”。Google 在 2014 年开源了 Kubernetes 项目， Kubernetes 建立在 <a href="https://research.google/pubs/pub43438" target="_blank" rel="noopener">Google 在大规模运行生产工作负载方面拥有十几年的经验</a> 的基础上，结合了社区中最好的想法和实践。</p>
<h3 id="时光回溯"><a href="#时光回溯" class="headerlink" title="时光回溯"></a>时光回溯</h3><p>让我们回顾一下为什么 Kubernetes 如此有用。</p>
<p><strong>传统部署时代</strong>：</p>
<p>早期，各个组织机构在物理服务器上运行应用程序。无法为物理服务器中的应用程序定义资源边界，这会导致资源分配问题。 例如，如果在物理服务器上运行多个应用程序，则可能会出现一个应用程序占用大部分资源的情况， 结果可能导致其他应用程序的性能下降。 一种解决方案是在不同的物理服务器上运行每个应用程序，但是由于资源利用不足而无法扩展， 并且维护许多物理服务器的成本很高。</p>
<p><strong>虚拟化部署时代：</strong></p>
<p>作为解决方案，引入了虚拟化。虚拟化技术允许你在单个物理服务器的 CPU 上运行多个虚拟机（VM）。 虚拟化允许应用程序在 VM 之间隔离，并提供一定程度的安全，因为一个应用程序的信息不能被另一应用程序随意访问。</p>
<p>虚拟化技术能够更好地利用物理服务器上的资源，并且因为可轻松地添加或更新应用程序而可以实现更好的可伸缩性，降低硬件成本等等。</p>
<p>每个 VM 是一台完整的计算机，在虚拟化硬件之上运行所有组件，包括其自己的操作系统。</p>
<p><strong>容器部署时代：</strong></p>
<p>容器类似于 VM，但是它们具有被放宽的隔离属性，可以在应用程序之间共享操作系统（OS）。 因此，容器被认为是轻量级的。容器与 VM 类似，具有自己的文件系统、CPU、内存、进程空间等。 由于它们与基础架构分离，因此可以跨云和 OS 发行版本进行移植。</p>
<p>容器因具有许多优势而变得流行起来。下面列出的是容器的一些好处：</p>
<ul>
<li>敏捷应用程序的创建和部署：与使用 VM 镜像相比，提高了容器镜像创建的简便性和效率。</li>
<li>持续开发、集成和部署：通过快速简单的回滚（由于镜像不可变性），支持可靠且频繁的容器镜像构建和部署。</li>
<li>关注开发与运维的分离：在构建/发布时而不是在部署时创建应用程序容器镜像， 从而将应用程序与基础架构分离。</li>
<li>可观察性不仅可以显示操作系统级别的信息和指标，还可以显示应用程序的运行状况和其他指标信号。</li>
<li>跨开发、测试和生产的环境一致性：在便携式计算机上与在云中相同地运行。</li>
<li>跨云和操作系统发行版本的可移植性：可在 Ubuntu、RHEL、CoreOS、本地、 Google Kubernetes Engine 和其他任何地方运行。</li>
<li>以应用程序为中心的管理：提高抽象级别，从在虚拟硬件上运行 OS 到使用逻辑资源在 OS 上运行应用程序。</li>
<li>松散耦合、分布式、弹性、解放的微服务：应用程序被分解成较小的独立部分， 并且可以动态部署和管理 - 而不是在一台大型单机上整体运行。</li>
<li>资源隔离：可预测的应用程序性能。</li>
<li>资源利用：高效率和高密度。</li>
</ul>
<h3 id="Kubernetes-能做什么？"><a href="#Kubernetes-能做什么？" class="headerlink" title="Kubernetes 能做什么？"></a>Kubernetes 能做什么？</h3><p>容器是打包和运行应用程序的最好方式。在生产环境中，你需要管理运行应用程序的容器，并确保不会停机。 例如，如果一个容器发生故障，则需要启动另一个容器。如果由系统处理此行为，会不会更容易？</p>
<p>这就是 Kubernetes 来解决这些问题的方法！ Kubernetes 为你提供了一个可弹性运行分布式系统的框架。 Kubernetes 会满足你的扩展要求、故障转移、部署模式等。 例如，Kubernetes 可以轻松管理系统的 Canary 部署。</p>
<p>Kubernetes 为你提供：</p>
<ul>
<li><p>服务发现和负载均衡</p>
<p>Kubernetes 可以使用 DNS 名称或自己的 IP 地址公开容器，如果进入容器的流量很大， Kubernetes 可以负载均衡并分配网络流量，从而使部署稳定。</p>
</li>
<li><p>存储编排</p>
<p>Kubernetes 允许你自动挂载你选择的存储系统，例如本地存储、公共云提供商等。</p>
</li>
<li><p>自动部署和回滚</p>
<p>你可以使用 Kubernetes 描述已部署容器的所需状态，它可以以受控的速率将实际状态更改为期望状态。例如，你可以自动化 Kubernetes 来为你的部署创建新容器， 删除现有容器并将它们的所有资源用于新容器。</p>
</li>
<li><p>自动完成装箱计算</p>
<p>Kubernetes 允许你指定每个容器所需 CPU 和内存（RAM）。 当容器指定了资源请求时，Kubernetes 可以做出更好的决策来管理容器的资源。</p>
</li>
<li><p>自我修复</p>
<p>Kubernetes 重新启动失败的容器、替换容器、杀死不响应用户定义的运行状况检查的容器，并且在准备好服务之前不将其通告给客户端。</p>
</li>
<li><p>密钥与配置管理</p>
<p>Kubernetes 允许你存储和管理敏感信息，例如密码、OAuth 令牌和 ssh 密钥。 你可以在不重建容器镜像的情况下部署和更新密钥和应用程序配置，也无需在堆栈配置中暴露密钥。</p>
</li>
</ul>
<h3 id="Kubernetes-不是什么？"><a href="#Kubernetes-不是什么？" class="headerlink" title="Kubernetes 不是什么？"></a>Kubernetes 不是什么？</h3><p>Kubernetes 不是传统的、包罗万象的 PaaS（平台即服务）系统。 由于 Kubernetes 在容器级别而不是在硬件级别运行，它提供了 PaaS 产品共有的一些普遍适用的功能， 例如部署、扩展、负载均衡、日志记录和监视。 但是，Kubernetes 不是单体系统，默认解决方案都是可选和可插拔的。 Kubernetes 提供了构建开发人员平台的基础，但是在重要的地方保留了用户的选择和灵活性。</p>
<p>Kubernetes：</p>
<ul>
<li><p>不限制支持的应用程序类型。 Kubernetes 旨在支持极其多种多样的工作负载，包括无状态、有状态和数据处理工作负载。 如果应用程序可以在容器中运行，那么它应该可以在 Kubernetes 上很好地运行。</p>
</li>
<li><p>不部署源代码，也不构建你的应用程序。 持续集成(CI)、交付和部署（CI/CD）工作流取决于组织的文化和偏好以及技术要求。</p>
</li>
<li><p>不提供应用程序级别的服务作为内置服务，例如中间件（例如，消息中间件）、 数据处理框架（例如，Spark）、数据库（例如，mysql）、缓存、集群存储系统 （例如，Ceph）。这样的组件可以在 Kubernetes 上运行，并且/或者可以由运行在 Kubernetes 上的应用程序通过可移植机制（例如， <a href="https://openservicebrokerapi.org/" target="_blank" rel="noopener">开放服务代理</a>）来访问。</p>
</li>
<li><p>不要求日志记录、监视或警报解决方案。 它提供了一些集成作为概念证明，并提供了收集和导出指标的机制。</p>
</li>
<li><p>不提供或不要求配置语言/系统（例如 jsonnet），它提供了声明性 API， 该声明性 API 可以由任意形式的声明性规范所构成。</p>
</li>
<li><p>不提供也不采用任何全面的机器配置、维护、管理或自我修复系统。</p>
</li>
<li><p>此外，Kubernetes 不仅仅是一个编排系统，实际上它消除了编排的需要。 编排的技术定义是执行已定义的工作流程：首先执行 A，然后执行 B，再执行 C。 相比之下，Kubernetes 包含一组独立的、可组合的控制过程， 这些过程连续地将当前状态驱动到所提供的所需状态。 如何从 A 到 C 的方式无关紧要，也不需要集中控制，这使得系统更易于使用 且功能更强大、系统更健壮、更为弹性和可扩展。</p>
</li>
</ul>
<h2 id="Kubernetes-组件"><a href="#Kubernetes-组件" class="headerlink" title="Kubernetes 组件"></a>Kubernetes 组件</h2><p>当你部署完 Kubernetes, 即拥有了一个完整的集群。</p>
<p>一个 Kubernetes 集群由一组被称作节点的机器组成。这些节点上运行 Kubernetes 所管理的容器化应用。集群具有至少一个工作节点。</p>
<p>工作节点托管作为应用负载的组件的 Pod 。控制平面管理集群中的工作节点和 Pod 。 为集群提供故障转移和高可用性，这些控制平面一般跨多主机运行，集群跨多个节点运行。</p>
<p>本文档概述了交付正常运行的 Kubernetes 集群所需的各种组件。</p>
<h3 id="控制平面组件（Control-Plane-Components）"><a href="#控制平面组件（Control-Plane-Components）" class="headerlink" title="控制平面组件（Control Plane Components）"></a>控制平面组件（Control Plane Components）</h3><p>控制平面的组件对集群做出全局决策（比如调度），以及检测和响应集群事件（例如，当不满足部署的 <code>replicas</code> 字段时，启动新的 pod）。</p>
<p>控制平面组件可以在集群中的任何节点上运行。 然而，为了简单起见，设置脚本通常会在同一个计算机（一般使用 master 节点）上启动所有控制平面组件，并且不会在此计算机上运行用户容器。 </p>
<h4 id="kube-apiserver"><a href="#kube-apiserver" class="headerlink" title="kube-apiserver"></a>kube-apiserver</h4><p>API 服务器是 Kubernetes 控制面的组件， 该组件公开了 Kubernetes API。 API 服务器是 Kubernetes 控制面的前端。</p>
<p>Kubernetes API 服务器的主要实现是 kube-apiserver。 kube-apiserver 设计上考虑了水平伸缩，也就是说，它可通过部署多个实例进行伸缩。 你可以运行 kube-apiserver 的多个实例，并在这些实例之间平衡流量。</p>
<h4 id="etcd"><a href="#etcd" class="headerlink" title="etcd"></a>etcd</h4><p>etcd 是兼具一致性和高可用性的键值数据库，可以作为保存 Kubernetes 所有集群数据的后台数据库。</p>
<p>您的 Kubernetes 集群的 etcd 数据库通常需要有个备份计划。</p>
<p>要了解 etcd 更深层次的信息，请参考 <a href="https://etcd.io/docs/" target="_blank" rel="noopener">etcd 文档</a>。</p>
<h4 id="kube-scheduler"><a href="#kube-scheduler" class="headerlink" title="kube-scheduler"></a>kube-scheduler</h4><p>控制平面组件，负责监视新创建的、未指定运行节点（node）的 Pods，选择节点让 Pod 在上面运行。</p>
<p>调度决策考虑的因素包括单个 Pod 和 Pod 集合的资源需求、硬件/软件/策略约束、亲和性和反亲和性规范、数据位置、工作负载间的干扰和最后时限。</p>
<h4 id="kube-controller-manager"><a href="#kube-controller-manager" class="headerlink" title="kube-controller-manager"></a>kube-controller-manager</h4><p>在主节点上运行控制器的组件。</p>
<p>从逻辑上讲，每个控制器都是一个单独的进程， 但是为了降低复杂性，它们都被编译到同一个可执行文件，并在一个进程中运行。</p>
<p>这些控制器包括:</p>
<ul>
<li><p>节点控制器（Node Controller）: 负责在节点出现故障时进行通知和响应</p>
</li>
<li><p>副本控制器（Replication Controller）: 负责为系统中的每个副本控制器对象维护正确数量的 Pod</p>
</li>
<li><p>端点控制器（Endpoints Controller）: 填充端点(Endpoints)对象(即加入 Service 与 Pod)</p>
</li>
<li><p>服务帐户和令牌控制器（Service Account &amp; Token Controllers）: 为新的命名空间创建默认帐户和 API 访问令牌</p>
</li>
</ul>
<h3 id="Node-组件"><a href="#Node-组件" class="headerlink" title="Node 组件"></a>Node 组件</h3><p>节点组件在每个节点上运行，维护运行的 Pod 并提供 Kubernetes 运行环境。</p>
<h4 id="kubelet"><a href="#kubelet" class="headerlink" title="kubelet"></a>kubelet</h4><p>一个在集群中每个节点（node）上运行的代理。 它保证容器（containers）都 运行在 Pod 中。</p>
<p>kubelet 接收一组通过各类机制提供给它的 PodSpecs，确保这些 PodSpecs 中描述的容器处于运行状态且健康。 kubelet 不会管理不是由 Kubernetes 创建的容器。</p>
<h4 id="kube-proxy"><a href="#kube-proxy" class="headerlink" title="kube-proxy"></a>kube-proxy</h4><p>kube-proxy 是集群中每个节点上运行的网络代理， 实现 Kubernetes 服务（Service） 概念的一部分。</p>
<p>kube-proxy 维护节点上的网络规则。这些网络规则允许从集群内部或外部的网络会话与 Pod 进行网络通信。</p>
<p>如果操作系统提供了数据包过滤层并可用的话，kube-proxy 会通过它来实现网络规则。否则， kube-proxy 仅转发流量本身。</p>
<h4 id="容器运行时（Container-Runtime）"><a href="#容器运行时（Container-Runtime）" class="headerlink" title="容器运行时（Container Runtime）"></a>容器运行时（Container Runtime）</h4><p>容器运行环境是负责运行容器的软件。</p>
<p>Kubernetes 支持多个容器运行环境: Docker、 containerd、CRI-O 以及任何实现 <a href="https://github.com/kubernetes/community/blob/master/contributors/devel/sig-node/container-runtime-interface.md" target="_blank" rel="noopener">Kubernetes CRI (容器运行环境接口)</a>。</p>
<h3 id="插件（Addons）"><a href="#插件（Addons）" class="headerlink" title="插件（Addons）"></a>插件（Addons）</h3><p>插件使用 Kubernetes 资源（DaemonSet、 Deployment等）实现集群功能。 因为这些插件提供集群级别的功能，插件中命名空间域的资源属于 kube-system 命名空间。</p>
<h4 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h4><p>尽管其他插件都并非严格意义上的必需组件，但几乎所有 Kubernetes 集群都应该有<a href="https://kubernetes.io/zh/docs/concepts/services-networking/dns-pod-service/" target="_blank" rel="noopener">集群 DNS</a>， 因为很多示例都需要 DNS 服务。</p>
<p>集群 DNS 是一个 DNS 服务器，和环境中的其他 DNS 服务器一起工作，它为 Kubernetes 服务提供 DNS 记录。</p>
<p>Kubernetes 启动的容器自动将此 DNS 服务器包含在其 DNS 搜索列表中。</p>
<h4 id="Web-界面（仪表盘）"><a href="#Web-界面（仪表盘）" class="headerlink" title="Web 界面（仪表盘）"></a>Web 界面（仪表盘）</h4><p><a href="https://kubernetes.io/zh/docs/tasks/access-application-cluster/web-ui-dashboard/" target="_blank" rel="noopener">Dashboard</a> 是Kubernetes 集群的通用、基于 Web 的用户界面。 它使用户可以管理集群中运行的应用程序以及集群本身并进行故障排除。</p>
<h4 id="Ingress-Controller"><a href="#Ingress-Controller" class="headerlink" title="Ingress Controller"></a>Ingress Controller</h4><p>为了让 Ingress 资源工作，集群必须有一个正在运行的 Ingress 控制器。</p>
<h4 id="容器资源监控"><a href="#容器资源监控" class="headerlink" title="容器资源监控"></a>容器资源监控</h4><p>容器资源监控将关于容器的一些常见的时间序列度量值保存到一个集中的数据库中，并提供用于浏览这些数据的界面，参考 <a href="https://prometheus.io/" target="_blank" rel="noopener">Prometheus 项目</a> 结合 <a href="https://grafana.com/" target="_blank" rel="noopener">Grafana 项目</a>。</p>
<h4 id="集群层面日志"><a href="#集群层面日志" class="headerlink" title="集群层面日志"></a>集群层面日志</h4><p><a href="https://kubernetes.io/zh/docs/concepts/cluster-administration/logging/" target="_blank" rel="noopener">集群层面日志</a> 机制负责将容器的日志数据 保存到一个集中的日志存储中，该存储能够提供搜索和浏览接口。</p>
<h2 id="Kubernetes-API"><a href="#Kubernetes-API" class="headerlink" title="Kubernetes API"></a>Kubernetes API</h2><p>Kubernetes 控制面的核心是 API 服务器。 API 服务器负责提供 HTTP API，以供用户、集群中的不同部分和集群外部组件相互通信。</p>
<p>Kubernetes API 使你可以查询和操纵 Kubernetes API 中对象（例如：Pod、Namespace、ConfigMap 和 Event）的状态。</p>
<p>大部分操作都可以通过 kubectl 命令行接口或类似 kubeadm 这类命令行工具来执行， 这些工具在背后也是调用 API。不过，你也可以使用 REST 调用来访问这些 API。</p>
<h2 id="使用-Kubernetes-对象"><a href="#使用-Kubernetes-对象" class="headerlink" title="使用 Kubernetes 对象"></a>使用 Kubernetes 对象</h2><h3 id="理解-Kubernetes-对象"><a href="#理解-Kubernetes-对象" class="headerlink" title="理解 Kubernetes 对象"></a>理解 Kubernetes 对象</h3><p>本页说明了 Kubernetes 对象在 Kubernetes API 中是如何表示的，以及如何在 <code>.yaml</code> 格式的文件中表示。</p>
<h4 id="理解-Kubernetes-对象-1"><a href="#理解-Kubernetes-对象-1" class="headerlink" title="理解 Kubernetes 对象"></a>理解 Kubernetes 对象</h4><p>在 Kubernetes 系统中，Kubernetes 对象是持久化的实体。 Kubernetes 使用这些实体去表示整个集群的状态。特别地，它们描述了如下信息：</p>
<ul>
<li>哪些容器化应用在运行（以及在哪些节点上运行）</li>
<li>可以被应用使用的资源</li>
<li>关于应用运行时表现的策略，比如重启策略、升级策略，以及容错策略</li>
</ul>
<p>Kubernetes 对象是 “目标性记录” —— 一旦创建对象，Kubernetes 系统将持续工作以确保对象存在。 通过创建对象，本质上是在告知 Kubernetes 系统，所需要的集群工作负载看起来是什么样子的， 这就是 Kubernetes 集群的期望状态（Desired State）。</p>
<p>操作 Kubernetes 对象 —— 无论是创建、修改，或者删除 —— 都需要使用 <a href="https://kubernetes.io/zh/docs/concepts/overview/kubernetes-api" target="_blank" rel="noopener">Kubernetes API</a>。 比如，当使用 kubectl 命令行接口时，CLI 会执行必要的 Kubernetes API 调用， 也可以在程序中使用 <a href="https://kubernetes.io/zh/docs/reference/using-api/client-libraries/" target="_blank" rel="noopener">客户端库</a>直接调用 Kubernetes API。</p>
<h4 id="对象规约（Spec）与状态（Status）"><a href="#对象规约（Spec）与状态（Status）" class="headerlink" title="对象规约（Spec）与状态（Status）"></a>对象规约（Spec）与状态（Status）</h4><p>几乎每个 Kubernetes 对象包含两个嵌套的对象字段，它们负责管理对象的配置： 对象 <code>spec</code>（规约）和对象 <code>status</code>（状态） 。 对于具有 <code>spec</code> 的对象，你必须在创建对象时设置其内容，描述你希望对象所具有的特征： <em>期望状态（Desired State）</em> 。</p>
<p><code>status</code> 描述了对象的 <em>当前状态（Current State）</em>，它是由 Kubernetes 系统和组件设置并更新的。在任何时刻，Kubernetes <a href="https://kubernetes.io/zh/docs/reference/glossary/?all=true#term-control-plane" target="_blank" rel="noopener">控制平面</a> 都一直积极地管理着对象的实际状态，以使之与期望状态相匹配。</p>
<h4 id="描述-Kubernetes-对象"><a href="#描述-Kubernetes-对象" class="headerlink" title="描述 Kubernetes 对象"></a>描述 Kubernetes 对象</h4><p>创建 Kubernetes 对象时，必须提供对象的规约，用来描述该对象的期望状态， 以及关于对象的一些基本信息（例如名称）。 当使用 Kubernetes API 创建对象时（或者直接创建，或者基于<code>kubectl</code>）， API 请求必须在请求体中包含 JSON 格式的信息。 大多数情况下，需要在 <code>.yaml</code> 文件中为 <code>kubectl</code> 提供这些信息。<code>kubectl</code> 在发起 API 请求时，会将这些信息转换成 JSON 格式。</p>
<h4 id="必需字段"><a href="#必需字段" class="headerlink" title="必需字段"></a>必需字段</h4><p>在想要创建的 Kubernetes 对象对应的 <code>.yaml</code> 文件中，需要配置如下的字段：</p>
<ul>
<li><code>apiVersion</code> - 创建该对象所使用的 Kubernetes API 的版本</li>
<li><code>kind</code> - 想要创建的对象的类别</li>
<li><code>metadata</code> - 帮助唯一性标识对象的一些数据，包括一个 <code>name</code> 字符串、UID 和可选的 <code>namespace</code></li>
</ul>
<h3 id="Kubernetes-对象管理"><a href="#Kubernetes-对象管理" class="headerlink" title="Kubernetes 对象管理"></a>Kubernetes 对象管理</h3><h4 id="命令式命令"><a href="#命令式命令" class="headerlink" title="命令式命令"></a>命令式命令</h4><p>用命令式命令时，用户可以在集群中的活动对象上进行操作。用户将操作传给 <code>kubectl</code> 命令作为参数或标志。</p>
<p>这是开始或者在集群中运行一次性任务的最简单方法。因为这个技术直接在活动对象上操作，所以它不提供以前配置的历史记录。</p>
<p>通过创建 Deployment 对象来运行 nginx 容器的实例：</p>
<pre class="line-numbers language-bash"><code class="language-bash">kubectl run nginx --image nginx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h4 id="命令式对象配置"><a href="#命令式对象配置" class="headerlink" title="命令式对象配置"></a>命令式对象配置</h4><p>在命令式对象配置中，kubectl 命令指定操作（创建，替换等），可选标志和至少一个文件名。指定的文件必须包含 YAML 或 JSON 格式的对象的完整定义。</p>
<p>创建配置文件中定义的对象：</p>
<pre class="line-numbers language-bash"><code class="language-bash">kubectl create -f nginx.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h3 id="对象名称和-IDs"><a href="#对象名称和-IDs" class="headerlink" title="对象名称和 IDs"></a>对象名称和 IDs</h3><p>集群中的每一个对象都有一个名称来标识在同类资源中的唯一性。</p>
<p>每个 Kubernetes 对象也有一个 UID 来标识在整个集群中的唯一性。</p>
<p>比如，在同一个名字空间中有一个名为 myapp-1234 的 Pod, 但是可以命名一个 Pod 和一个 Deployment 同为 myapp-1234.</p>
<p>对于用户提供的非唯一性的属性，Kubernetes 提供了 标签（Labels）和 注解（Annotation）机制。</p>
<h3 id="名字空间"><a href="#名字空间" class="headerlink" title="名字空间"></a>名字空间</h3><p>Kubernetes 支持多个虚拟集群，它们底层依赖于同一个物理集群。 这些虚拟集群被称为名字空间。</p>
<h4 id="何时使用多个名字空间"><a href="#何时使用多个名字空间" class="headerlink" title="何时使用多个名字空间"></a>何时使用多个名字空间</h4><p>名字空间适用于存在很多跨多个团队或项目的用户的场景。对于只有几到几十个用户的集群，根本不需要创建或考虑名字空间。当需要名称空间提供的功能时，请开始使用它们。</p>
<p>名字空间为名称提供了一个范围。资源的名称需要在名字空间内是唯一的，但不能跨名字空间。 名字空间不能相互嵌套，每个 Kubernetes 资源只能在一个名字空间中。</p>
<p>名字空间是在多个用户之间划分集群资源的一种方法（通过资源配额）。</p>
<p>不需要使用多个名字空间来分隔轻微不同的资源，例如同一软件的不同版本： 使用标签来区分同一名字空间中的不同资源。</p>
<h4 id="使用名字空间"><a href="#使用名字空间" class="headerlink" title="使用名字空间"></a>使用名字空间</h4><p>名字空间的创建和删除在<a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/namespaces/" target="_blank" rel="noopener">名字空间的管理指南文档</a>描述。</p>
<p><strong>说明：</strong> 避免使用前缀 <code>kube-</code> 创建名字空间，因为它是为 Kubernetes 系统名字空间保留的。</p>
<h5 id="查看名字空间"><a href="#查看名字空间" class="headerlink" title="查看名字空间"></a>查看名字空间</h5><p>你可以使用以下命令列出集群中现存的名字空间：</p>
<pre class="line-numbers language-bash"><code class="language-bash">kubectl get namespace<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>Kubernetes 会创建四个初始名字空间：</p>
<ul>
<li><code>default</code> 没有指明使用其它名字空间的对象所使用的默认名字空间</li>
<li><code>kube-system</code> Kubernetes 系统创建对象所使用的名字空间</li>
<li><code>kube-public</code> 这个名字空间是自动创建的，所有用户（包括未经过身份验证的用户）都可以读取它。 这个名字空间主要用于集群使用，以防某些资源在整个集群中应该是可见和可读的。 这个名字空间的公共方面只是一种约定，而不是要求。</li>
<li><code>kube-node-lease</code> 此名字空间用于与各个节点相关的租期（Lease）对象； 此对象的设计使得集群规模很大时节点心跳检测性能得到提升。</li>
</ul>
<h5 id="为请求设置名字空间"><a href="#为请求设置名字空间" class="headerlink" title="为请求设置名字空间"></a>为请求设置名字空间</h5><p>要为当前请求设置名字空间，请使用 <code>--namespace</code> 参数。</p>
<p>例如：</p>
<pre class="line-numbers language-shell"><code class="language-shell">kubectl run nginx --image=nginx --namespace=<名字空间名称>
kubectl get pods --namespace=<名字空间名称><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h5 id="设置名字空间偏好"><a href="#设置名字空间偏好" class="headerlink" title="设置名字空间偏好"></a>设置名字空间偏好</h5><p>你可以永久保存名字空间，以用于对应上下文中所有后续 kubectl 命令。</p>
<h4 id="名字空间和-DNS"><a href="#名字空间和-DNS" class="headerlink" title="名字空间和 DNS"></a>名字空间和 DNS</h4><p>当你创建一个服务 时， Kubernetes 会创建一个相应的 DNS 条目。</p>
<p>该条目的形式是 &lt;服务名称&gt;.&lt;名字空间名称&gt;.svc.cluster.local，这意味着如果容器只使用 &lt;服务名称&gt;，它将被解析到本地名字空间的服务。这对于跨多个名字空间（如开发、分级和生产） 使用相同的配置非常有用。如果你希望跨名字空间访问，则需要使用完全限定域名（FQDN）。</p>
<h4 id="并非所有对象都在名字空间中"><a href="#并非所有对象都在名字空间中" class="headerlink" title="并非所有对象都在名字空间中"></a>并非所有对象都在名字空间中</h4><p>大多数 kubernetes 资源（例如 Pod、Service、副本控制器等）都位于某些名字空间中。 但是名字空间资源本身并不在名字空间中。而且底层资源，例如 <a href="https://kubernetes.io/zh/docs/concepts/architecture/nodes/" target="_blank" rel="noopener">节点</a> 和持久化卷不属于任何名字空间。</p>
<p>查看哪些 Kubernetes 资源在名字空间中，哪些不在名字空间中：</p>
<pre class="line-numbers language-shell"><code class="language-shell"># 位于名字空间中的资源
kubectl api-resources --namespaced=true

# 不在名字空间中的资源
kubectl api-resources --namespaced=false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="标签和选择算符"><a href="#标签和选择算符" class="headerlink" title="标签和选择算符"></a>标签和选择算符</h3><p>标签（Labels）是附加到 Kubernetes 对象（比如 Pods）上的键值对。 标签旨在用于指定对用户有意义且相关的对象的标识属性，但不直接对核心系统有语义含义。 标签可以用于组织和选择对象的子集。标签可以在创建时附加到对象，随后可以随时添加和修改。 每个对象都可以定义一组键/值标签。每个键对于给定对象必须是唯一的。</p>
<h4 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h4><p>标签使用户能够以松散耦合的方式将他们自己的组织结构映射到系统对象，而无需客户端存储这些映射。</p>
<p>服务部署和批处理流水线通常是多维实体（例如，多个分区或部署、多个发行序列、多个层，每层多个微服务）。 管理通常需要交叉操作，这打破了严格的层次表示的封装，特别是由基础设施而不是用户确定的严格的层次结构。</p>
<p>示例标签：</p>
<ul>
<li><code>&quot;release&quot; : &quot;stable&quot;</code>, <code>&quot;release&quot; : &quot;canary&quot;</code></li>
<li><code>&quot;environment&quot; : &quot;dev&quot;</code>, <code>&quot;environment&quot; : &quot;qa&quot;</code>, <code>&quot;environment&quot; : &quot;production&quot;</code></li>
<li><code>&quot;tier&quot; : &quot;frontend&quot;</code>, <code>&quot;tier&quot; : &quot;backend&quot;</code>, <code>&quot;tier&quot; : &quot;cache&quot;</code></li>
<li><code>&quot;partition&quot; : &quot;customerA&quot;</code>, <code>&quot;partition&quot; : &quot;customerB&quot;</code></li>
<li><code>&quot;track&quot; : &quot;daily&quot;</code>, <code>&quot;track&quot; : &quot;weekly&quot;</code></li>
</ul>
<p>这些只是常用标签的例子; 你可以任意制定自己的约定。请记住，对于给定对象标签的键必须是唯一的。</p>
<h4 id="语法和字符集"><a href="#语法和字符集" class="headerlink" title="语法和字符集"></a>语法和字符集</h4><p>标签是键值对。有效的标签键有两个段：可选的前缀和名称，用斜杠（/）分隔。 名称段是必需的，必须小于等于 63 个字符，以字母数字字符（[a-z0-9A-Z]）开头和结尾， 带有破折号（-），下划线（_），点（ .）和之间的字母数字。 前缀是可选的。如果指定，前缀必须是 DNS 子域：由点（.）分隔的一系列 DNS 标签，总共不超过 253 个字符， 后跟斜杠（/）。</p>
<p>如果省略前缀，则假定标签键对用户是私有的。 向最终用户对象添加标签的自动系统组件（例如 kube-scheduler、kube-controller-manager、 kube-apiserver、kubectl 或其他第三方自动化工具）必须指定前缀。</p>
<p>kubernetes.io/ 前缀是为 Kubernetes 核心组件保留的。</p>
<p>有效标签值必须为 63 个字符或更少，并且必须为空或以字母数字字符（[a-z0-9A-Z]）开头和结尾， 中间可以包含破折号（-）、下划线（_）、点（.）和字母或数字。</p>
<h4 id="标签选择算符"><a href="#标签选择算符" class="headerlink" title="标签选择算符"></a>标签选择算符</h4><p>与名称和 UID 不同， 标签不支持唯一性。通常，我们希望许多对象携带相同的标签。</p>
<p>通过 标签选择算符，客户端/用户可以识别一组对象。标签选择算符是 Kubernetes 中的核心分组原语。</p>
<p>API 目前支持两种类型的选择算符：基于等值的 和 基于集合的。 标签选择算符可以由逗号分隔的多个 需求 组成。 在多个需求的情况下，必须满足所有要求，因此逗号分隔符充当逻辑 与（&amp;&amp;）运算符。</p>
<p>空标签选择算符或者未指定的选择算符的语义取决于上下文， 支持使用选择算符的 API 类别应该将算符的合法性和含义用文档记录下来。</p>
<h5 id="基于等值的需求"><a href="#基于等值的需求" class="headerlink" title="基于等值的需求"></a>基于等值的需求</h5><p>基于等值 或 基于不等值 的需求允许按标签键和值进行过滤。 匹配对象必须满足所有指定的标签约束，尽管它们也可能具有其他标签。 可接受的运算符有 = 、 == 和 != 三种。 前两个表示相等（并且只是同义词），而后者表示不相等。例如：</p>
<pre class="line-numbers language-shell"><code class="language-shell">environment = production
tier != frontend<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h5 id="基于集合的需求"><a href="#基于集合的需求" class="headerlink" title="基于集合的需求"></a>基于集合的需求</h5><p>基于集合 的标签需求允许你通过一组值来过滤键。 支持三种操作符：in、notin 和 exists (只可以用在键标识符上)。例如：</p>
<pre class="line-numbers language-shell"><code class="language-shell">environment in (production, qa)
tier notin (frontend, backend)
partition
!partition<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>第一个示例选择了所有键等于 environment 并且值等于 production 或者 qa 的资源。</li>
<li>第二个示例选择了所有键等于 tier 并且值不等于 frontend 或者 backend 的资源，以及所有没有 tier 键标签的资源。</li>
<li>第三个示例选择了所有包含了有 partition 标签的资源；没有校验它的值。</li>
<li>第四个示例选择了所有没有 partition 标签的资源；没有校验它的值。 类似地，逗号分隔符充当 与 运算符。因此，使用 partition 键（无论为何值）和 environment 不同于 qa 来过滤资源可以使用 partition, environment notin（qa) 来实现。</li>
</ul>
<p>基于集合的标签选择算符是相等标签选择算符的一般形式，因为 environment=production 等同于 environment in（production）；!= 和 notin 也是类似的。</p>
<p>基于集合的要求可以与基于相等的要求混合使用。例如：partition in (customerA, customerB),environment!=qa。</p>
<h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><p>你可以使用 Kubernetes 注解为对象附加任意的非标识的元数据。客户端程序（例如工具和库）能够获取这些元数据信息。</p>
<h5 id="为对象附加元数据"><a href="#为对象附加元数据" class="headerlink" title="为对象附加元数据"></a>为对象附加元数据</h5><p>你可以使用标签或注解将元数据附加到 Kubernetes 对象。 标签可以用来选择对象和查找满足某些条件的对象集合。 相反，注解不用于标识和选择对象。 注解中的元数据，可以很小，也可以很大，可以是结构化的，也可以是非结构化的，能够包含标签不允许的字符。</p>
<p>注解和标签一样，是键/值对:</p>
<pre class="line-numbers language-json"><code class="language-json"><span class="token property">"metadata"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
  <span class="token property">"annotations"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token property">"key1"</span> <span class="token operator">:</span> <span class="token string">"value1"</span><span class="token punctuation">,</span>
    <span class="token property">"key2"</span> <span class="token operator">:</span> <span class="token string">"value2"</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="语法和字符集-1"><a href="#语法和字符集-1" class="headerlink" title="语法和字符集"></a>语法和字符集</h5><p>注解（Annotations）存储的形式是键/值对。有效的注解键分为两部分： 可选的前缀和名称，以斜杠（/）分隔。 名称段是必需项，并且必须在63个字符以内，以字母数字字符（[a-z0-9A-Z]）开头和结尾， 并允许使用破折号（-），下划线（_），点（.）和字母数字。 前缀是可选的。如果指定，则前缀必须是DNS子域：一系列由点（.）分隔的DNS标签， 总计不超过253个字符，后跟斜杠（/）。 如果省略前缀，则假定注解键对用户是私有的。 由系统组件添加的注解 （例如，kube-scheduler，kube-controller-manager，kube-apiserver，kubectl 或其他第三方组件），必须为终端用户添加注解前缀。</p>
<p>kubernetes.io/ 和 k8s.io/ 前缀是为 Kubernetes 核心组件保留的。</p>
<p>例如，下面是一个 Pod 的配置文件，其注解中包含 imageregistry: <a href="https://hub.docker.com/：" target="_blank" rel="noopener">https://hub.docker.com/：</a></p>
<pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> annotations<span class="token punctuation">-</span>demo
  <span class="token key atrule">annotations</span><span class="token punctuation">:</span>
    <span class="token key atrule">imageregistry</span><span class="token punctuation">:</span> <span class="token string">"https://hub.docker.com/"</span>
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">containers</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx
    <span class="token key atrule">image</span><span class="token punctuation">:</span> nginx<span class="token punctuation">:</span>1.7.9
    <span class="token key atrule">ports</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">80</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="字段选择器"><a href="#字段选择器" class="headerlink" title="字段选择器"></a>字段选择器</h3><p>字段选择器（Field selectors）允许你根据一个或多个资源字段的值 <a href="https://kubernetes.io/zh/docs/concepts/overview/working-with-objects/kubernetes-objects" target="_blank" rel="noopener">筛选 Kubernetes 资源</a>。 下面是一些使用字段选择器查询的例子：</p>
<ul>
<li><code>metadata.name=my-service</code></li>
<li><code>metadata.namespace!=default</code></li>
<li><code>status.phase=Pending</code></li>
</ul>
<p>下面这个 kubectl 命令将筛选出 <code>status.phase</code> 字段值为 <code>Running</code> 的所有 Pod：</p>
<pre class="line-numbers language-shell"><code class="language-shell">kubectl get pods --field-selector status.phase=Running<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h5 id="支持的字段"><a href="#支持的字段" class="headerlink" title="支持的字段"></a>支持的字段</h5><p>你可在字段选择器中使用 =、==和 != （= 和 == 的意义是相同的）操作符。 例如，下面这个 kubectl 命令将筛选所有不属于 default 命名空间的 Kubernetes 服务：</p>
<pre class="line-numbers language-shell"><code class="language-shell">kubectl get services  --all-namespaces --field-selector metadata.namespace!=default<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h5 id="链式选择器"><a href="#链式选择器" class="headerlink" title="链式选择器"></a>链式选择器</h5><p>同标签和其他选择器一样， 字段选择器可以通过使用逗号分隔的列表组成一个选择链。 下面这个 kubectl 命令将筛选 status.phase 字段不等于 Running 同时 spec.restartPolicy 字段等于 Always 的所有 Pod：</p>
<pre class="line-numbers language-shell"><code class="language-shell">kubectl get pods --field-selector=status.phase!=Running,spec.restartPolicy=Always<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h5 id="多种资源类型"><a href="#多种资源类型" class="headerlink" title="多种资源类型"></a>多种资源类型</h5><p>你能够跨多种资源类型来使用字段选择器。 下面这个 kubectl 命令将筛选出所有不在 default 命名空间中的 StatefulSet 和 Service：</p>
<pre class="line-numbers language-shell"><code class="language-shell">kubectl get statefulsets,services --all-namespaces --field-selector metadata.namespace!=default<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="Kubernetes-架构"><a href="#Kubernetes-架构" class="headerlink" title="Kubernetes 架构"></a>Kubernetes 架构</h2><h3 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h3><p>Kubernetes 通过将容器放入在节点（Node）上运行的 Pod 中来执行你的工作负载。 节点可以是一个虚拟机或者物理机器，取决于所在的集群配置。 每个节点包含运行 Pods 所需的服务， 这些 Pods 由控制面负责管理。</p>
<p>通常集群中会有若干个节点；而在一个学习用或者资源受限的环境中，你的集群中也可能只有一个节点。</p>
<p>节点上的组件包括 kubelet、 容器运行时以及 kube-proxy。</p>
<h4 id="管理"><a href="#管理" class="headerlink" title="管理"></a>管理</h4><p>向 API 服务器添加节点的方式主要有两种：</p>
<ol>
<li>节点上的 kubelet 向控制面执行自注册；</li>
<li>你，或者别的什么人，手动添加一个 Node 对象。</li>
</ol>
<p>在你创建了 Node 对象或者节点上的 kubelet 执行了自注册操作之后， 控制面会检查新的 Node 对象是否合法。例如，如果你使用下面的 JSON 对象来创建 Node 对象：</p>
<pre class="line-numbers language-json"><code class="language-json"><span class="token punctuation">{</span>
  <span class="token property">"kind"</span><span class="token operator">:</span> <span class="token string">"Node"</span><span class="token punctuation">,</span>
  <span class="token property">"apiVersion"</span><span class="token operator">:</span> <span class="token string">"v1"</span><span class="token punctuation">,</span>
  <span class="token property">"metadata"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"10.240.79.157"</span><span class="token punctuation">,</span>
    <span class="token property">"labels"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"my-first-k8s-node"</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Kubernetes 会在内部创建一个 Node 对象作为节点的表示。Kubernetes 检查 kubelet 向 API 服务器注册节点时使用的 metadata.name 字段是否匹配。 如果节点是健康的（即所有必要的服务都在运行中），则该节点可以用来运行 Pod。 否则，直到该节点变为健康之前，所有的集群活动都会忽略该节点。</p>
<h3 id="控制面到节点通信"><a href="#控制面到节点通信" class="headerlink" title="控制面到节点通信"></a>控制面到节点通信</h3><p>本文列举控制面节点（确切说是 API 服务器）和 Kubernetes 集群之间的通信路径。 目的是为了让用户能够自定义他们的安装，以实现对网络配置的加固，使得集群能够在不可信的网络上（或者在一个云服务商完全公开的 IP 上）运行。</p>
<h4 id="节点到控制面"><a href="#节点到控制面" class="headerlink" title="节点到控制面"></a>节点到控制面</h4><p>Kubernetes 采用的是中心辐射型（Hub-and-Spoke）API 模式。 所有从集群（或所运行的 Pods）发出的 API 调用都终止于 apiserver（其它控制面组件都没有被设计为可暴露远程服务）。 apiserver 被配置为在一个安全的 HTTPS 端口（443）上监听远程连接请求， 并启用一种或多种形式的客户端身份认证机制。 一种或多种客户端鉴权机制应该被启用， 特别是在允许使用匿名请求 或服务账号令牌的时候。</p>
<p>应该使用集群的公共根证书开通节点，这样它们就能够基于有效的客户端凭据安全地连接 apiserver。 一种好的方法是以客户端证书的形式将客户端凭据提供给 kubelet。 请查看 kubelet TLS 启动引导 以了解如何自动提供 kubelet 客户端证书。</p>
<p>想要连接到 apiserver 的 Pod 可以使用服务账号安全地进行连接。 当 Pod 被实例化时，Kubernetes 自动把公共根证书和一个有效的持有者令牌注入到 Pod 里。 kubernetes 服务（位于所有名字空间中）配置了一个虚拟 IP 地址，用于（通过 kube-proxy）转发 请求到 apiserver 的 HTTPS 末端。</p>
<p>控制面组件也通过安全端口与集群的 apiserver 通信。</p>
<p>这样，从集群节点和节点上运行的 Pod 到控制面的连接的缺省操作模式即是安全的， 能够在不可信的网络或公网上运行。</p>
<h4 id="控制面到节点"><a href="#控制面到节点" class="headerlink" title="控制面到节点"></a>控制面到节点</h4><p>从控制面（apiserver）到节点有两种主要的通信路径。 第一种是从 apiserver 到集群中每个节点上运行的 kubelet 进程。 第二种是从 apiserver 通过它的代理功能连接到任何节点、Pod 或者服务。</p>
<h5 id="API-服务器到-kubelet"><a href="#API-服务器到-kubelet" class="headerlink" title="API 服务器到 kubelet"></a>API 服务器到 kubelet</h5><p>从 apiserver 到 kubelet 的连接用于：</p>
<ul>
<li>获取 Pod 日志</li>
<li>挂接（通过 kubectl）到运行中的 Pod</li>
<li>提供 kubelet 的端口转发功能。</li>
</ul>
<p>这些连接终止于 kubelet 的 HTTPS 末端。 默认情况下，apiserver 不检查 kubelet 的服务证书。这使得此类连接容易受到中间人攻击， 在非受信网络或公开网络上运行也是 不安全的。</p>
<p>为了对这个连接进行认证，使用 –kubelet-certificate-authority 标志给 apiserver 提供一个根证书包，用于 kubelet 的服务证书。</p>
<p>如果无法实现这点，又要求避免在非受信网络或公共网络上进行连接，可在 apiserver 和 kubelet 之间使用 SSH 隧道。</p>
<p>最后，应该启用 kubelet 用户认证和/或鉴权 来保护 kubelet API。</p>
<h5 id="apiserver-到节点、Pod-和服务"><a href="#apiserver-到节点、Pod-和服务" class="headerlink" title="apiserver 到节点、Pod 和服务"></a>apiserver 到节点、Pod 和服务</h5><p>从 apiserver 到节点、Pod 或服务的连接默认为纯 HTTP 方式，因此既没有认证，也没有加密。 这些连接可通过给 API URL 中的节点、Pod 或服务名称添加前缀 <code>https:</code> 来运行在安全的 HTTPS 连接上。 不过这些连接既不会验证 HTTPS 末端提供的证书，也不会提供客户端证书。 因此，虽然连接是加密的，仍无法提供任何完整性保证。 这些连接目前还不能安全地在非受信网络或公共网络上运行。</p>
<h2 id="工作负载"><a href="#工作负载" class="headerlink" title="工作负载"></a>工作负载</h2><h3 id="pods"><a href="#pods" class="headerlink" title="pods"></a>pods</h3><h3 id="工作负载资源"><a href="#工作负载资源" class="headerlink" title="工作负载资源"></a>工作负载资源</h3>
        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2021-03-09T10:37:41.560Z" itemprop="dateUpdated">2021-03-09 18:37:41</time>
</span><br>


        
        想给作者写留言，请在下面使用Github账号登录，留言支持Markdown语法。如果这篇文章对你有所帮助，那就请我喝咖啡吧！
        
    </div>
    
    <footer>
        <a href="/">
            <img src="https://pic.imgdb.cn/item/5e9e78b6c2a9a83be545fef2.jpg" alt="荒原饮露">
            荒原饮露
        </a>
    </footer>
</blockquote>

        
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>



        <div class="post-footer">
            
	<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Kubernetes/" rel="tag">Kubernetes</a></li></ul>


            


        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between flex-row-reverse">

  
    <div class="waves-block waves-effect prev">
      <a href="/post/23473589.html" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev </div>
        <h4 class="title">Ubuntu 18.04 系统初始化</h4>
      </a>
    </div>
  

  


</nav>



    

















<section class="comments" id="comments">
    <div id="gitalk-container"></div>
    <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
    <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
    <script>
        var id = location.pathname
        if (location.pathname.length > 50) {
          id = location.pathname.replace(/\/\d+\/\d+\/\d+\//, '').replace('/', '').substring(0, 50)
        }
        const gitalk = new Gitalk({
          clientID: '23c466a5c9454511f778',
          clientSecret: '0175fa1cbbd5ae44c3a5adcd4a6ce32c0011032b',
          repo: 'mf-restart.github.io',
          owner: 'MF-ReStart',
          admin: ['MF-ReStart'],
          id: id,      // Ensure uniqueness and length less than 50
          title: document.title.split('|')[0],
          distractionFreeMode: false  // Facebook-like distraction free mode
        })

        gitalk.render('gitalk-container')
    </script>
</section>




</article>

<div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        请我喝咖啡吧~
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="https://pic.imgdb.cn/item/5e9e7942c2a9a83be54666eb.jpg" alt="打赏二维码">
        </div>
        
        <label class="reward-toggle">
            <input id="rewardToggle" type="checkbox" class="reward-toggle-check"
                data-wechat="https://pic.imgdb.cn/item/5e9e7942c2a9a83be54666eb.jpg" data-alipay="https://pic.imgdb.cn/item/5e9e795ac2a9a83be54675ba.jpg">
            <div class="reward-toggle-ctrol">
                <span class="reward-toggle-item wechat">微信</span>
                <span class="reward-toggle-label"></span>
                <span class="reward-toggle-item alipay">支付宝</span>
            </div>
        </label>
        
    </div>
</div>



</div>

        <footer class="footer">
    <div class="bottom">
        <p><span>荒原饮露 &copy; 2019 - 2021</span>
            <span id="alive"></span>
            <script type="text/javascript">
                function runtime(){
                    // 初始时间，日/月/年 时:分:秒
                    X = new Date("03/24/2019 9:30:00");
                    Y = new Date();
                    T = (Y.getTime()-X.getTime());
                    M = 24*60*60*1000;
                    a = T/M;
                    A = Math.floor(a);
                    b = (a-A)*24;
                    B = Math.floor(b);
                    c = (b-B)*60;
                    C = Math.floor((b-B)*60);
                    D = Math.floor((c-C)*60);
                    //信息写入到DIV中
                    var alive = document.getElementById("alive");
                    alive.innerHTML = "本站勉强运行 : "+A+"天"+B+"小时"+C+"分"+D+"秒"
                }
                setInterval(runtime, 1000);
            </script>
            
        </p>
        <br>
        <p>
            <span>
                
                <div class="github-badge">
    <a style="color: #fff" rel="license" href="https://hexo.io/" target="_blank" title="由 Hexo 强力驱动">
        <span class="badge-subject">Powered</span><span class="badge-value bg-blue">Hexo</span></a>
</div>
<div class="github-badge">
    <a style="color: #fff" rel="license" href="https://github.com/" target="_blank"
       title="静态网页托管于 GitHub & Coding Pages">
        <span class="badge-subject">Hosted</span><span class="badge-value bg-brightgreen">GitHub & Coding Pages</span></a>
</div>
<div class="github-badge">
    <a style="color: #fff" rel="license" href="https://www.aliyun.com/" target="_blank" title="阿里云提供域名相关服务">
        <span class="badge-subject">DNS</span><span class="badge-value bg-blueviolet">Aliyun</span></a>
</div>
<div class="github-badge">
    <a style="color: #fff" rel="license" href="https://github.com/yscoder/hexo-theme-indigo" target="_blank"
       title="站点使用 Indigo 主题">
        <span class="badge-subject">Theme</span><span class="badge-value bg-blue">indigo</span></a>
</div>
<div class="github-badge">
    <a style="color: #fff" rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank"
       title="本站点采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可">
        <span class="badge-subject"><i class="icon icon-copyright"></i></span><span class="badge-value bg-lightgrey">BY-NC-SA 4.0</span></a>
</div>


    <div class="github-badge">
        <span class="badge-subject">UV</span><span class="badge-value bg-orange"
                                                                                   id="busuanzi_value_site_uv"></span>
    </div>
    <div class="github-badge">
        <span class="badge-subject">PV</span><span class="badge-value bg-brightgreen"
                                                                                   id="busuanzi_value_site_pv"></span>
    </div>
    <div class="github-badge">
        <span class="badge-subject">WordCount</span><span class="badge-value bg-blueviolet">
            
                8.9k
            
        </span>
    </div>


            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>


    <script src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script>
<script src="https://cdn.bootcdn.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js"></script>
<script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: false, REWARD: true };


</script>

<script src="/js/main.js"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="/js/search.js" async></script>






<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





</body>
</html>
