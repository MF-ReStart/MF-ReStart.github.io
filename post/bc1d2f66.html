<!DOCTYPE html>
<html>
<head>
    

    

    
<!-- Baidu Tongji -->
<script>var _hmt = _hmt || []</script>
<script async src="//hm.baidu.com/hm.js?8b4479ac4dfb59b63d69ce30940d781d"></script>
<!-- End Baidu Tongji -->




    <meta name="chinaz-site-verification" content="EC6F7C888ADBF24B">
    <meta charset="utf-8">
    
    
    
    
    <title>Docker容器网络(5) | 荒原饮露 | 青春不是隔岸观火啊</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="Docker,容器技术,云计算">
    <meta name="description" content="容器的四种网络模式bridge 模式当启动docker进程之后，docker会默认创建一个名为docker0的虚拟网桥，创建容器时如果不指定网络，默认就是添加到这个网桥中。这样docker主机上的所有容器都可以通过交换机的方式连接在一个二层网络中。创建容器时，docker会先创建容器的虚拟网卡，容器的虚拟网卡去连接docker主机的docker0虚拟网桥，相当于用一根网线将容器和docker主机连">
<meta property="og:type" content="article">
<meta property="og:title" content="Docker容器网络(5)">
<meta property="og:url" content="https://www.missf.top/post/bc1d2f66.html">
<meta property="og:site_name" content="荒原饮露">
<meta property="og:description" content="容器的四种网络模式bridge 模式当启动docker进程之后，docker会默认创建一个名为docker0的虚拟网桥，创建容器时如果不指定网络，默认就是添加到这个网桥中。这样docker主机上的所有容器都可以通过交换机的方式连接在一个二层网络中。创建容器时，docker会先创建容器的虚拟网卡，容器的虚拟网卡去连接docker主机的docker0虚拟网桥，相当于用一根网线将容器和docker主机连">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pic.imgdb.cn/item/5ef9619814195aa5940901bf.jpg">
<meta property="article:published_time" content="2020-06-23T01:49:44.000Z">
<meta property="article:modified_time" content="2020-07-14T01:20:15.112Z">
<meta property="article:author" content="荒原饮露">
<meta property="article:tag" content="Docker">
<meta property="article:tag" content="容器技术">
<meta property="article:tag" content="云计算">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pic.imgdb.cn/item/5ef9619814195aa5940901bf.jpg">
    
        <link rel="alternate" type="application/atom+xml" title="荒原饮露" href="/atom.xml">
    
    <link rel="shortcut icon" href="https://pic.imgdb.cn/item/5e9e7910c2a9a83be54641d1.png">
    <link rel="stylesheet" href="/css/style.css">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

<meta name="generator" content="Hexo 4.2.0"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(https://pic.imgdb.cn/item/5e9e78fbc2a9a83be5463167.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="https://pic.imgdb.cn/item/5e9e78b6c2a9a83be545fef2.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">荒原饮露</h5>
          <a href="mailto:mf_2013@163.com" title="mf_2013@163.com" class="mail">mf_2013@163.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                Archives
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                Tags
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                Categories
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/MF-ReStart" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">Docker容器网络(5)</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入你要搜索的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">Docker容器网络(5)</h1>
        <h5 class="subtitle">
            
                <time datetime="2020-06-23T01:49:44.000Z" itemprop="datePublished" class="page-time">
  2020-06-23
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Docker/">Docker</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#容器的四种网络模式"><span class="post-toc-number">1.</span> <span class="post-toc-text">容器的四种网络模式</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#bridge-模式"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">bridge 模式</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#host模式"><span class="post-toc-number">1.2.</span> <span class="post-toc-text">host模式</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#none模式"><span class="post-toc-number">1.3.</span> <span class="post-toc-text">none模式</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#container模式"><span class="post-toc-number">1.4.</span> <span class="post-toc-text">container模式</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#容器虚拟网卡和docker0网桥的veth-pair配对"><span class="post-toc-number">2.</span> <span class="post-toc-text">容器虚拟网卡和docker0网桥的veth pair配对</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#容器网络访问原理图"><span class="post-toc-number">3.</span> <span class="post-toc-text">容器网络访问原理图</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#容器网络实现的核心技术-iptables"><span class="post-toc-number">4.</span> <span class="post-toc-text">容器网络实现的核心技术: iptables</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#源IP地址变换规则"><span class="post-toc-number">4.1.</span> <span class="post-toc-text">源IP地址变换规则</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#目标IP地址变换规则"><span class="post-toc-number">4.2.</span> <span class="post-toc-text">目标IP地址变换规则</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#etcd-和-flannel-实现-docker-跨主机通信"><span class="post-toc-number">5.</span> <span class="post-toc-text">etcd 和 flannel 实现 docker 跨主机通信</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#实现原理"><span class="post-toc-number">5.1.</span> <span class="post-toc-text">实现原理</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#实验环境"><span class="post-toc-number">5.2.</span> <span class="post-toc-text">实验环境</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#master节点配置"><span class="post-toc-number">5.3.</span> <span class="post-toc-text">master节点配置</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#slave节点配置"><span class="post-toc-number">5.4.</span> <span class="post-toc-text">slave节点配置</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#配置docker使用flannel的网络"><span class="post-toc-number">5.5.</span> <span class="post-toc-text">配置docker使用flannel的网络</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#查看宿主机的IP变化"><span class="post-toc-number">5.6.</span> <span class="post-toc-text">查看宿主机的IP变化</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#在两个节点创建容器相互ping验证"><span class="post-toc-number">5.7.</span> <span class="post-toc-text">在两个节点创建容器相互ping验证</span></a></li></ol></li></ol>
        </nav>
    </aside>


<article id="post-Docker容器网络(5)"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">Docker容器网络(5)</h1>
        <div class="post-meta">
            <time class="post-time" title="2020-06-23 09:49:44" datetime="2020-06-23T01:49:44.000Z"  itemprop="datePublished">2020-06-23</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Docker/">Docker</a></li></ul>



            
<!--<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>-->
<!--    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>-->
<!--</span>-->


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <h1 id="容器的四种网络模式"><a href="#容器的四种网络模式" class="headerlink" title="容器的四种网络模式"></a>容器的四种网络模式</h1><h2 id="bridge-模式"><a href="#bridge-模式" class="headerlink" title="bridge 模式"></a>bridge 模式</h2><p>当启动docker进程之后，docker会默认创建一个名为docker0的虚拟网桥，创建容器时如果不指定网络，默认就是添加到这个网桥中。这样docker主机上的所有容器都可以通过交换机的方式连接在一个二层网络中。创建容器时，docker会先创建容器的虚拟网卡，容器的虚拟网卡去连接docker主机的docker0虚拟网桥，相当于用一根网线将容器和docker主机连接起来。虚拟网卡连接到docker0子网后，由docker0虚拟网桥分配IP给容器的虚拟网卡使用，并设置docker0虚拟网桥的IP地址为容器的默认网关。除了docker启动时默认创建的bridge默认网络，我们还可以自定义bridge网络。相比默认的具备内部DNS发现，bridge网络模式还可以通过容器名去实现容器之间的网络通信</p>
<p>查看docker宿主机上的docker0虚拟网桥，默认网段是172.17.0.1，安装docker之后默认创建的</p>
<pre class="line-numbers language-shell"><code class="language-shell">ip a s docker0
3: docker0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP group default 
    link/ether 02:42:9f:dc:ee:74 brd ff:ff:ff:ff:ff:ff
    inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0
       valid_lft forever preferred_lft forever
    inet6 fe80::42:9fff:fedc:ee74/64 scope link 
       valid_lft forever preferred_lft forever<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>查看默认定义好的网络模式,这里没有container模式是因为container是启动容器时直接指定的</p>
<pre class="line-numbers language-shell"><code class="language-shell">docker network ls
NETWORK ID          NAME                DRIVER              SCOPE
a42d2b0e12ec        bridge              bridge              local
168bbf4b0447        host                host                local
ec481d03e2a1        none                null                local
21be62f7b97e        webserver           bridge              local<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>查看bridge网络模式的详细信息</p>
<pre class="line-numbers language-shell"><code class="language-shell">docker network inspect bridge
[
    {
        "Name": "bridge",
        "Id": "a42d2b0e12ec0e039e7c4686099468585b88c8df8b639eaa780700980adb9e1b",
        "Created": "2020-06-23T17:16:25.717600267+08:00",
        "Scope": "local",
        "Driver": "bridge",
        "EnableIPv6": false,
        "IPAM": {
            "Driver": "default",
            "Options": null,
            "Config": [
                {
                    "Subnet": "172.17.0.0/16",
                    "Gateway": "172.17.0.1"
                }
            ]
        },
        "Internal": false,
        "Attachable": false,
        "Ingress": false,
        "ConfigFrom": {
            "Network": ""
        },
        "ConfigOnly": false,
        "Containers": {
            "253d0d8f196182eccaa52238068513cebfbf2abe69d2a7980e40d8c136b53960": {
                "Name": "nginx",
                "EndpointID": "7fd4576f90bc1d0fd966ed5794710dd43461d077ea32f99e54a8b3c56ba1de08",
                "MacAddress": "02:42:ac:11:00:02",
                "IPv4Address": "172.17.0.2/16",
                "IPv6Address": ""
            },
            "8652448b6f9a99d9b9a6c70277ea23924b21df57289d4deb29a146974ad4c4dd": {
                "Name": "centos7",
                "EndpointID": "e112927463f07a606a3a019f3af7400c711b9a903fec19c130b27c7d5f53d359",
                "MacAddress": "02:42:ac:11:00:03",
                "IPv4Address": "172.17.0.3/16",
                "IPv6Address": ""
            }
        },
        "Options": {
            "com.docker.network.bridge.default_bridge": "true",
            "com.docker.network.bridge.enable_icc": "true",
            "com.docker.network.bridge.enable_ip_masquerade": "true",
            "com.docker.network.bridge.host_binding_ipv4": "0.0.0.0",
            "com.docker.network.bridge.name": "docker0",
            "com.docker.network.driver.mtu": "1500"
        },
        "Labels": {}
    }
]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>安装网桥管理工具包</p>
<pre class="line-numbers language-shell"><code class="language-shell">yum install -y bridge-utils.x86_64<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>查看虚拟网桥上的接口信息</p>
<pre class="line-numbers language-shell"><code class="language-shell">brctl show docker0
bridge name    bridge id                STP enabled        interfaces
docker0        8000.02429fdcee74        no                veth81bdc19                                                    vetha8f66a7<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>创建类型为bridge的自定义网桥</p>
<pre class="line-numbers language-shell"><code class="language-shell">docker network create webserver
21be62f7b97ebfc9ce6f6a1aaaffd59a4a220c6b778f36a98c72162023b5c5e5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>启动容器时指定使用自定义创建的webserver网桥(具备DNS发现)</p>
<pre class="line-numbers language-shell"><code class="language-shell">docker container run -itd --name "app1" --network webserver centos:7.7.1908 
98efd7fb3c63c0bd487039b7ef00925d786e0499f10d76003afa2277cc93b404

docker container run -itd --name "app2" --network webserver centos:7.7.1908 
c81e58db50ca74111d46f460ff322378b45414a36804738597559ec3c06cf542

docker container run -itd --name "app3" --network webserver centos:7.7.1908
41fb1a7dd161c03a158a104da54dcfa3b226035feceecabd003f7a18e91bff61<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>查看容器的IP地址</p>
<pre class="line-numbers language-shell"><code class="language-shell">docker inspect --format='{{.NetworkSettings.Networks.webserver.IPAddress}}' app1
172.18.0.2
docker inspect --format='{{.NetworkSettings.Networks.webserver.IPAddress}}' app2
172.18.0.3
docker inspect --format='{{.NetworkSettings.Networks.webserver.IPAddress}}' app3
172.18.0.4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>容器之间的通信测试，自定义的bridge网桥相比默认的bridge网桥具备内部DNS发现， IP和主机名都是可以PING通</p>
<pre class="line-numbers language-shell"><code class="language-shell">ping 172.18.0.2
PING 172.18.0.2 (172.18.0.2) 56(84) bytes of data.
64 bytes from 172.18.0.2: icmp_seq=1 ttl=64 time=0.203 ms
64 bytes from 172.18.0.2: icmp_seq=2 ttl=64 time=0.085 ms

ping 98efd7fb3c63    # 如果启动容器时不指定自定义的网桥,那就会使用默认的bridge模式,这样是不能PING通主机名的
PING 98efd7fb3c63 (172.18.0.2) 56(84) bytes of data.
64 bytes from app1.webserver (172.18.0.2): icmp_seq=1 ttl=64 time=0.402 ms
64 bytes from app1.webserver (172.18.0.2): icmp_seq=2 ttl=64 time=0.100 ms<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="host模式"><a href="#host模式" class="headerlink" title="host模式"></a>host模式</h2><p>如果启动容器时指定host模式，那么这个容器将不会获得一个独立的Network namespace，而是和宿主机共用一个Network namespace。容器不会虚拟出自己的网卡，而是使用宿主机的IP和端口。这种无需NAT转换的网络模式无需再映射容器与宿主机之间的端口，在提高网络传输性能的同时，造成了网络环境隔离性弱化。容器之间不再拥有隔离独立的网络，docker host上已使用的端口就不能再用了</p>
<p>启动一个nginx容器，再查看宿主机上的80端口是否被使用</p>
<pre class="line-numbers language-shell"><code class="language-shell">docker container run -itd --name "host_nginx" --network=host nginx:1.1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>查看宿主机上的80端口是否被nginx容器所使用</p>
<pre class="line-numbers language-shell"><code class="language-shell">netstat -lntup | grep 80
tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      7358/nginx: master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>查看宿主机上nginx进程的父进程是否为docker</p>
<pre class="line-numbers language-shell"><code class="language-shell">ps -afx | grep containerd -A 1
  1100 ?        Ssl    1:18 /usr/bin/containerd
  7341 ?        Sl     0:00  \_ containerd-shim -namespace moby -workdir /var/lib/containerd/io.containerd.runtime.v1.linux/moby/adf66250b1fcd95c2531f04f8504bea614dd90903f4f074e150ce6202895a023 -address /run/containerd/containerd.sock -containerd-binary /usr/bin/containerd -runtime-root /var/run/docker/runtime-runc
  7358 pts/0    Ss+    0:00      \_ nginx: master process nginx -g daemon off;    # 这个nginx进程是容器中启动的nginx进程,这也正如我们前面所说,使用host模式启动容器,容器会和宿主机共用一个Network namespace<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>进入容器中查看网卡信息，可以看到宿主机上的网卡也会显示，这就是共用了一个Network namespace的结果</p>
<pre class="line-numbers language-shell"><code class="language-shell">ifconfig
br-21be62f7b97e: flags=4099<UP,BROADCAST,MULTICAST>  mtu 1500
        inet 172.18.0.1  netmask 255.255.0.0  broadcast 172.18.255.255
        inet6 fe80::42:6fff:fe77:c9f0  prefixlen 64  scopeid 0x20<link>
        ether 02:42:6f:77:c9:f0  txqueuelen 0  (Ethernet)
        RX packets 0  bytes 0 (0.0 B)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 0  bytes 0 (0.0 B)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

docker0: flags=4099<UP,BROADCAST,MULTICAST>  mtu 1500
        inet 172.17.0.1  netmask 255.255.0.0  broadcast 172.17.255.255
        inet6 fe80::42:9fff:fedc:ee74  prefixlen 64  scopeid 0x20<link>
        ether 02:42:9f:dc:ee:74  txqueuelen 0  (Ethernet)
        RX packets 3  bytes 114 (114.0 B)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 8  bytes 677 (677.0 B)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

ens32: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 10.10.110.150  netmask 255.255.255.0  broadcast 10.10.110.255
        inet6 fe80::20c:29ff:fec4:cbac  prefixlen 64  scopeid 0x20<link>
        ether 00:0c:29:c4:cb:ac  txqueuelen 1000  (Ethernet)
        RX packets 91694  bytes 118390130 (112.9 MiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 41857  bytes 2875558 (2.7 MiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

lo: flags=73<UP,LOOPBACK,RUNNING>  mtu 65536
        inet 127.0.0.1  netmask 255.0.0.0
        inet6 ::1  prefixlen 128  scopeid 0x10<host>
        loop  txqueuelen 1000  (Local Loopback)
        RX packets 0  bytes 0 (0.0 B)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 0  bytes 0 (0.0 B)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="none模式"><a href="#none模式" class="headerlink" title="none模式"></a>none模式</h2><p>容器启动时指定none模式是获取独立的Network namespace，但不为容器进行任何网络配置。容器内部只有loopback网络设备不会再有其他的网络资源，将网络创建的责任完全交给用户。作为 Docker 开发者，才能在这基础做其他无限多可能的网络定制开发，这种方式可以实现更加灵活复杂的网络，同时也体现了Docker设计理念的开放</p>
<p>启动一个none模式的容器</p>
<pre class="line-numbers language-shell"><code class="language-shell">docker container run -itd --name "none_centos" --network=none centos:7.7.1908<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>进入容器查看网卡设备信息</p>
<pre class="line-numbers language-shell"><code class="language-shell">docker container exec -it none_centos /bin/bash

ifconfig    # 这里只有一个回环口地址,因为none模式不会对容器进行任何网络配置
lo: flags=73<UP,LOOPBACK,RUNNING>  mtu 65536
        inet 127.0.0.1  netmask 255.0.0.0
        inet6 ::1  prefixlen 128  scopeid 0x10<host>
        loop  txqueuelen 1000  (Local Loopback)
        RX packets 0  bytes 0 (0.0 B)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 0  bytes 0 (0.0 B)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="container模式"><a href="#container模式" class="headerlink" title="container模式"></a>container模式</h2><p>创建新的容器时指定和已存在的容器共享一个Network namespace，这些容器之间共享IP、端口范围等网络配置，容器之间传输效率高。两个容器除了网络资源共享之外，其他资源还是隔离的。虽然多个容器共享网络环境，但是多个容器形成的整体依然与宿主机以及其他容器形成网络隔离</p>
<p>启动一个名为server1的容器</p>
<pre class="line-numbers language-shell"><code class="language-shell">docker container run -itd --name "server1" centos:7.7.1908<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>再启动两个容器，把它们加入到server1这个容器的Network namespace</p>
<pre class="line-numbers language-shell"><code class="language-shell">docker container run -itd --name "server2" --network=container:server1 centos:7.7.1908
docker container run -itd --name "server3" --network=container:server1 centos:7.7.1908<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>查看各个容器的IP地址</p>
<pre class="line-numbers language-shell"><code class="language-shell">docker inspect --format='{{.NetworkSettings.Networks.bridge.IPAddress}}' server1
172.17.0.3
docker inspect --format='{{.NetworkSettings.Networks.bridge.IPAddress}}' server2
<no value>
docker inspect --format='{{.NetworkSettings.Networks.bridge.IPAddress}}' server3
<no value><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里我们在查看server2和server3容器IP时，显示为&lt;no value&gt;，其实它们是和server1共用一个Network namespace的</p>
<pre class="line-numbers language-shell"><code class="language-shell">docker container exec -it server2 /bin/bash
[root@41436b0be6f7 /]# ifconfig
eth0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 172.17.0.3  netmask 255.255.0.0  broadcast 172.17.255.255
        ether 02:42:ac:11:00:03  txqueuelen 0  (Ethernet)
        RX packets 10969  bytes 20985758 (20.0 MiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 6234  bytes 344851 (336.7 KiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

docker container exec -it server3 /bin/bash
[root@41436b0be6f7 /]# ifconfig
eth0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 172.17.0.3  netmask 255.255.0.0  broadcast 172.17.255.255
        ether 02:42:ac:11:00:03  txqueuelen 0  (Ethernet)
        RX packets 10969  bytes 20985758 (20.0 MiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 6234  bytes 344851 (336.7 KiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
# 两个容器的IP、主机名都相同<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="容器虚拟网卡和docker0网桥的veth-pair配对"><a href="#容器虚拟网卡和docker0网桥的veth-pair配对" class="headerlink" title="容器虚拟网卡和docker0网桥的veth pair配对"></a>容器虚拟网卡和docker0网桥的veth pair配对</h1><p>veth是成对出现的虚拟网络设备， 发送到veth一端虚拟设备的请求会从另一端的虚拟设备中发出。创建一个容器的同时会为这个容器创建一对虚拟网卡veth pair，这个成对出现的虚拟网卡veth pair，分别放到宿主机和容器中，宿主机一端桥接到默认的docker0或者自定义的网桥上，容器一端放到新创建容器的Network namespace中，并把名字修改为eth0。虚拟网卡veth pair就像是一根网线，将宿主机的docker0和容器连接起来</p>
<pre class="line-numbers language-shell"><code class="language-shell">docker container run -itd --name "server1" centos:7.7.1908    # 创建容器

brctl show docker0    # 查看宿主机上的docker0网桥
bridge name    bridge id        STP enabled    interfaces
docker0        8000.02429fdcee74    no        veth7459cf7

ip a s veth7459cf7    # 这是虚拟网卡veth pair在宿主机上的一端
34: veth7459cf7@if33: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue master docker0 state UP group default 
    link/ether 86:54:3c:c6:70:6b brd ff:ff:ff:ff:ff:ff link-netnsid 0
    inet6 fe80::8454:3cff:fec6:706b/64 scope link 
       valid_lft forever preferred_lft forever

[root@ec94bfbd724f /]# ifconfig        # 容器内部的eth0网卡是虚拟网卡veth pair在容器中的一端
eth0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 172.17.0.2  netmask 255.255.0.0  broadcast 172.17.255.255
        ether 02:42:ac:11:00:02  txqueuelen 0  (Ethernet)
        RX packets 5495  bytes 10346440 (9.8 MiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 3386  bytes 186731 (182.3 KiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="容器网络访问原理图"><a href="#容器网络访问原理图" class="headerlink" title="容器网络访问原理图"></a>容器网络访问原理图</h1><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://pic.imgdb.cn/item/5ef9619814195aa5940901bf.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>

<h1 id="容器网络实现的核心技术-iptables"><a href="#容器网络实现的核心技术-iptables" class="headerlink" title="容器网络实现的核心技术: iptables"></a>容器网络实现的核心技术: iptables</h1><p>docker容器的跨网络隔离与通信，是使用iptables去实现的</p>
<h2 id="源IP地址变换规则"><a href="#源IP地址变换规则" class="headerlink" title="源IP地址变换规则"></a>源IP地址变换规则</h2><p>docker在安装完成后，将默认在宿主机上增加一些iptables规则，以用于docker容器和容器之间的隔离与通信，可以使用使用iptables-save命令查看</p>
<pre class="line-numbers language-shell"><code class="language-shell">iptables-save | grep docker
-A POSTROUTING -s 172.17.0.0/16 ! -o docker0 -j MASQUERADE

参数说明:
-s:源地址172.17.0.0/16
-o:指定数据报文流出接口为docker0
-j:动作为MASQUERADE(地址伪装)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上面这条规则关系着docker容器和外界的通信，含义是源地址为172.17.0.0/16的数据包(即docker容器发出的数据)，当不是从docker0网卡发出时做SNAT(源地址转换)。这样使得docker容器访问外网的流量，在外界看来就是从宿主机上发出的，外界感觉不到docker容器的存在</p>
<h2 id="目标IP地址变换规则"><a href="#目标IP地址变换规则" class="headerlink" title="目标IP地址变换规则"></a>目标IP地址变换规则</h2><p>从docker容器访问外网的流量，在外部看来就是从宿主机上发出的，外部感觉不到docker容器的存在。其实这也是由相应的iptables规则去实现的</p>
<pre class="line-numbers language-shell"><code class="language-shell">docker container run -itd --name "nginx" -p 80:80 nginx:1.17<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>查看创建容器之后生成的iptables规则</p>
<pre class="line-numbers language-shell"><code class="language-shell">iptables-save | grep docker
-A DOCKER ! -i docker0 -p tcp -m tcp --dport 80 -j DNAT --to-destination 172.17.0.2:80
-A DOCKER -d 172.17.0.2/32 ! -i docker0 -o docker0 -p tcp -m tcp --dport 80 -j ACCEPT<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>这两条规则将访问宿主机的80端口的流量转发到了172.17.0.2的80端口上(即真正提供服务的docker容器的IP+端口)，所以外界访问docker容器是通过iptables做DNAT(目的地址转换)实现的</p>
<h1 id="etcd-和-flannel-实现-docker-跨主机通信"><a href="#etcd-和-flannel-实现-docker-跨主机通信" class="headerlink" title="etcd 和 flannel 实现 docker 跨主机通信"></a>etcd 和 flannel 实现 docker 跨主机通信</h1><p>flannel是一种基于overlay网络的跨主机容器网络解决方案，也就是将TCP数据包封装在另一种网络包里面进行路由转发和通信，flannel是CoreOS团队针对Kubernetes设计的一个网络规划服务，让集群中的不同节点主机创建的容器都具有全集群唯一的虚拟ip地址，flannel使用go语言编写</p>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>flannel为每个host分配一个subnet，容器从这个subnet中分配ip，这些ip可以在host间路由，容器间无需使用nat和端口映射即可实现跨主机通信。每个subnet都是从一个更大的ip池中划分的，flannel会在每个主机上运行一个叫flanneld的agent，其职责就是从池子中分配subnet。etcd相当于一个数据库，flannel使用etcd存放网络配置、已分配的subnet、host的IP等信息</p>
<h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><table>
<thead>
<tr>
<th>节点</th>
<th>安装软件</th>
<th>系统</th>
<th>内核版本</th>
<th>docker版本</th>
</tr>
</thead>
<tbody><tr>
<td>10.10.110.150(master)</td>
<td>etcd、flannel、docker</td>
<td>CentOS7.7.1908</td>
<td>3.10.0-1062.el7.x86_64</td>
<td>19.03.12</td>
</tr>
<tr>
<td>10.10.110.151(slave)</td>
<td>flannel、docker</td>
<td>CentOS7.7.1908</td>
<td>3.10.0-1062.el7.x86_64</td>
<td>19.03.12</td>
</tr>
</tbody></table>
<h2 id="master节点配置"><a href="#master节点配置" class="headerlink" title="master节点配置"></a>master节点配置</h2><p>安装配置etcd</p>
<pre class="line-numbers language-shell"><code class="language-shell">yum install -y etcd        # 安装etcd,由于不配置etcd集群,所以只在10.10.110.150节点安装etcd就行了

sed -i "s/localhost/10.10.110.150/g" /etc/etcd/etcd.conf    # 修改etcd配置文件

systemctl start etcd.service    # 启动etcd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>安装配置flannel</p>
<pre class="line-numbers language-shell"><code class="language-shell">yum install -y flannel

sed -i "s/127.0.0.1/10.10.110.150/g" /etc/sysconfig/flanneld    # flannel连接到etcd,slave连接也是填写master的IP

etcdctl --endpoints="http://10.10.110.150:2379" set /atomic.io/network/config '{ "Network":"172.17.0.0/16", "Backend": {"Type": "vxlan"}} '        # 配置etcd的子网,如果这一步不配置,那么etcd无法启动

systemctl start flanneld.service    # 启动flannel<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="slave节点配置"><a href="#slave节点配置" class="headerlink" title="slave节点配置"></a>slave节点配置</h2><p>安装配置flannel</p>
<pre class="line-numbers language-shell"><code class="language-shell">yum install -y flannel

sed -i "s/127.0.0.1/10.10.110.150/g" /etc/sysconfig/flanneld    # 这里是填写master节点的IP,让slave连接到master的etcd,多slave也一样

systemctl start flanneld.service    # 确保slave节点能连接到master节点的etcd,如果不关闭防火墙,那必须打开2379端口<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="配置docker使用flannel的网络"><a href="#配置docker使用flannel的网络" class="headerlink" title="配置docker使用flannel的网络"></a>配置docker使用flannel的网络</h2><p>master节点</p>
<pre class="line-numbers language-shell"><code class="language-shell">vim /usr/lib/systemd/system/docker.service

EnvironmentFile=/run/flannel/docker        # 加载这个文件里面的变量,这个文件记录了flannel分配给master节点的子网信息(slave也会有自己的子网)

ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock $DOCKER_NETWORK_OPTIONS    # 这个变量是上面文件中定义的,意思是在启动容器时指定使用flannel分配的子网去配置容器的网络

iptables -P FORWARD ACCEPT        # 开启iptables转发,如不开启即使配置成功也不能通信

systemctl daemon-reload

systemctl restart flanneld.service    # 这里必须先重启flannel再重启docker,这时候启动容器就会使用flannel去配置容器的网络

systemctl restart docker.service<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>slave节点配置</p>
<pre class="line-numbers language-shell"><code class="language-shell">vim /usr/lib/systemd/system/docker.service

EnvironmentFile=/run/flannel/docker        # 查看slave节点上这个文件,网段是和master节点不一样的

ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock $DOCKER_NETWORK_OPTIONS

iptables -P FORWARD ACCEPT

systemctl daemon-reload

systemctl restart flanneld.service

systemctl restart docker.service<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="查看宿主机的IP变化"><a href="#查看宿主机的IP变化" class="headerlink" title="查看宿主机的IP变化"></a>查看宿主机的IP变化</h2><p>master节点</p>
<pre class="line-numbers language-shell"><code class="language-shell">ip a
3: docker0: <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc noqueue state DOWN group default 
    link/ether 02:42:e3:89:96:4e brd ff:ff:ff:ff:ff:ff
    inet 172.17.98.1/24 brd 172.17.98.255 scope global docker0
       valid_lft forever preferred_lft forever
4: flannel.1: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1450 qdisc noqueue state UNKNOWN group default 
    link/ether 02:6f:fa:71:67:f7 brd ff:ff:ff:ff:ff:ff
    inet 172.17.98.0/32 scope global flannel.1
       valid_lft forever preferred_lft forever
    inet6 fe80::6f:faff:fe71:67f7/64 scope link 
       valid_lft forever preferred_lft forever    
# docker0虚拟网卡和flannel虚拟网卡已经在同一网段，这时候说明配置成功<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>slave节点</p>
<pre class="line-numbers language-shell"><code class="language-shell">ip a
3: docker0: <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc noqueue state DOWN group default 
    link/ether 02:42:f2:30:ba:34 brd ff:ff:ff:ff:ff:ff
    inet 172.17.75.1/24 brd 172.17.75.255 scope global docker0
       valid_lft forever preferred_lft forever
4: flannel.1: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1450 qdisc noqueue state UNKNOWN group default 
    link/ether f6:ae:d1:c0:e1:a7 brd ff:ff:ff:ff:ff:ff
    inet 172.17.75.0/32 scope global flannel.1
       valid_lft forever preferred_lft forever
    inet6 fe80::f4ae:d1ff:fec0:e1a7/64 scope link 
       valid_lft forever preferred_lft forever<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="在两个节点创建容器相互ping验证"><a href="#在两个节点创建容器相互ping验证" class="headerlink" title="在两个节点创建容器相互ping验证"></a>在两个节点创建容器相互ping验证</h2><p>master节点</p>
<pre class="line-numbers language-shell"><code class="language-shell">docker run -it busybox sh
/ # ifconfig
eth0      Link encap:Ethernet  HWaddr 02:42:AC:11:62:02  
          inet addr:172.17.98.2  Bcast:172.17.98.255  Mask:255.255.255.0
          UP BROADCAST RUNNING MULTICAST  MTU:1450  Metric:1
          RX packets:8 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0 
          RX bytes:656 (656.0 B)  TX bytes:0 (0.0 B)

lo        Link encap:Local Loopback  
          inet addr:127.0.0.1  Mask:255.0.0.0
          UP LOOPBACK RUNNING  MTU:65536  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000 
          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)

/ # ping 172.17.75.2
PING 172.17.75.2 (172.17.75.2): 56 data bytes
64 bytes from 172.17.75.2: seq=0 ttl=62 time=0.492 ms
64 bytes from 172.17.75.2: seq=1 ttl=62 time=0.353 ms
64 bytes from 172.17.75.2: seq=2 ttl=62 time=0.342 ms<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>slave节点</p>
<pre class="line-numbers language-shell"><code class="language-shell">docker run -it busybox sh
/ # ifconfig
eth0      Link encap:Ethernet  HWaddr 02:42:AC:11:4B:02  
          inet addr:172.17.75.2  Bcast:172.17.75.255  Mask:255.255.255.0
          UP BROADCAST RUNNING MULTICAST  MTU:1450  Metric:1
          RX packets:6 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0 
          RX bytes:516 (516.0 B)  TX bytes:0 (0.0 B)

lo        Link encap:Local Loopback  
          inet addr:127.0.0.1  Mask:255.0.0.0
          UP LOOPBACK RUNNING  MTU:65536  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000 
          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)

/ # ping 172.17.98.2
PING 172.17.98.2 (172.17.98.2): 56 data bytes
64 bytes from 172.17.98.2: seq=0 ttl=62 time=1.945 ms
64 bytes from 172.17.98.2: seq=1 ttl=62 time=0.344 ms
64 bytes from 172.17.98.2: seq=2 ttl=62 time=0.384 ms<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>注意:如果不能ping通，先重启flannel再重启docker试试</code></p>

        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2020-07-14T01:20:15.112Z" itemprop="dateUpdated">2020-07-14 09:20:15</time>
</span><br>


        
        想给作者写留言，请在下面使用Github账号登录，留言支持Markdown语法。如果这篇文章对你有所帮助，那就请我喝咖啡吧！
        
    </div>
    
    <footer>
        <a href="/">
            <img src="https://pic.imgdb.cn/item/5e9e78b6c2a9a83be545fef2.jpg" alt="荒原饮露">
            荒原饮露
        </a>
    </footer>
</blockquote>

        
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>



        <div class="post-footer">
            
	<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Docker/" rel="tag">Docker</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/" rel="tag">云计算</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/" rel="tag">容器技术</a></li></ul>


            


        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/post/62ac8f71.html" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">ansible的jinja2模板(16)</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/post/44241b5a.html" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">Dockerfile定制容器镜像(6)</h4>
      </a>
    </div>
  
</nav>



    

















<section class="comments" id="comments">
    <div id="gitalk-container"></div>
    <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
    <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
    <script>
        var id = location.pathname
        if (location.pathname.length > 50) {
          id = location.pathname.replace(/\/\d+\/\d+\/\d+\//, '').replace('/', '').substring(0, 50)
        }
        const gitalk = new Gitalk({
          clientID: '23c466a5c9454511f778',
          clientSecret: '0175fa1cbbd5ae44c3a5adcd4a6ce32c0011032b',
          repo: 'mf-restart.github.io',
          owner: 'MF-ReStart',
          admin: ['MF-ReStart'],
          id: id,      // Ensure uniqueness and length less than 50
          title: document.title.split('|')[0],
          distractionFreeMode: false  // Facebook-like distraction free mode
        })

        gitalk.render('gitalk-container')
    </script>
</section>




</article>

<div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        请我喝咖啡吧~
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="https://pic.imgdb.cn/item/5e9e7942c2a9a83be54666eb.jpg" alt="打赏二维码">
        </div>
        
        <label class="reward-toggle">
            <input id="rewardToggle" type="checkbox" class="reward-toggle-check"
                data-wechat="https://pic.imgdb.cn/item/5e9e7942c2a9a83be54666eb.jpg" data-alipay="https://pic.imgdb.cn/item/5e9e795ac2a9a83be54675ba.jpg">
            <div class="reward-toggle-ctrol">
                <span class="reward-toggle-item wechat">微信</span>
                <span class="reward-toggle-label"></span>
                <span class="reward-toggle-item alipay">支付宝</span>
            </div>
        </label>
        
    </div>
</div>



</div>

        <footer class="footer">
    <div class="bottom">
        <p><span>荒原饮露 &copy; 2019 - 2020</span>
            <span id="alive"></span>
            <script type="text/javascript">
                function runtime(){
                    // 初始时间，日/月/年 时:分:秒
                    X = new Date("03/24/2019 9:30:00");
                    Y = new Date();
                    T = (Y.getTime()-X.getTime());
                    M = 24*60*60*1000;
                    a = T/M;
                    A = Math.floor(a);
                    b = (a-A)*24;
                    B = Math.floor(b);
                    c = (b-B)*60;
                    C = Math.floor((b-B)*60);
                    D = Math.floor((c-C)*60);
                    //信息写入到DIV中
                    var alive = document.getElementById("alive");
                    alive.innerHTML = "本站勉强运行 : "+A+"天"+B+"小时"+C+"分"+D+"秒"
                }
                setInterval(runtime, 1000);
            </script>
            
        </p>
        <br>
        <p>
            <span>
                
                <div class="github-badge">
    <a style="color: #fff" rel="license" href="https://hexo.io/" target="_blank" title="由 Hexo 强力驱动">
        <span class="badge-subject">Powered</span><span class="badge-value bg-blue">Hexo</span></a>
</div>
<div class="github-badge">
    <a style="color: #fff" rel="license" href="https://github.com/" target="_blank"
       title="静态网页托管于 GitHub & Coding Pages">
        <span class="badge-subject">Hosted</span><span class="badge-value bg-brightgreen">GitHub & Coding Pages</span></a>
</div>
<div class="github-badge">
    <a style="color: #fff" rel="license" href="https://www.aliyun.com/" target="_blank" title="阿里云提供域名相关服务">
        <span class="badge-subject">DNS</span><span class="badge-value bg-blueviolet">Aliyun</span></a>
</div>
<div class="github-badge">
    <a style="color: #fff" rel="license" href="https://github.com/yscoder/hexo-theme-indigo" target="_blank"
       title="站点使用 Indigo 主题">
        <span class="badge-subject">Theme</span><span class="badge-value bg-blue">indigo</span></a>
</div>
<div class="github-badge">
    <a style="color: #fff" rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank"
       title="本站点采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可">
        <span class="badge-subject"><i class="icon icon-copyright"></i></span><span class="badge-value bg-lightgrey">BY-NC-SA 4.0</span></a>
</div>


    <div class="github-badge">
        <span class="badge-subject">UV</span><span class="badge-value bg-orange"
                                                                                   id="busuanzi_value_site_uv"></span>
    </div>
    <div class="github-badge">
        <span class="badge-subject">PV</span><span class="badge-value bg-brightgreen"
                                                                                   id="busuanzi_value_site_pv"></span>
    </div>
    <div class="github-badge">
        <span class="badge-subject">WordCount</span><span class="badge-value bg-blueviolet">
            
                4.5k
            
        </span>
    </div>


            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>


    <script src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.4/clipboard.min.js"></script>
<script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: false, REWARD: true };


</script>

<script src="/js/main.js"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="/js/search.js" async></script>






<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





</body>
</html>
