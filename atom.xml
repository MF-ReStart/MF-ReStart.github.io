<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>荒原饮露</title>
  
  <subtitle>青春不是隔岸观火啊</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.missf.top/"/>
  <updated>2020-08-05T03:19:41.569Z</updated>
  <id>https://www.missf.top/</id>
  
  <author>
    <name>荒原饮露</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Prometheus的pushgateway工具(8)</title>
    <link href="https://www.missf.top/post/5cf39589.html"/>
    <id>https://www.missf.top/post/5cf39589.html</id>
    <published>2020-08-04T10:05:33.000Z</published>
    <updated>2020-08-05T03:19:41.569Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PushGateway部署"><a href="#PushGateway部署" class="headerlink" title="PushGateway部署"></a>PushGateway部署</h1><p>prometheus基于http的pull方式去采集时间序列数据，但是由于业务需求，prometheus和exporter可能不在一个子网或者防火墙原因，导致Prometheus无法直接拉取各个target数据，或者需要将不同的数据进行汇总，这时候就可以使用prometheus的自带组件pushgateway进行数据的汇总，将默认的pull方式改为push方式进行数据的采集</p><pre class="line-numbers language-shell"><code class="language-shell"># 下载pushgatewaywget https://github.com/prometheus/pushgateway/releases/download/v1.2.0/pushgateway-1.2.0.linux-amd64.tar.gz# 解压tar xf pushgateway-1.2.0.linux-amd64.tar.gz && mv pushgateway-1.2.0.linux-amd64 /usr/local/pushgateway# 创建pushgateway启动文件vim /usr/lib/systemd/system/pushgateway.service[Unit]Documentation=pushgateway exporterAfter=local-fs.target network-online.target network.targetWants=local-fs.target network-online.target network.target[Service]Restart=on-failureExecStart=/usr/local/pushgateway/pushgateway    # 需要修改监听端口可以自行添加参数[Install]WantedBy=multi-user.target# 启动pushgatewaysystemctl start pushgateway.service<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Prometheus添加PushGateway"><a href="#Prometheus添加PushGateway" class="headerlink" title="Prometheus添加PushGateway"></a>Prometheus添加PushGateway</h1><p>在我们的prometheus配置文件添加pushgateway的地址</p><pre class="line-numbers language-yaml"><code class="language-yaml">vim /usr/local/prometheus/prometheus.yml<span class="token key atrule">scrape_configs</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">job_name</span><span class="token punctuation">:</span> <span class="token string">'pushgateway'</span>    <span class="token key atrule">static_configs</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">targets</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'49.233.200.185:9091'</span><span class="token punctuation">]</span>    <span class="token comment" spellcheck="true"># 这个是安装了pushgateway的服务器地址</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span>        <span class="token key atrule">instance</span><span class="token punctuation">:</span> pushgateway<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>重启prometheus服务</p><pre class="line-numbers language-shell"><code class="language-shell">systemctl restart prometheus.service<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>pushgateway其实是一个中转站，我们可以使用任何高级语言发送post请求到pushgateway，然后对数据进行增加删除等操作，pushgateway再把数据推送到prometheus</p><h1 id="推送数据到PushGateway"><a href="#推送数据到PushGateway" class="headerlink" title="推送数据到PushGateway"></a>推送数据到PushGateway</h1><pre class="line-numbers language-shell"><code class="language-shell">echo "missf 123456" | curl --data-binary @- http://49.233.200.185:9091/metrics/job/prometheus# 数据:missf,值:123456# --data-binary 表示发送二进制数据(post方式)# http://49.233.200.185:9091 pushgateway的地址<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>查看pushgateway推送到prometheus上的数据，这可以看到有exported_job=”prometheus”和job=”pushgateway”两个指标，我们推送数据时指定的job是prometheus，为什么这里的job会显示pushgateway呢？这里需要修改一个honor_labels的参数</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://pic.imgdb.cn/item/5f2a200a14195aa594b740f9.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>修改prometheus的配置文件，开启honor_labels参数(默认为false)</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">scrape_configs</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">job_name</span><span class="token punctuation">:</span> <span class="token string">'pushgateway'</span>    <span class="token key atrule">honor_labels</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>    <span class="token key atrule">static_configs</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">targets</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'49.233.200.185:9091'</span><span class="token punctuation">]</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span>        <span class="token key atrule">instance</span><span class="token punctuation">:</span> pushgateway<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>重启prometheus</p><p>再次推送数据到pushgateway，然后查看prometheus上的数据</p><pre class="line-numbers language-shell"><code class="language-shell">echo "mwj 123456" | curl --data-binary @- http://49.233.200.185:9091/metrics/job/prometheus/instance/missf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>{% image https://pic.imgdb.cn/item/5f2a245714195aa594b8dbe0.jpg '' '' %}<p>这里说明一下honor_labels的作用:因为prometheus配置pushgateway的时候，也会指定job和instance，但是它只表示pushgateway实例本身，不能真正表达收集数据的含义。所以配置pushgateway需要添加honor_labels:true参数，避免收集到的数据本身的job和instance被覆盖。具体参考官网</p><h1 id="在PushGateway删除数据"><a href="#在PushGateway删除数据" class="headerlink" title="在PushGateway删除数据"></a>在PushGateway删除数据</h1><pre class="line-numbers language-shell"><code class="language-shell">curl -X DELETE http://49.233.200.185:9091/metrics/job/prometheus/instance/missf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;PushGateway部署&quot;&gt;&lt;a href=&quot;#PushGateway部署&quot; class=&quot;headerlink&quot; title=&quot;PushGateway部署&quot;&gt;&lt;/a&gt;PushGateway部署&lt;/h1&gt;&lt;p&gt;prometheus基于http的pull方式去采集
      
    
    </summary>
    
    
      <category term="Prometheus" scheme="https://www.missf.top/categories/Prometheus/"/>
    
    
      <category term="云计算" scheme="https://www.missf.top/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
      <category term="Prometheus" scheme="https://www.missf.top/tags/Prometheus/"/>
    
      <category term="监控" scheme="https://www.missf.top/tags/%E7%9B%91%E6%8E%A7/"/>
    
  </entry>
  
  <entry>
    <title>Prometheus业务监控(7)</title>
    <link href="https://www.missf.top/post/f261c617.html"/>
    <id>https://www.missf.top/post/f261c617.html</id>
    <published>2020-08-03T02:26:26.000Z</published>
    <updated>2020-08-05T03:59:06.694Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Blackbox-exporter部署"><a href="#Blackbox-exporter部署" class="headerlink" title="Blackbox_exporter部署"></a>Blackbox_exporter部署</h1><p>Blackbox_exporter是prometheus官方提供的exporter之一，可以提供http、dns、tcp、icmp 的监控数据采集</p><pre class="line-numbers language-shell"><code class="language-shell"># 下载wget https://github.com/prometheus/blackbox_exporter/releases/download/v0.17.0/blackbox_exporter-0.17.0.linux-amd64.tar.gz# 解压tar xf blackbox_exporter-0.17.0.linux-amd64.tar.gz && mv blackbox_exporter-0.17.0.linux-amd64 /usr/local/blackbox# 创建blackbox启动文件vim /usr/lib/systemd/system/blackbox.service [Unit]Documentation=Blackbox exporterAfter=local-fs.target network-online.target network.targetWants=local-fs.target network-online.target network.target[Service]Restart=on-failureExecStart=/usr/local/blackbox/blackbox_exporter --config.file=/usr/local/blackbox/blackbox.yml[Install]WantedBy=multi-user.target# 启动blackboxsystemctl daemon-reloadsystemctl restart blackbox.service<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="配置TCP端口检测及告警"><a href="#配置TCP端口检测及告警" class="headerlink" title="配置TCP端口检测及告警"></a>配置TCP端口检测及告警</h1><p>传统的端口检测方式，调用命令的方式去实现</p><pre class="line-numbers language-shell"><code class="language-shell">ncat -vz 47.100.107.121 80    # 返回seconds而不是timeout那么端口就是通的telnet ......zabbix监控端口可以通过模板或者自定义key写脚本实现<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>修改prometheus配置文件，配置TCP端口检测</p><pre class="line-numbers language-yaml"><code class="language-yaml">vim /usr/local/prometheus/prometheus.yml<span class="token key atrule">scrape_configs</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">job_name</span><span class="token punctuation">:</span> <span class="token string">'nginx_port_check'</span>    <span class="token key atrule">metrics_path</span><span class="token punctuation">:</span> /probe    <span class="token key atrule">params</span><span class="token punctuation">:</span>      <span class="token key atrule">module</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>tcp_connect<span class="token punctuation">]</span>    <span class="token key atrule">file_sd_configs</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">files</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> check/port/nginx.json    <span class="token key atrule">relabel_configs</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">source_labels</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>__address__<span class="token punctuation">]</span>        <span class="token key atrule">target_label</span><span class="token punctuation">:</span> __param_target      <span class="token punctuation">-</span> <span class="token key atrule">source_labels</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>__param_target<span class="token punctuation">]</span>        <span class="token key atrule">target_label</span><span class="token punctuation">:</span> instance      <span class="token punctuation">-</span> <span class="token key atrule">target_label</span><span class="token punctuation">:</span> __address__        <span class="token key atrule">replacement</span><span class="token punctuation">:</span> 47.100.107.121<span class="token punctuation">:</span><span class="token number">9115    </span><span class="token comment" spellcheck="true"># 这个是blackbox所在主机以及端口</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编写监控TCP端口的告警规则</p><pre class="line-numbers language-yaml"><code class="language-yaml">vim /usr/local/prometheus/rules/nginx_port_check.yml<span class="token key atrule">groups</span><span class="token punctuation">:</span> <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx port check   <span class="token key atrule">rules</span><span class="token punctuation">:</span>   <span class="token punctuation">-</span> <span class="token key atrule">alert</span><span class="token punctuation">:</span> nginx_port_check failed     <span class="token key atrule">for</span><span class="token punctuation">:</span> 5s     <span class="token key atrule">expr</span><span class="token punctuation">:</span> probe_success<span class="token punctuation">{</span>job="nginx_port_check"<span class="token punctuation">}</span> == 0     <span class="token key atrule">labels</span><span class="token punctuation">:</span>       <span class="token key atrule">serverity</span><span class="token punctuation">:</span> critical     <span class="token key atrule">annotations</span><span class="token punctuation">:</span>       <span class="token key atrule">description</span><span class="token punctuation">:</span> <span class="token string">"{{ $labels.group }} port connection fail,{{ $labels.group }} value is:{{ $value }}"</span>      <span class="token key atrule">summary</span><span class="token punctuation">:</span> <span class="token string">"{{ $labels.group }} port connection failed"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>修改prometheus配置文件需要重启prometheus服务</p><pre class="line-numbers language-shell"><code class="language-shell">systemctl restart prometheus.service<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>关闭Nginx测试当80端口无法访问之后的告警结果</p><p><img src="https://pic.imgdb.cn/item/5f27e91d14195aa594ee2d22.jpg" alt=""></p><h1 id="业务接口检测及告警"><a href="#业务接口检测及告警" class="headerlink" title="业务接口检测及告警"></a>业务接口检测及告警</h1><p>基于现在Java + Vue前后端分离的开发模式下，我们很多时候需要去检测Java的接口是否正常。传统的手动检测可以使用postman，或者写shell脚本也可以实现，但是prometheus可以通过blackbox去更好的检测业务接口</p><p>修改prometheus配置文件，添加监控业务接口的job</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">scrape_configs</span><span class="token punctuation">:</span><span class="token punctuation">-</span> <span class="token key atrule">job_name</span><span class="token punctuation">:</span> <span class="token string">'get_mysite'</span>    <span class="token key atrule">scrape_interval</span><span class="token punctuation">:</span> 5s    <span class="token key atrule">metrics_path</span><span class="token punctuation">:</span> /probe    <span class="token key atrule">params</span><span class="token punctuation">:</span>      <span class="token key atrule">module</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>http_2xx<span class="token punctuation">]</span>    <span class="token key atrule">file_sd_configs</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">files</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> check/url/*.json    <span class="token key atrule">relabel_configs</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">source_labels</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>__address__<span class="token punctuation">]</span>        <span class="token key atrule">target_label</span><span class="token punctuation">:</span> __param_target      <span class="token punctuation">-</span> <span class="token key atrule">source_labels</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>__param_target<span class="token punctuation">]</span>        <span class="token key atrule">target_label</span><span class="token punctuation">:</span> instance      <span class="token punctuation">-</span> <span class="token key atrule">target_label</span><span class="token punctuation">:</span> __address__        <span class="token key atrule">replacement</span><span class="token punctuation">:</span> 47.100.107.121<span class="token punctuation">:</span><span class="token number">9115</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编写监控url链接的告警规则文件</p><pre class="line-numbers language-yaml"><code class="language-yaml">vim /usr/local/prometheus/rules/get_mysite.yml<span class="token key atrule">groups</span><span class="token punctuation">:</span> <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> get mysite check  <span class="token key atrule">rules</span><span class="token punctuation">:</span>   <span class="token punctuation">-</span> <span class="token key atrule">alert</span><span class="token punctuation">:</span> get_mysite_check failed     <span class="token key atrule">for</span><span class="token punctuation">:</span> 5s     <span class="token key atrule">expr</span><span class="token punctuation">:</span> probe_success<span class="token punctuation">{</span>group="get_mysite"<span class="token punctuation">,</span>instance="https<span class="token punctuation">:</span>//www.missf.top"<span class="token punctuation">,</span>job="get_mysite"<span class="token punctuation">}</span> == 0    <span class="token key atrule">labels</span><span class="token punctuation">:</span>       <span class="token key atrule">serverity</span><span class="token punctuation">:</span> critical     <span class="token key atrule">annotations</span><span class="token punctuation">:</span>       <span class="token key atrule">description</span><span class="token punctuation">:</span> <span class="token string">"{{ $labels.group }} failed, {{ $labels.group }} value is:{{ $value }}"</span>      <span class="token key atrule">summary</span><span class="token punctuation">:</span> <span class="token string">"{{ $labels.group }} website not accessible"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>修改prometheus配置文件之后记得重启prometheus服务</p><pre class="line-numbers language-shell"><code class="language-shell">systemctl restart prometheus.service<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果<a href="https://www.missf.top这个链接的http请求不是返回2xx的状态码就会告警" target="_blank" rel="noopener">https://www.missf.top这个链接的http请求不是返回2xx的状态码就会告警</a></p>{% image https://pic.imgdb.cn/item/5f28fbe914195aa5944ce74b.jpg '' '' %}<p>我们在监控业务接口时，只监控到接口的返回状态(2xx状态码)，假如我们想要监控业务接口的返回内容该如何实现呢？那就需要修改blackbox的配置文件</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">modules</span><span class="token punctuation">:</span>  <span class="token key atrule">http_2xx</span><span class="token punctuation">:</span>    <span class="token key atrule">prober</span><span class="token punctuation">:</span> http<span class="token comment" spellcheck="true"># 下面这段是需要添加的内容 </span>    <span class="token key atrule">http</span><span class="token punctuation">:</span>          <span class="token key atrule">method</span><span class="token punctuation">:</span> GET      <span class="token key atrule">headers</span><span class="token punctuation">:</span>        <span class="token key atrule">Host</span><span class="token punctuation">:</span> www.missf.top        <span class="token key atrule">Accept-Language</span><span class="token punctuation">:</span> en<span class="token punctuation">-</span>US        <span class="token key atrule">Origin</span><span class="token punctuation">:</span> missf.top      <span class="token key atrule">fail_if_body_matches_regexp</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 如果我get的url地址返回的正文中有"apache",那么就会失败,则probe_success值为0</span>        <span class="token punctuation">-</span> <span class="token string">"apache"</span>      <span class="token key atrule">fail_if_body_not_matches_regexp</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token string">"nginx"</span>    <span class="token comment" spellcheck="true"># 如果我get的url地址返回的正文中没有"nginx",那么就会失败,则probe_success值为0</span>  <span class="token key atrule">http_post_2xx</span><span class="token punctuation">:</span>    <span class="token key atrule">prober</span><span class="token punctuation">:</span> http    <span class="token key atrule">http</span><span class="token punctuation">:</span>      <span class="token key atrule">method</span><span class="token punctuation">:</span> POST  <span class="token key atrule">tcp_connect</span><span class="token punctuation">:</span>    <span class="token key atrule">prober</span><span class="token punctuation">:</span> tcp  <span class="token key atrule">pop3s_banner</span><span class="token punctuation">:</span>    <span class="token key atrule">prober</span><span class="token punctuation">:</span> tcp    <span class="token key atrule">tcp</span><span class="token punctuation">:</span>      <span class="token key atrule">query_response</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">expect</span><span class="token punctuation">:</span> <span class="token string">"^+OK"</span>      <span class="token key atrule">tls</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>      <span class="token key atrule">tls_config</span><span class="token punctuation">:</span>        <span class="token key atrule">insecure_skip_verify</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>  <span class="token key atrule">ssh_banner</span><span class="token punctuation">:</span>    <span class="token key atrule">prober</span><span class="token punctuation">:</span> tcp    <span class="token key atrule">tcp</span><span class="token punctuation">:</span>      <span class="token key atrule">query_response</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">expect</span><span class="token punctuation">:</span> <span class="token string">"^SSH-2.0-"</span>  <span class="token key atrule">irc_banner</span><span class="token punctuation">:</span>    <span class="token key atrule">prober</span><span class="token punctuation">:</span> tcp    <span class="token key atrule">tcp</span><span class="token punctuation">:</span>      <span class="token key atrule">query_response</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">send</span><span class="token punctuation">:</span> <span class="token string">"NICK prober"</span>      <span class="token punctuation">-</span> <span class="token key atrule">send</span><span class="token punctuation">:</span> <span class="token string">"USER prober prober prober :prober"</span>      <span class="token punctuation">-</span> <span class="token key atrule">expect</span><span class="token punctuation">:</span> <span class="token string">"PING :([^ ]+)"</span>        <span class="token key atrule">send</span><span class="token punctuation">:</span> <span class="token string">"PONG ${1}"</span>      <span class="token punctuation">-</span> <span class="token key atrule">expect</span><span class="token punctuation">:</span> <span class="token string">"^:[^ ]+ 001"</span>  <span class="token key atrule">icmp</span><span class="token punctuation">:</span>    <span class="token key atrule">prober</span><span class="token punctuation">:</span> icmp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>修改了blackbox配置文件需要重启blackbox服务</p><pre class="line-numbers language-shell"><code class="language-shell">systemctl restart blackbox.service<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面所配置的匹配返回内容是在http_2xx这个模块下添加的，我们需要修改prometheus配置文件对应的http_2xx模块的规则文件，配置我们监控业务接口的返回内容的url地址</p><pre class="line-numbers language-yaml"><code class="language-yaml">vim /usr/local/prometheus/check/url/get_mysite.json <span class="token punctuation">[</span><span class="token punctuation">{</span>        <span class="token key atrule">"targets"</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>            <span class="token string">"47.100.107.121"</span>    <span class="token comment" spellcheck="true"># 这个url返回的是默认的Nginx页面,对应我上面的匹配规则(nginx/apache)</span>        <span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token key atrule">"labels"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>            <span class="token key atrule">"group"</span><span class="token punctuation">:</span> <span class="token string">"get_mysite"</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>查看blackbox的采集数据</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://pic.imgdb.cn/item/5f292cb314195aa594682880.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>probe_success的值是根据我们在blackbox配置文件的正则去决定的</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://pic.imgdb.cn/item/5f292d4d14195aa59468abde.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>这时候我们get_mysite.json这个规则文件的job的probe_success值就是通过get获取一个url的返回值去确定的，我们这样就可以去监控接口的返回内容了</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://pic.imgdb.cn/item/5f292f3014195aa5946a6ddd.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="配置网络监控"><a href="#配置网络监控" class="headerlink" title="配置网络监控"></a>配置网络监控</h1><p>我们可以让服务器使用icmp协议去请求<a href="http://www.baidu.com或者是一个公网IP，测试服务器的网络是否正常" target="_blank" rel="noopener">www.baidu.com或者是一个公网IP，测试服务器的网络是否正常</a></p><p>修改prometheus配置文件，添加网络监控的job</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">scrape_configs</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">job_name</span><span class="token punctuation">:</span> <span class="token string">'icmp_check_network'</span>     <span class="token key atrule">scrape_interval</span><span class="token punctuation">:</span> 5s     <span class="token key atrule">metrics_path</span><span class="token punctuation">:</span> /probe     <span class="token key atrule">params</span><span class="token punctuation">:</span>       <span class="token key atrule">module</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>icmp<span class="token punctuation">]</span>     <span class="token key atrule">file_sd_configs</span><span class="token punctuation">:</span>     <span class="token punctuation">-</span> <span class="token key atrule">files</span><span class="token punctuation">:</span>       <span class="token punctuation">-</span> check/icmp/*.json     <span class="token key atrule">relabel_configs</span><span class="token punctuation">:</span>       <span class="token punctuation">-</span> <span class="token key atrule">source_labels</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>__address__<span class="token punctuation">]</span>         <span class="token key atrule">target_label</span><span class="token punctuation">:</span> __param_target       <span class="token punctuation">-</span> <span class="token key atrule">source_labels</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>__param_target<span class="token punctuation">]</span>         <span class="token key atrule">target_label</span><span class="token punctuation">:</span> instance       <span class="token punctuation">-</span> <span class="token key atrule">target_label</span><span class="token punctuation">:</span> __address__         <span class="token key atrule">replacement</span><span class="token punctuation">:</span> 47.100.107.121<span class="token punctuation">:</span><span class="token number">9115</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编写网络监控的规则文件</p><pre class="line-numbers language-yaml"><code class="language-yaml">vim /usr/local/prometheus/rules/check_network.yml<span class="token key atrule">groups</span><span class="token punctuation">:</span><span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> icmp check network  <span class="token key atrule">rules</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">alert</span><span class="token punctuation">:</span> icmp check network failed    <span class="token key atrule">for</span><span class="token punctuation">:</span> 10s    <span class="token key atrule">expr</span><span class="token punctuation">:</span> probe_success<span class="token punctuation">{</span>group="icmp_check_network"<span class="token punctuation">,</span>instance="www.baidu.com"<span class="token punctuation">,</span>job="icmp_check_network"<span class="token punctuation">}</span> == 0    <span class="token key atrule">labels</span><span class="token punctuation">:</span>       <span class="token key atrule">serverity</span><span class="token punctuation">:</span> critical    <span class="token key atrule">annotations</span><span class="token punctuation">:</span>      <span class="token key atrule">description</span><span class="token punctuation">:</span> <span class="token string">"{{ $labels.group }} icmp connection failed, {{ $labels.group }} value is: {{ $value }}"</span>      <span class="token key atrule">summary</span><span class="token punctuation">:</span> "<span class="token punctuation">{</span><span class="token punctuation">{</span> $labels.group <span class="token punctuation">}</span><span class="token punctuation">}</span> connection failed<span class="token punctuation">,</span> <span class="token key atrule">instance</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">{</span> $labels.instance <span class="token punctuation">}</span><span class="token punctuation">}</span>"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>修改prometheus配置文件之后记得重启prometheus服务</p><pre class="line-numbers language-shell"><code class="language-shell">systemctl restart prometheus.service<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Blackbox-exporter部署&quot;&gt;&lt;a href=&quot;#Blackbox-exporter部署&quot; class=&quot;headerlink&quot; title=&quot;Blackbox_exporter部署&quot;&gt;&lt;/a&gt;Blackbox_exporter部署&lt;/h1&gt;&lt;p&gt;Bl
      
    
    </summary>
    
    
      <category term="Prometheus" scheme="https://www.missf.top/categories/Prometheus/"/>
    
    
      <category term="云计算" scheme="https://www.missf.top/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
      <category term="Prometheus" scheme="https://www.missf.top/tags/Prometheus/"/>
    
      <category term="监控" scheme="https://www.missf.top/tags/%E7%9B%91%E6%8E%A7/"/>
    
  </entry>
  
  <entry>
    <title>Prometheus告警(6)</title>
    <link href="https://www.missf.top/post/615f0093.html"/>
    <id>https://www.missf.top/post/615f0093.html</id>
    <published>2020-07-23T03:53:03.000Z</published>
    <updated>2020-08-03T02:26:00.981Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Alertmanager概述"><a href="#Alertmanager概述" class="headerlink" title="Alertmanager概述"></a>Alertmanager概述</h1><p>prometheus发出告警时分为两部分，首先prometheus按告警规则(rule_files配置)向alertmanager发送告警，即告警规则是在prometheus上定义的，然后由alertmanager去管理这些告警，包括去重(deduplicating)、分组(grouping)、静音(silencing)、抑制(inhibition)、聚合(aggregation)，最终通过丰富的告警通知渠道(电话、微信、短信、邮件)将告警通知路由给对应的联系人。prometheus的大部分组件都是go语言开发的，zabbix到4.4之后的客户端才是go编写</p><h1 id="Alertmanager二进制安装"><a href="#Alertmanager二进制安装" class="headerlink" title="Alertmanager二进制安装"></a>Alertmanager二进制安装</h1><pre class="line-numbers language-shell"><code class="language-shell"># 下载wget https://github.com/prometheus/alertmanager/releases/download/v0.21.0/alertmanager-0.21.0.linux-amd64.tar.gz# 解压tar xf alertmanager-0.21.0.linux-amd64.tar.gz && mv alertmanager-0.21.0.linux-amd64 /usr/local/alertmanager# 创建alertmanager启动文件vim /usr/lib/systemd/system/alertmanager.service[Unit]Documentation=alertmanager[Service]Restart=on-failureExecStart=/usr/local/alertmanager/alertmanager --config.file=/usr/local/alertmanager/alertmanager.yml --storage.path=/usr/local/alertmanager/data[Install]WantedBy=multi-user.target# 启动systemctl daemon-reloadsystemctl start alertmanager.service<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Alertmanager配置文件详解"><a href="#Alertmanager配置文件详解" class="headerlink" title="Alertmanager配置文件详解"></a>Alertmanager配置文件详解</h1><pre class="line-numbers language-yaml"><code class="language-yaml">vim /usr/local/alertmanager/alertmanager.yml<span class="token key atrule">global</span><span class="token punctuation">:</span>  <span class="token key atrule">resolve_timeout</span><span class="token punctuation">:</span> 5m    <span class="token comment" spellcheck="true"># 恢复的超时时间,这个跟告警恢复通知有关,此参数并不是说在这个时间没有收到告警就会恢复</span><span class="token key atrule">route</span><span class="token punctuation">:</span>  <span class="token key atrule">group_by</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'alertname'</span><span class="token punctuation">]</span>    <span class="token comment" spellcheck="true"># 默认以告警名进行分组,就是rule文件的alert值进行分组</span>  <span class="token key atrule">group_wait</span><span class="token punctuation">:</span> 10s    <span class="token comment" spellcheck="true"># 发送警报前，至少等待多少秒才会发送(为了收集同组更多的警报信息一起发送)</span>  <span class="token key atrule">group_interval</span><span class="token punctuation">:</span> 10s    <span class="token comment" spellcheck="true"># 如果警报1已经发送,这时又出现同组的警报2,由于组状态发生变化,警报会在group_interval这个时间内发送,不会被repeat_interval这个时间收敛</span>  <span class="token key atrule">repeat_interval</span><span class="token punctuation">:</span> 20m    <span class="token comment" spellcheck="true"># 报警信息已发送，但事件并没有恢复,则等待多久时间再重新发送(生产环境一般设成20min或者30min)</span>  <span class="token key atrule">receiver</span><span class="token punctuation">:</span> <span class="token string">'web.hook'</span>    <span class="token comment" spellcheck="true"># 发送警报的接收者名称,如果一个报警没有被一个route匹配,则发送给默认的接收器</span><span class="token key atrule">receivers</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 发送告警信息给那个接收者</span><span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> <span class="token string">'web.hook'</span>    <span class="token comment" spellcheck="true"># 这个需要和上面定义的接收者名称一致</span>  <span class="token key atrule">webhook_configs</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">url</span><span class="token punctuation">:</span> <span class="token string">'http://127.0.0.1:5001/'</span><span class="token key atrule">inhibit_rules</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 抑制规则,防止告警风暴</span>  <span class="token punctuation">-</span> <span class="token key atrule">source_match</span><span class="token punctuation">:</span>      <span class="token key atrule">severity</span><span class="token punctuation">:</span> <span class="token string">'critical'</span>    <span class="token key atrule">target_match</span><span class="token punctuation">:</span>      <span class="token key atrule">severity</span><span class="token punctuation">:</span> <span class="token string">'warning'</span>    <span class="token key atrule">equal</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'alertname'</span><span class="token punctuation">,</span> <span class="token string">'dev'</span><span class="token punctuation">,</span> <span class="token string">'instance'</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="检查Alertmanager配置文件"><a href="#检查Alertmanager配置文件" class="headerlink" title="检查Alertmanager配置文件"></a>检查Alertmanager配置文件</h1><pre class="line-numbers language-shell"><code class="language-shell"># 提示SUCCESS,则配置文件没有问题./amtool check-config alertmanager.yml# 修改配置文件之后重启alertmanagersystemctl restart alertmanager.service<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="配置邮件告警"><a href="#配置邮件告警" class="headerlink" title="配置邮件告警"></a>配置邮件告警</h1><p>修改alertmanager配置文件，填写邮箱的验证信息，定义路由的收件人，配置发送告警邮件到那个邮箱</p><pre class="line-numbers language-yaml"><code class="language-yaml">cat /usr/local/alertmanager/alertmanager.yml <span class="token key atrule">global</span><span class="token punctuation">:</span>  <span class="token key atrule">resolve_timeout</span><span class="token punctuation">:</span> 3m  <span class="token key atrule">smtp_smarthost</span><span class="token punctuation">:</span> <span class="token string">'smtp.qq.com:465'</span>  <span class="token key atrule">smtp_from</span><span class="token punctuation">:</span> <span class="token string">'1173354099@qq.com'</span>  <span class="token key atrule">smtp_auth_username</span><span class="token punctuation">:</span> <span class="token string">'1173354099@qq.com'</span>  <span class="token key atrule">smtp_auth_password</span><span class="token punctuation">:</span> <span class="token string">''</span>    <span class="token comment" spellcheck="true"># 授权码</span>  <span class="token key atrule">smtp_require_tls</span><span class="token punctuation">:</span> <span class="token boolean important">false</span><span class="token key atrule">route</span><span class="token punctuation">:</span>  <span class="token key atrule">group_by</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'alertname'</span><span class="token punctuation">]</span>  <span class="token key atrule">group_wait</span><span class="token punctuation">:</span> 10s  <span class="token key atrule">group_interval</span><span class="token punctuation">:</span> 10s  <span class="token key atrule">repeat_interval</span><span class="token punctuation">:</span> 20m  <span class="token key atrule">receiver</span><span class="token punctuation">:</span> <span class="token string">'devops.mail'</span><span class="token key atrule">receivers</span><span class="token punctuation">:</span><span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> <span class="token string">'devops.mail'</span>  <span class="token key atrule">email_configs</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">to</span><span class="token punctuation">:</span> <span class="token string">'mf_2013@163.com'</span>    <span class="token key atrule">headers</span><span class="token punctuation">:</span> <span class="token punctuation">{</span> <span class="token key atrule">Subject</span><span class="token punctuation">:</span> <span class="token string">"[WARN] Prometheus 报警邮件"</span> <span class="token punctuation">}</span>    <span class="token key atrule">send_resolved</span><span class="token punctuation">:</span> <span class="token boolean important">true        </span><span class="token comment" spellcheck="true"># 发送告警恢复通知</span><span class="token comment" spellcheck="true">#inhibit_rules:</span><span class="token comment" spellcheck="true">#  - source_match:</span><span class="token comment" spellcheck="true">#      severity: 'critical'</span><span class="token comment" spellcheck="true">#    target_match:</span><span class="token comment" spellcheck="true">#      severity: 'warning'</span><span class="token comment" spellcheck="true">#    equal: ['alertname', 'dev', 'instance']</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>配置prometheus与alertmanager通信，设置规则文件的路径和正则匹配</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true"># 修改prometheus配置文件</span>vim /usr/local/prometheus/prometheus.yml<span class="token key atrule">alerting</span><span class="token punctuation">:</span>  <span class="token key atrule">alertmanagers</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">static_configs</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">targets</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> 127.0.0.1<span class="token punctuation">:</span><span class="token number">9093    </span><span class="token comment" spellcheck="true"># 这里由于alertmanager是和prometheus部署在同一台机器上,所以写本机地址</span><span class="token key atrule">rule_files</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token string">"rules/*.yml"</span>    <span class="token comment" spellcheck="true"># rules这个目录是在prometheus上的,指当前配置文件的同级目录,这个目录需要自己创建</span><span class="token comment" spellcheck="true"># 检查prometheus配置文件</span>./promtool check config prometheus.ymlsystemctl restart prometheus.service<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编写rules文件，根据rules文件中的表达式去告警，这个规则文件的路径是prometheus配置文件中定义的</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true"># 监控节点的状态</span>cat /usr/local/prometheus/rules/node.yml <span class="token key atrule">groups</span><span class="token punctuation">:</span><span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> node_alert  <span class="token key atrule">rules</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">alert</span><span class="token punctuation">:</span> Node_InstanceDown            <span class="token key atrule">expr</span><span class="token punctuation">:</span> up == 0    <span class="token comment" spellcheck="true"># 表达式</span>    <span class="token key atrule">for</span><span class="token punctuation">:</span> 5s    <span class="token key atrule">labels</span><span class="token punctuation">:</span>      <span class="token key atrule">serverity</span><span class="token punctuation">:</span> error    <span class="token key atrule">annotations</span><span class="token punctuation">:</span>      <span class="token key atrule">summary</span><span class="token punctuation">:</span> <span class="token string">"Instance {{ $labels.instance }} down"</span>      <span class="token key atrule">description</span><span class="token punctuation">:</span> <span class="token string">"{{ $labels.instance }} of job {{ $labels.job }} has been down for more than 5 minutes"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在prometheus的web控制台查看配置的规则</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://pic.imgdb.cn/item/5f20e09814195aa594f3290e.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>关闭node_exporter.service节点，查看告警邮件</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://pic.imgdb.cn/item/5f20e13414195aa594f3b901.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="配置微信告警"><a href="#配置微信告警" class="headerlink" title="配置微信告警"></a>配置微信告警</h1><p>修改alertmanager配置文件，定义路由规则</p><pre class="line-numbers language-yaml"><code class="language-yaml">cat /usr/local/alertmanager/alertmanager.yml <span class="token key atrule">global</span><span class="token punctuation">:</span>  <span class="token key atrule">resolve_timeout</span><span class="token punctuation">:</span> 3m  <span class="token key atrule">smtp_smarthost</span><span class="token punctuation">:</span> <span class="token string">'smtp.qq.com:465'</span>  <span class="token key atrule">smtp_from</span><span class="token punctuation">:</span> <span class="token string">'1173354099@qq.com'</span>  <span class="token key atrule">smtp_auth_username</span><span class="token punctuation">:</span> <span class="token string">'1173354099@qq.com'</span>  <span class="token key atrule">smtp_auth_password</span><span class="token punctuation">:</span> <span class="token string">''</span>    <span class="token comment" spellcheck="true"># 授权码</span>  <span class="token key atrule">smtp_require_tls</span><span class="token punctuation">:</span> <span class="token boolean important">false</span><span class="token key atrule">templates</span><span class="token punctuation">:</span><span class="token punctuation">-</span> /usr/local/alertmanager/template/wechat.temp<span class="token key atrule">route</span><span class="token punctuation">:</span>  <span class="token key atrule">group_by</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'alertname'</span><span class="token punctuation">]</span>  <span class="token key atrule">group_wait</span><span class="token punctuation">:</span> 10s  <span class="token key atrule">group_interval</span><span class="token punctuation">:</span> 10s  <span class="token key atrule">repeat_interval</span><span class="token punctuation">:</span> 20m  <span class="token comment" spellcheck="true">#receiver: 'devops.mail'</span>  <span class="token key atrule">receiver</span><span class="token punctuation">:</span> <span class="token string">'devops.mailwechat'</span>  <span class="token key atrule">routes</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 为node_exporter、docker、mysqld_exporter定义匹配路由,每个路由有自己的分组在微信告警时信息就会单独发送</span>  <span class="token punctuation">-</span> <span class="token key atrule">receiver</span><span class="token punctuation">:</span> <span class="token string">'devops.mailwechat'</span>    <span class="token comment" spellcheck="true"># 每个服务可以定义自己的接收者,这样在发送时就可以发送给不同的人,不同的服务对应不同的处理人员</span>    <span class="token key atrule">group_wait</span><span class="token punctuation">:</span> 10s    <span class="token key atrule">group_by</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'node_exporter'</span><span class="token punctuation">]</span>    <span class="token key atrule">match_re</span><span class="token punctuation">:</span>      <span class="token key atrule">job</span><span class="token punctuation">:</span> node_exporter  <span class="token punctuation">-</span> <span class="token key atrule">receiver</span><span class="token punctuation">:</span> <span class="token string">'devops.mailwechat'</span>    <span class="token key atrule">group_wait</span><span class="token punctuation">:</span> 10s    <span class="token key atrule">group_by</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'docker'</span><span class="token punctuation">]</span>    <span class="token key atrule">match_re</span><span class="token punctuation">:</span>      <span class="token key atrule">job</span><span class="token punctuation">:</span> docker  <span class="token punctuation">-</span> <span class="token key atrule">receiver</span><span class="token punctuation">:</span> <span class="token string">'devops.mailwechat'</span>    <span class="token key atrule">group_wait</span><span class="token punctuation">:</span> 10s    <span class="token key atrule">group_by</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'mysqld_exporter'</span><span class="token punctuation">]</span>    <span class="token key atrule">match_re</span><span class="token punctuation">:</span>      <span class="token key atrule">job</span><span class="token punctuation">:</span> mysqld_exporter<span class="token key atrule">receivers</span><span class="token punctuation">:</span><span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> <span class="token string">'devops.mailwechat'</span>    <span class="token comment" spellcheck="true"># 将这个告警同时发送到邮件和微信</span>  <span class="token key atrule">email_configs</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">to</span><span class="token punctuation">:</span> <span class="token string">'mf_2013@163.com'</span>    <span class="token key atrule">headers</span><span class="token punctuation">:</span> <span class="token punctuation">{</span> <span class="token key atrule">Subject</span><span class="token punctuation">:</span> <span class="token string">"[WARN] Prometheus 报警邮件"</span> <span class="token punctuation">}</span>    <span class="token key atrule">send_resolved</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">wechat_configs</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">api_secret</span><span class="token punctuation">:</span> <span class="token string">''</span>    <span class="token key atrule">agent_id</span><span class="token punctuation">:</span> <span class="token string">''</span>    <span class="token key atrule">corp_id</span><span class="token punctuation">:</span> <span class="token string">''</span>    <span class="token key atrule">to_party</span><span class="token punctuation">:</span> <span class="token string">''</span>    <span class="token key atrule">send_resolved</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span class="token comment" spellcheck="true">#inhibit_rules:</span><span class="token comment" spellcheck="true">#  - source_match:</span><span class="token comment" spellcheck="true">#      severity: 'critical'</span><span class="token comment" spellcheck="true">#    target_match:</span><span class="token comment" spellcheck="true">#      severity: 'warning'</span><span class="token comment" spellcheck="true">#    equal: ['alertname', 'dev', 'instance']</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编写rules文件，为了每个服务单独报警，这里将node_exporter、docker、mysqld_exporter分开去写匹配规则</p><pre class="line-numbers language-yaml"><code class="language-yaml">cat /usr/local/prometheus/rules/node.yml <span class="token key atrule">groups</span><span class="token punctuation">:</span><span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> node_exporter  <span class="token key atrule">rules</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">alert</span><span class="token punctuation">:</span> node_exporter_Down    <span class="token key atrule">expr</span><span class="token punctuation">:</span> up<span class="token punctuation">{</span>job="node_exporter"<span class="token punctuation">}</span> == 0    <span class="token key atrule">for</span><span class="token punctuation">:</span> 5s    <span class="token key atrule">labels</span><span class="token punctuation">:</span>      <span class="token key atrule">serverity</span><span class="token punctuation">:</span> error    <span class="token key atrule">annotations</span><span class="token punctuation">:</span>      <span class="token key atrule">summary</span><span class="token punctuation">:</span> <span class="token string">"Instance {{ $labels.instance }} down"</span>      <span class="token key atrule">description</span><span class="token punctuation">:</span> <span class="token string">"{{ $labels.instance }} of job {{ $labels.job }} has been down for more than 5 minutes"</span><span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> mysqld_exporter  <span class="token key atrule">rules</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">alert</span><span class="token punctuation">:</span> mysqld_exporter_Down    <span class="token key atrule">expr</span><span class="token punctuation">:</span> up<span class="token punctuation">{</span>job="mysqld_exporter"<span class="token punctuation">}</span> == 0    <span class="token key atrule">for</span><span class="token punctuation">:</span> 5s    <span class="token key atrule">labels</span><span class="token punctuation">:</span>      <span class="token key atrule">serverity</span><span class="token punctuation">:</span> error    <span class="token key atrule">annotations</span><span class="token punctuation">:</span>      <span class="token key atrule">summary</span><span class="token punctuation">:</span> <span class="token string">"Instance {{ $labels.instance }} down"</span>      <span class="token key atrule">description</span><span class="token punctuation">:</span> <span class="token string">"{{ $labels.instance }} of job {{ $labels.job }} has been down for more than 5 minutes"</span><span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> docker  <span class="token key atrule">rules</span><span class="token punctuation">:</span>   <span class="token punctuation">-</span> <span class="token key atrule">alert</span><span class="token punctuation">:</span> docker_Down    <span class="token key atrule">expr</span><span class="token punctuation">:</span> up<span class="token punctuation">{</span>job="docker"<span class="token punctuation">}</span> == 0    <span class="token key atrule">for</span><span class="token punctuation">:</span> 5s    <span class="token key atrule">labels</span><span class="token punctuation">:</span>      <span class="token key atrule">serverity</span><span class="token punctuation">:</span> error    <span class="token key atrule">annotations</span><span class="token punctuation">:</span>      <span class="token key atrule">summary</span><span class="token punctuation">:</span> <span class="token string">"Instance {{ $labels.instance }} down"</span>      <span class="token key atrule">description</span><span class="token punctuation">:</span> <span class="token string">"{{ $labels.instance }} of job {{ $labels.job }} has been down for more than 5 minutes"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>配置完成之后重启alertmanager</p><pre class="line-numbers language-shell"><code class="language-shell">systemctl restart alertmanager.service<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>关闭node_exporter和docker_cadvisor服务，这时候会每个服务单独发送告警信息，由于将全部服务group_by在一个组里面，在发送恢复信息时会出现服务混乱的情况，所以我将每个服务做了路由，每一个服务都有自己的group_by，这样在发送信息时才会单独去发送</p><p><img src="https://pic.imgdb.cn/item/5f2140bc14195aa5945ae70c.jpg" alt=""></p><h1 id="配置钉钉告警"><a href="#配置钉钉告警" class="headerlink" title="配置钉钉告警"></a>配置钉钉告警</h1><p>先去创建一个钉钉机器人，具体过程这里就不详细说明了</p><p>prometheus配置钉钉告警需要使用到prometheus-webhook-dingtalk插件，我们先使用二进制安装钉钉插件，dingtalk服务默认启动的端口是8060</p><p><a href="https://github.com/timonwong/prometheus-webhook-dingtalk" target="_blank" rel="noopener">prometheus-webhook-dingtalk插件下载地址</a></p><pre class="line-numbers language-shell"><code class="language-shell"># 下载prometheus-webhook-dingtalkwget https://github.com/timonwong/prometheus-webhook-dingtalk/releases/download/v1.4.0/prometheus-webhook-dingtalk-1.4.0.linux-amd64.tar.gz# 解压prometheus-webhook-dingtalktar xf prometheus-webhook-dingtalk-1.4.0.linux-amd64.tar.gz && mv prometheus-webhook-dingtalk-1.4.0.linux-amd64 /usr/local/dingtalk# 编写dingtalk启动文件vim /usr/lib/systemd/system/dingtalk.service[Unit]Description=prometheus-webhook-dingtalkAfter=network-online.target[Service]Restart=on-failureExecStart=/usr/local/dingtalk/prometheus-webhook-dingtalk \--ding.profile=Prometheus告警=https://oapi.dingtalk.com/robot/send?access_token=xxxxxx[Install]WantedBy=multi-user.target# 启动dingtalk.servicesystemctl daemon-reloadsystemctl restart dingtalk.service# 查看dingtalk的webhook地址journalctl -fu dingtalk.serviceJul 29 18:38:01 iZuf6fpaicz5jt7kep555qZ prometheus-webhook-dingtalk[5504]: ts=2020-07-29T10:38:01.655Z caller=main.go:133 component=configuration msg="Webhook urls for prometheus alertmanager" urls=http://localhost:8060/dingtalk/Prometheus告警/send<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>修改prometheus的alertmanager配置，更改告警的路由和接收者</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">route</span><span class="token punctuation">:</span>  <span class="token key atrule">receiver</span><span class="token punctuation">:</span> <span class="token string">'devops_dingtalk'</span>    <span class="token comment" spellcheck="true"># 接收者必须和下面的一致</span><span class="token key atrule">receivers</span><span class="token punctuation">:</span><span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> <span class="token string">'devops_dingtalk'</span>  <span class="token key atrule">webhook_configs</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">url</span><span class="token punctuation">:</span> <span class="token string">'http://localhost:8060/dingtalk/Prometheus告警/send'</span>    <span class="token comment" spellcheck="true"># 这个URL是dingtalk的webhook地址</span>    <span class="token key atrule">send_resolved</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>关闭docker收集器查看告警效果</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://pic.imgdb.cn/item/5f22831a14195aa594112818.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="告警状态"><a href="#告警状态" class="headerlink" title="告警状态"></a>告警状态</h1><p>prometheus的告警状态有三种，我们可以在prometheus的控制台页面上查看告警的状态</p><h2 id="inactive"><a href="#inactive" class="headerlink" title="inactive"></a>inactive</h2><p>没有触发任何阈值，这个是根据scrape_interval参数(采集数据周期)和evaluation_interval参数(对比规则周期)去决定的</p><h2 id="pending"><a href="#pending" class="headerlink" title="pending"></a>pending</h2><p>已触发阈值但未满足告警持续时间，告警进入pending状态之后，需要等待规则配置的for时间，如果在这个时间内触发阈值的表达式一直成立，才会进入firing状态</p><h2 id="firing"><a href="#firing" class="headerlink" title="firing"></a>firing</h2><p>已触发阈值且满足告警持续时间，将告警从prometheus发送给alertmanager，在alertmanager收到告警之后并不会立刻发送，还需要等待一个group_wait时间，直到某个计算周期表达式为假，告警状态变更为inactive，发送一个resolve给altermanger，说明此告警已解决</p><h1 id="告警收敛"><a href="#告警收敛" class="headerlink" title="告警收敛"></a>告警收敛</h1><p>alertmanager在收到prometheus发送的告警之后，并不是把收到的信息简单的直接发送出去，而是通过一系列的收敛机制(分组、抑制、静默)去筛选出需要发送的信息，如果alertmanager收到信息就直接发送出去，会导致告警信息过多，运维人员会被告警信息淹没，错过重要的告警信息 </p><p><img src="https://pic.imgdb.cn/item/5f23803214195aa5946d5b86.jpg" alt=""></p><h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h2><p>将类似性质的告警分类为单个通知，减少告警消息数量</p><p>将类似性质的告警进行聚合发送，帮助运维更好的排查问题</p><h2 id="抑制"><a href="#抑制" class="headerlink" title="抑制"></a>抑制</h2><p>当告警发出后，停止重复发送由此告警而引起的其他告警，帮助运维第一时间掌握最核心的告警信息</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">inhibit_rules</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">source_match</span><span class="token punctuation">:</span>      <span class="token key atrule">severity</span><span class="token punctuation">:</span> <span class="token string">'critical'</span>    <span class="token comment" spellcheck="true"># 当发生critical级别的告警时,就会抑制下面warning级别的告警</span>    <span class="token key atrule">target_match</span><span class="token punctuation">:</span>      <span class="token key atrule">severity</span><span class="token punctuation">:</span> <span class="token string">'warning'</span>    <span class="token key atrule">equal</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'alertname'</span><span class="token punctuation">,</span> <span class="token string">'dev'</span><span class="token punctuation">,</span> <span class="token string">'instance'</span><span class="token punctuation">]</span>    <span class="token comment" spellcheck="true"># 已发送的告警与新产生的告警中equal定义的标签完全相同,则启动抑制机制</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="静默"><a href="#静默" class="headerlink" title="静默"></a>静默</h2><p>是一种简单的特定时间静音的提醒机制，在发布新版本时我们需要停掉某些进程，这时候告警肯定会触发的，由于这是我们已经预知的现象，我们可以打开prometheus主机的9093端口暂时将告警设置成静音</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://pic.imgdb.cn/item/5f23c66b14195aa5948a1e2d.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="Prometheus一条告警是怎么触发的"><a href="#Prometheus一条告警是怎么触发的" class="headerlink" title="Prometheus一条告警是怎么触发的"></a>Prometheus一条告警是怎么触发的</h1><p>1.采集数据 scrape_interval: 15s</p><p>2.比对采集到的数据是否触发阈值 evaluation_interval: 15s</p><p>3.判断是否超出持续时间(在这个时间内一直处于触发阈值状态)for: 5s</p><p>4.告警到达alertmanager然后进行分组、抑制、静默</p><p>5.通过分组、抑制、静默一系列机制的信息将会被发送，但是会延迟发送group_wait: 10s</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://pic.imgdb.cn/item/5f23ceb714195aa5948dbd05.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="编写告警规则案例"><a href="#编写告警规则案例" class="headerlink" title="编写告警规则案例"></a>编写告警规则案例</h1><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">groups</span><span class="token punctuation">:</span><span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> general.rules  <span class="token key atrule">rules</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">alert</span><span class="token punctuation">:</span> node_FileSystemUsage    <span class="token comment" spellcheck="true"># 监控磁盘使用率</span>    <span class="token key atrule">expr</span><span class="token punctuation">:</span> 100 <span class="token punctuation">-</span> node_filesystem_free_bytes<span class="token punctuation">{</span>mountpoint="/"<span class="token punctuation">,</span>fstype=~"ext4<span class="token punctuation">|</span>xfs"<span class="token punctuation">}</span> / node_filesystem_size_bytes<span class="token punctuation">{</span>mountpoint="/"<span class="token punctuation">,</span>fstype=~"ext4<span class="token punctuation">|</span>xfs"<span class="token punctuation">}</span> * 100 <span class="token punctuation">></span> 80    <span class="token key atrule">for</span><span class="token punctuation">:</span> 5s    <span class="token key atrule">labels</span><span class="token punctuation">:</span>      <span class="token key atrule">serverity</span><span class="token punctuation">:</span> warning    <span class="token key atrule">annotations</span><span class="token punctuation">:</span>      <span class="token key atrule">summary</span><span class="token punctuation">:</span> <span class="token string">"Instance {{ $labels.instance }} : {{ $labels.mountpoint }} Partition utilization is too high"</span>      <span class="token key atrule">description</span><span class="token punctuation">:</span> <span class="token string">"{{ $labels.instance }} : {{ $labels.mountpoint }} Partition utilization is greater than 80% (Currently: {{ $value }})"</span>  <span class="token punctuation">-</span> <span class="token key atrule">alert</span><span class="token punctuation">:</span> node_MemoryUsage    <span class="token comment" spellcheck="true"># 监控内存使用率</span>    <span class="token key atrule">expr</span><span class="token punctuation">:</span> 100 <span class="token punctuation">-</span> (node_memory_MemFree_bytes + node_memory_Buffers_bytes + node_memory_Cached_bytes) / node_memory_MemTotal_bytes * 100 <span class="token punctuation">></span> 80    <span class="token key atrule">for</span><span class="token punctuation">:</span> 5s    <span class="token key atrule">labels</span><span class="token punctuation">:</span>      <span class="token key atrule">serverity</span><span class="token punctuation">:</span> warning    <span class="token key atrule">annotations</span><span class="token punctuation">:</span>      <span class="token key atrule">summary</span><span class="token punctuation">:</span> <span class="token string">"Instance {{ $labels.instance }} High memory usage"</span>      <span class="token key atrule">description</span><span class="token punctuation">:</span> <span class="token string">"{{ $labels.instance }}  Memory usage greater than 80% (Currently: {{ $value }})"</span>  <span class="token punctuation">-</span> <span class="token key atrule">alert</span><span class="token punctuation">:</span> node_cpuUsage    <span class="token comment" spellcheck="true"># 监控CPU使用率</span>    <span class="token key atrule">expr</span><span class="token punctuation">:</span> 100 <span class="token punctuation">-</span> irate(node_cpu_seconds_total<span class="token punctuation">{</span>mode="idle"<span class="token punctuation">,</span>job="node_exporter"<span class="token punctuation">,</span>instance="47.100.107.121<span class="token punctuation">:</span>9100"<span class="token punctuation">}</span><span class="token punctuation">[</span>5m<span class="token punctuation">]</span>) * 100 <span class="token punctuation">></span> 80    <span class="token key atrule">for</span><span class="token punctuation">:</span> 5s    <span class="token key atrule">labels</span><span class="token punctuation">:</span>      <span class="token key atrule">serverity</span><span class="token punctuation">:</span> warning    <span class="token key atrule">annotations</span><span class="token punctuation">:</span>      <span class="token key atrule">summary</span><span class="token punctuation">:</span> <span class="token string">"Instance {{ $labels.instance }} High cpu usage"</span>      <span class="token key atrule">description</span><span class="token punctuation">:</span> <span class="token string">"{{ $labels.instance }} Memory usage greater than 60% (Currently: {{ $value }})"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Alertmanager概述&quot;&gt;&lt;a href=&quot;#Alertmanager概述&quot; class=&quot;headerlink&quot; title=&quot;Alertmanager概述&quot;&gt;&lt;/a&gt;Alertmanager概述&lt;/h1&gt;&lt;p&gt;prometheus发出告警时分为两部分，首
      
    
    </summary>
    
    
      <category term="Prometheus" scheme="https://www.missf.top/categories/Prometheus/"/>
    
    
      <category term="云计算" scheme="https://www.missf.top/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
      <category term="Prometheus" scheme="https://www.missf.top/tags/Prometheus/"/>
    
      <category term="监控" scheme="https://www.missf.top/tags/%E7%9B%91%E6%8E%A7/"/>
    
  </entry>
  
  <entry>
    <title>Prometheus监控案例(5)</title>
    <link href="https://www.missf.top/post/ba827699.html"/>
    <id>https://www.missf.top/post/ba827699.html</id>
    <published>2020-07-16T07:43:16.000Z</published>
    <updated>2020-08-03T03:27:09.082Z</updated>
    
    <content type="html"><![CDATA[<h1 id="监控Linux服务器"><a href="#监控Linux服务器" class="headerlink" title="监控Linux服务器"></a>监控Linux服务器</h1><h2 id="部署node-exporter"><a href="#部署node-exporter" class="headerlink" title="部署node_exporter"></a>部署node_exporter</h2><p>prometheus官方提供Node_exporter来让我们收集机器的系统数据，除node_exporter外，官方还提供consul、memcached、haproxy、mysqld等exporter。exporter类似于zabbix写好的监控模板，但是这些exporter都是需要在被监控节点安装</p><pre class="line-numbers language-shell"><code class="language-shell"># 下载node_exporterwget https://github.com/prometheus/node_exporter/releases/download/v1.0.1/node_exporter-1.0.1.linux-amd64.tar.gz# 解压tar xf node_exporter-1.0.1.linux-amd64.tar.gz && mv node_exporter-1.0.1.linux-amd64 /usr/local/node_exporter# 编写启动文件vim /usr/lib/systemd/system/node_exporter.service[Unit]Description=prometheus[Service]Restart=on-failureExecStart=/usr/local/node_exporter/node_exporter[Install]WantedBy=multi-user.target# 启动node_exportersystemctl daemon-reloadsystemctl start node_exporter.service# 访问node_exporter的数据接口http://10.10.110.23:9100/metrics    # 默认端口是9100,默认接口是metrics<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="配置监控"><a href="#配置监控" class="headerlink" title="配置监控"></a>配置监控</h2><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true"># 修改prometheus配置文件</span>vim /usr/local/prometheus/prometheus.yml  <span class="token punctuation">-</span> <span class="token key atrule">job_name</span><span class="token punctuation">:</span> <span class="token string">'node_exporter'</span>    <span class="token key atrule">file_sd_configs</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">files</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'/usr/local/prometheus/sd_config/node/*.yaml'</span><span class="token punctuation">]</span>        <span class="token key atrule">refresh_interval</span><span class="token punctuation">:</span> 5s<span class="token comment" spellcheck="true"># 创建服务发现的文件</span>vim /usr/local/prometheus/sd_config/node/*.yaml<span class="token punctuation">-</span> <span class="token key atrule">targets</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token string">'10.10.110.23:9100'</span>        <span class="token comment" spellcheck="true"># 这个地址是被监控节点的IP地址</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="promSQL监控CPU、内存、硬盘"><a href="#promSQL监控CPU、内存、硬盘" class="headerlink" title="promSQL监控CPU、内存、硬盘"></a>promSQL监控CPU、内存、硬盘</h1><h2 id="CPU监控"><a href="#CPU监控" class="headerlink" title="CPU监控"></a>CPU监控</h2><pre class="line-numbers language-shell"><code class="language-shell"># 计算CPU五分钟内平均的使用率表达式100 - irate(node_cpu_seconds_total{mode="idle",instance="10.10.110.23:9100",job="node_exporter"}[5m]) * 100# node_cpu_seconds_total{mode="idle",instance="10.10.110.23:9100",job="node_exporter"}[5m]:取CPU五分钟之内的空闲值# irate函数:将会用于计算某个指标在一定时间间隔内的变化速率# 将得到的空闲值乘以100再得到CPU百分比的空闲值,再以100减去CPU百分比的空闲值,就得到CPU五分钟内平均的使用率<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="内存监控"><a href="#内存监控" class="headerlink" title="内存监控"></a>内存监控</h2><pre class="line-numbers language-shell"><code class="language-shell"># 计算内存使用率表达式100 - (node_memory_MemFree_bytes + node_memory_Buffers_bytes + node_memory_Cached_bytes) / node_memory_MemTotal_bytes * 100# (node_memory_MemFree_bytes + node_memory_Buffers_bytes + node_memory_Cached_bytes)是内存剩余的总量    在系统层面来考虑:buff和cache是已经被使用的内存    在程序层面来考虑:buff和cache是剩余的内存# 内存剩余的总量除以内存总量得到内存剩余率,再以100减去内存剩余率得到内存使用率<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="硬盘监控"><a href="#硬盘监控" class="headerlink" title="硬盘监控"></a>硬盘监控</h2><pre class="line-numbers language-shell"><code class="language-shell"># 计算硬盘使用率表达式100 - node_filesystem_free_bytes{mountpoint="/",fstype=~"ext4|xfs"} / node_filesystem_size_bytes{mountpoint="/",fstype=~"ext4|xfs"} * 100# node_filesystem_free_bytes{mountpoint="/",fstype=~"ext4|xfs"}是根分区硬盘剩余容量,只计算ext4|xfs类型的文件系统# node_filesystem_size_bytes{mountpoint="/",fstype=~"ext4|xfs"}是根分区的硬盘总量# 根分区硬盘剩余容量除以根分区的硬盘总量得到根分区硬盘的剩余率,再以100减去硬盘的剩余率得到硬盘使用率<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="监控系统服务状态"><a href="#监控系统服务状态" class="headerlink" title="监控系统服务状态"></a>监控系统服务状态</h1><h2 id="修改node-exporter的启动参数"><a href="#修改node-exporter的启动参数" class="headerlink" title="修改node_exporter的启动参数"></a>修改node_exporter的启动参数</h2><pre class="line-numbers language-shell"><code class="language-shell">vim /usr/lib/systemd/system/node_exporter.service[Unit]Description=prometheus[Service]Restart=on-failureExecStart=/usr/local/node_exporter/node_exporter --collector.systemd --collector.systemd.unit-whitelist=(docker|sshd).service# 利用正则匹配监控systemd的docker|sshd这三个服务[Install]WantedBy=multi-user.target<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="重启node-exporter"><a href="#重启node-exporter" class="headerlink" title="重启node_exporter"></a>重启node_exporter</h2><pre class="line-numbers language-shell"><code class="language-shell">systemctl daemon-reloadsystemctl restart node_exporter.service<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="查看监控服务的数据指标"><a href="#查看监控服务的数据指标" class="headerlink" title="查看监控服务的数据指标"></a>查看监控服务的数据指标</h2><pre class="line-numbers language-shell"><code class="language-shell">node_systemd_unit_state{name="docker.service"}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在activating、active、deactivating、failed、inactive五个状态中value为1的状态，就是服务当前的状态</p>{% image https://pic.imgdb.cn/item/5f1fa26414195aa5947438c7.jpg '' '' %}<h1 id="使用Grafana图表展示监控数据"><a href="#使用Grafana图表展示监控数据" class="headerlink" title="使用Grafana图表展示监控数据"></a>使用Grafana图表展示监控数据</h1><h2 id="安装Grafana"><a href="#安装Grafana" class="headerlink" title="安装Grafana"></a>安装Grafana</h2><pre class="line-numbers language-shell"><code class="language-shell"># 下载软件包wget https://dl.grafana.com/oss/release/grafana-7.1.0-1.x86_64.rpm# 安装yum install grafana-7.1.0-1.x86_64.rpm -y# 启动systemctl enable grafana-server.servicesystemctl start grafana-server.service# Grafana默认端口为3000,账号密码都为admin,初次登录会提示需要修改密码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Grafana配置数据源"><a href="#Grafana配置数据源" class="headerlink" title="Grafana配置数据源"></a>Grafana配置数据源</h2><p>填写prometheus主机的地址，在配置数据源时我们还可以配置验证、定义HTTP头部、以及其他的一些信息</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://pic.imgdb.cn/item/5f14fccb14195aa59415fa14.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="Grafana导入仪表盘"><a href="#Grafana导入仪表盘" class="headerlink" title="Grafana导入仪表盘"></a>Grafana导入仪表盘</h2><p>我们可以自己编写仪表盘，也可以使用官方网站上别人已经写好的仪表盘模板直接导入使用，这里我们没有必要自己去编写(重复造轮子而且还没有人家专业…)。我们先去<a href="https://grafana.com/grafana/dashboards" target="_blank" rel="noopener">Grafana Labs</a>上找到监控Linux主机的仪表盘，然后将仪表盘的ID号导入到Grafana</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://pic.imgdb.cn/item/5f1515d514195aa5941cc06f.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="查看仪表盘"><a href="#查看仪表盘" class="headerlink" title="查看仪表盘"></a>查看仪表盘</h2><p>Grafana监控Linux主机的仪表盘数据是从prometheus的数据源获取的，就是被监控主机上的node_exporter获取到的数据</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://pic.imgdb.cn/item/5f1518a914195aa5941d6c7f.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="监控Docker服务器"><a href="#监控Docker服务器" class="headerlink" title="监控Docker服务器"></a>监控Docker服务器</h1><h2 id="部署cadvisor"><a href="#部署cadvisor" class="headerlink" title="部署cadvisor"></a>部署cadvisor</h2><p>想要监控Docker容器，需要在被监控主机安装cadvisor插件，暴露一个HTTP端口，为prometheus提供容器的监控数据</p><pre class="line-numbers language-shell"><code class="language-shell"># 由于国内无法连接到gcr.io,这里使用张馆长仓库的镜像地址docker run \--volume=/:/rootfs:ro \--volume=/var/run:/var/run:ro \--volume=/sys:/sys:ro \--volume=/var/lib/docker/:/var/lib/docker:ro \--volume=/dev/disk/:/dev/disk:ro \--publish=8080:8080 \--detach=true \--name=cadvisor \--privileged \--device=/dev/kmsg \registry.aliyuncs.com/k8sxio/cadvisor:latest<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="配置Prometheus监控cadvisor"><a href="#配置Prometheus监控cadvisor" class="headerlink" title="配置Prometheus监控cadvisor"></a>配置Prometheus监控cadvisor</h2><p>cadvisor可以搜集一台机器上所有运行的容器信息，还提供基础查询界面和http接口，供其他组件如prometheus拉取数据</p><pre class="line-numbers language-shell"><code class="language-shell">vim /usr/local/prometheus/prometheus.yml    # 在prometheus配置文件加入监控主机的cadvisor端口(拉取容器数据)  - job_name: 'docker'    static_configs:    - targets: ['10.10.110.23:8080']systemctl daemon-reloadsystemctl restart prometheus.service<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Grafana导入仪表盘-1"><a href="#Grafana导入仪表盘-1" class="headerlink" title="Grafana导入仪表盘"></a>Grafana导入仪表盘</h2><p>我们去<a href="https://grafana.com/grafana/dashboards" target="_blank" rel="noopener">Grafana Labs</a>网站寻找一个监控Docker主机的仪表盘，在Grafana进行导入</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://pic.imgdb.cn/item/5f23b7c914195aa5948360c4.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="查看Docker主机仪表盘"><a href="#查看Docker主机仪表盘" class="headerlink" title="查看Docker主机仪表盘"></a>查看Docker主机仪表盘</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://pic.imgdb.cn/item/5f17260614195aa59400404d.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="监控MySQL服务器"><a href="#监控MySQL服务器" class="headerlink" title="监控MySQL服务器"></a>监控MySQL服务器</h1><p>监控MySQL主机和监控Linux主机一样，都是需要导出器去获取数据，这里我们去prometheus官网下载mysqld_exporter，然后在mysql主机上安装(监控那台mysql主机就在那台主机安装mysqld_exporter)</p><h2 id="MySQL主机安装mysqld-exporter"><a href="#MySQL主机安装mysqld-exporter" class="headerlink" title="MySQL主机安装mysqld_exporter"></a>MySQL主机安装mysqld_exporter</h2><pre class="line-numbers language-shell"><code class="language-shell"># 下载wget https://github.com/prometheus/mysqld_exporter/releases/download/v0.12.1/mysqld_exporter-0.12.1.linux-amd64.tar.gz# 解压tar xf mysqld_exporter-0.12.1.linux-amd64.tar.gz && mv mysqld_exporter-0.12.1.linux-amd64 /usr/local/mysqld_exporter# 创建启动文件vim /usr/lib/systemd/system/mysqld_exporter.service[Unit]Documentation=https://prometheus.io/[Service]Restart=on-failureEnvironment=DATA_SOURCE_NAME=exporter:Missf.top123@(localhost:3306)/    # 连接数据库的账号密码,也可以指定.my.cnf文件ExecStart=/usr/local/mysqld_exporter/mysqld_exporter[Install]WantedBy=multi-user.target# 被监控数据库添加mysql用户及监控权限CREATE USER 'exporter'@'localhost' IDENTIFIED BY 'Missf.top123' WITH MAX_USER_CONNECTIONS 3;GRANT PROCESS, REPLICATION CLIENT, SELECT ON *.* TO 'exporter'@'localhost';FLUSH PRIVILEGES;# 启动mysqld_exportersystemctl start mysqld_exporter# 获取监控数据curl [IP]:9104/metrics<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="配置Prometheus监控mysqld-exporter"><a href="#配置Prometheus监控mysqld-exporter" class="headerlink" title="配置Prometheus监控mysqld_exporter"></a>配置Prometheus监控mysqld_exporter</h2><pre class="line-numbers language-shell"><code class="language-shell"># 修改配置文件vim /usr/local/prometheus/prometheus.yml  - job_name: 'mysqld_exporter'        # 添加监控mysqld_exporter    static_configs:    - targets: ['47.100.107.121:9104']# 重启systemctl restart prometheus.service<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="导入MySQL仪表盘"><a href="#导入MySQL仪表盘" class="headerlink" title="导入MySQL仪表盘"></a>导入MySQL仪表盘</h2><p>导入ID为7362的MySQL仪表盘，查看MySQL的监控数据</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://pic.imgdb.cn/item/5f18f80f14195aa594e798e0.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;监控Linux服务器&quot;&gt;&lt;a href=&quot;#监控Linux服务器&quot; class=&quot;headerlink&quot; title=&quot;监控Linux服务器&quot;&gt;&lt;/a&gt;监控Linux服务器&lt;/h1&gt;&lt;h2 id=&quot;部署node-exporter&quot;&gt;&lt;a href=&quot;#部署node
      
    
    </summary>
    
    
      <category term="Prometheus" scheme="https://www.missf.top/categories/Prometheus/"/>
    
    
      <category term="云计算" scheme="https://www.missf.top/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
      <category term="Prometheus" scheme="https://www.missf.top/tags/Prometheus/"/>
    
      <category term="监控" scheme="https://www.missf.top/tags/%E7%9B%91%E6%8E%A7/"/>
    
  </entry>
  
  <entry>
    <title>Prometheus配置文件与核心功能(4)</title>
    <link href="https://www.missf.top/post/521f1005.html"/>
    <id>https://www.missf.top/post/521f1005.html</id>
    <published>2020-07-15T11:06:15.000Z</published>
    <updated>2020-07-29T08:44:20.583Z</updated>
    
    <content type="html"><![CDATA[<h1 id="全局配置文件介绍"><a href="#全局配置文件介绍" class="headerlink" title="全局配置文件介绍"></a>全局配置文件介绍</h1><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">global</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># 全局默认的数据拉取间隔,默认每隔1m拉取一次监控数据</span>  <span class="token punctuation">[</span> <span class="token key atrule">scrape_interval</span><span class="token punctuation">:</span> &lt;duration<span class="token punctuation">></span> <span class="token punctuation">|</span> default = 1m <span class="token punctuation">]</span>  <span class="token comment" spellcheck="true"># 全局默认的单次数据拉取超时</span>  <span class="token punctuation">[</span> <span class="token key atrule">scrape_timeout</span><span class="token punctuation">:</span> &lt;duration<span class="token punctuation">></span> <span class="token punctuation">|</span> default = 10s <span class="token punctuation">]</span>  <span class="token comment" spellcheck="true"># 对告警规则做定期计算的间隔时间,每隔1m对比一次我采集到的数据跟我设置的告警规则,符合告警规则的事件就会被发送到alertmanager,由alertmanager做路由匹配然后进行告警处理</span>  <span class="token punctuation">[</span> <span class="token key atrule">evaluation_interval</span><span class="token punctuation">:</span> &lt;duration<span class="token punctuation">></span> <span class="token punctuation">|</span> default = 1m <span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 监控告警的规则设置</span><span class="token key atrule">rule_files</span><span class="token punctuation">:</span>  <span class="token punctuation">[</span> <span class="token punctuation">-</span> &lt;filepath_glob<span class="token punctuation">></span> <span class="token punctuation">...</span> <span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 配置被监控指标</span><span class="token key atrule">scrape_configs</span><span class="token punctuation">:</span>  <span class="token punctuation">[</span> <span class="token punctuation">-</span> &lt;scrape_config<span class="token punctuation">></span> <span class="token punctuation">...</span> <span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 指定告警和告警管理器相关的设置</span><span class="token key atrule">alerting</span><span class="token punctuation">:</span>  <span class="token key atrule">alert_relabel_configs</span><span class="token punctuation">:</span>    <span class="token punctuation">[</span> <span class="token punctuation">-</span> &lt;relabel_config<span class="token punctuation">></span> <span class="token punctuation">...</span> <span class="token punctuation">]</span>  <span class="token key atrule">alertmanagers</span><span class="token punctuation">:</span>    <span class="token punctuation">[</span> <span class="token punctuation">-</span> &lt;alertmanager_config<span class="token punctuation">></span> <span class="token punctuation">...</span> <span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="scrape-configs"><a href="#scrape-configs" class="headerlink" title="scrape_configs"></a>scrape_configs</h1><p>配置数据源，拉取数据的对象称为Targets，每个Targets用job_name命名，添加数据源又分为静态配置和服务发现</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true"># 定义job名称,是一个拉取单元,每个job_name都会自动引入默认配置如:</span>    <span class="token comment" spellcheck="true"># scrape_interval 依赖全局配置</span>    <span class="token comment" spellcheck="true"># scrape_timeout 依赖全局配置</span>    <span class="token comment" spellcheck="true"># metrics_path 默认为'/metrics'</span>    <span class="token comment" spellcheck="true"># scheme 默认为'http'</span><span class="token key atrule">job_name</span><span class="token punctuation">:</span> &lt;job_name<span class="token punctuation">></span><span class="token comment" spellcheck="true"># 数据拉取间隔</span><span class="token punctuation">[</span> <span class="token key atrule">scrape_interval</span><span class="token punctuation">:</span> &lt;duration<span class="token punctuation">></span> <span class="token punctuation">|</span> default = &lt;global_config.scrape_interval<span class="token punctuation">></span> <span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 数据拉取超时时间</span><span class="token punctuation">[</span> <span class="token key atrule">scrape_timeout</span><span class="token punctuation">:</span> &lt;duration<span class="token punctuation">></span> <span class="token punctuation">|</span> default = &lt;global_config.scrape_timeout<span class="token punctuation">></span> <span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 拉取数据指标的地址</span><span class="token punctuation">[</span> <span class="token key atrule">metrics_path</span><span class="token punctuation">:</span> &lt;path<span class="token punctuation">></span> <span class="token punctuation">|</span> default = /metrics <span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="基于文件的服务发现"><a href="#基于文件的服务发现" class="headerlink" title="基于文件的服务发现"></a>基于文件的服务发现</h1><p>基于文件的服务发现不需要依赖其他平台与第三方服务，用户只需将要更新的target信息以yaml或json文件格式添加到target文件中，prometheus会定期的从指定文件中读取target信息并更新。给我们带来的好处就是不需要一个个target去添加，只需要一个yaml或者json文件，便于管理</p><h2 id="编写配置文件"><a href="#编写配置文件" class="headerlink" title="编写配置文件"></a>编写配置文件</h2><pre class="line-numbers language-yaml"><code class="language-yaml">vim prometheus.yml<span class="token comment" spellcheck="true"># my global config 全局配置文件</span><span class="token key atrule">global</span><span class="token punctuation">:</span>  <span class="token key atrule">scrape_interval</span><span class="token punctuation">:</span>     5s <span class="token comment" spellcheck="true"># Set the scrape interval to every 15 seconds. Default is every 1 minute.</span>  <span class="token key atrule">evaluation_interval</span><span class="token punctuation">:</span> 15s <span class="token comment" spellcheck="true"># Evaluate rules every 15 seconds. The default is every 1 minute.</span>  <span class="token comment" spellcheck="true"># scrape_timeout is set to the global default (10s).</span><span class="token comment" spellcheck="true"># Alertmanager configuration 告警管理</span><span class="token key atrule">alerting</span><span class="token punctuation">:</span>  <span class="token key atrule">alertmanagers</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">static_configs</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">targets</span><span class="token punctuation">:</span>      <span class="token comment" spellcheck="true"># - alertmanager:9093</span><span class="token comment" spellcheck="true"># Load rules once and periodically evaluate them according to the global 'evaluation_interval'.</span><span class="token key atrule">rule_files</span><span class="token punctuation">:</span>      <span class="token comment" spellcheck="true"># - "first_rules.yml"</span>  <span class="token comment" spellcheck="true"># - "second_rules.yml"</span><span class="token comment" spellcheck="true"># A scrape configuration containing exactly one endpoint to scrape:</span><span class="token comment" spellcheck="true"># Here it's Prometheus itself.</span><span class="token key atrule">scrape_configs</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># The job name is added as a label `job=&lt;job_name>` to any timeseries scraped from this config.</span>  <span class="token punctuation">-</span> <span class="token key atrule">job_name</span><span class="token punctuation">:</span> <span class="token string">'prometheus'</span>    <span class="token comment" spellcheck="true"># metrics_path defaults to '/metrics'</span>    <span class="token comment" spellcheck="true"># scheme defaults to 'http'.</span><span class="token comment" spellcheck="true">#    scrape_interval: 5s</span><span class="token comment" spellcheck="true">#    static_configs:</span><span class="token comment" spellcheck="true">#    - targets: ['localhost:9090']</span>    <span class="token key atrule">file_sd_configs</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 文件服务发现</span>      <span class="token punctuation">-</span> <span class="token key atrule">files</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'/usr/local/prometheus/sd_config/*.yaml'</span><span class="token punctuation">]</span>    <span class="token comment" spellcheck="true"># 指定服务发现的文件路径</span>        <span class="token key atrule">refresh_interval</span><span class="token punctuation">:</span> 5s    <span class="token comment" spellcheck="true"># 每过5秒动态发现服务配置</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="创建目录及文件"><a href="#创建目录及文件" class="headerlink" title="创建目录及文件"></a>创建目录及文件</h2><pre class="line-numbers language-yaml"><code class="language-yaml">vim /usr/local/prometheus/sd_config/test.yaml    <span class="token comment" spellcheck="true"># 需要监控那一台主机就在那一台主机上创建</span><span class="token punctuation">-</span> <span class="token key atrule">targets</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token string">'10.10.110.150:9090'</span>    <span class="token comment" spellcheck="true"># 这个是填写prometheus主机的地址,如果prometheus启动时监听的是8080端口,那么这里就需要和prometheus端口一致,不然获取不到数据</span>  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">group</span><span class="token punctuation">:</span> prometheus<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="重载配置文件"><a href="#重载配置文件" class="headerlink" title="重载配置文件"></a>重载配置文件</h2><pre class="line-numbers language-shell"><code class="language-shell">ps -ef | grep prometheusroot       1774      1  0 Jul15 ?        00:02:21 /usr/local/prometheus/prometheus --config.file=/usr/local/prometheus/prometheus.ymlroot       2741   1702  0 14:13 pts/1    00:00:00 grep --color=auto prometheuskill -hup 1774<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;全局配置文件介绍&quot;&gt;&lt;a href=&quot;#全局配置文件介绍&quot; class=&quot;headerlink&quot; title=&quot;全局配置文件介绍&quot;&gt;&lt;/a&gt;全局配置文件介绍&lt;/h1&gt;&lt;pre class=&quot;line-numbers language-yaml&quot;&gt;&lt;code cla
      
    
    </summary>
    
    
      <category term="Prometheus" scheme="https://www.missf.top/categories/Prometheus/"/>
    
    
      <category term="云计算" scheme="https://www.missf.top/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
      <category term="Prometheus" scheme="https://www.missf.top/tags/Prometheus/"/>
    
      <category term="监控" scheme="https://www.missf.top/tags/%E7%9B%91%E6%8E%A7/"/>
    
  </entry>
  
  <entry>
    <title>Prometheus部署(3)</title>
    <link href="https://www.missf.top/post/d26dfcbe.html"/>
    <id>https://www.missf.top/post/d26dfcbe.html</id>
    <published>2020-07-15T09:11:11.000Z</published>
    <updated>2020-07-28T08:52:16.948Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二进制部署"><a href="#二进制部署" class="headerlink" title="二进制部署"></a>二进制部署</h1><pre class="line-numbers language-shell"><code class="language-shell"># 下载二进制安装包wget https://github.com/prometheus/prometheus/releases/download/v2.19.2/prometheus-2.19.2.linux-amd64.tar.gz# 解压tar xf prometheus-2.19.2.linux-amd64.tar.gz && mv prometheus-2.19.2.linux-amd64 /usr/local/prometheus# 创建启动文件cp /usr/lib/systemd/system/sshd.service /usr/lib/systemd/system/prometheus.service# 编写启动文件tee /usr/lib/systemd/system/prometheus.service << EOF[Unit]Description=http://prometheus.io[Service]Restart=on-failureExecStart=/usr/local/prometheus/prometheus --config.file=/usr/local/prometheus/prometheus.yml[Install]WantedBy=multi-user.targetEOF# 启动prometheussystemctl daemon-reloadsystemctl restart prometheus.service<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h2><pre class="line-numbers language-yaml"><code class="language-yaml">vim /usr/local/prometheus/prometheus<span class="token comment" spellcheck="true"># my global config</span><span class="token key atrule">global</span><span class="token punctuation">:</span>  <span class="token key atrule">scrape_interval</span><span class="token punctuation">:</span>     5s <span class="token comment" spellcheck="true"># Set the scrape interval to every 15 seconds. Default is every 1 minute.</span>  <span class="token key atrule">evaluation_interval</span><span class="token punctuation">:</span> 15s <span class="token comment" spellcheck="true"># Evaluate rules every 15 seconds. The default is every 1 minute.</span>  <span class="token comment" spellcheck="true"># scrape_timeout is set to the global default (10s).</span><span class="token comment" spellcheck="true"># Alertmanager configuration</span><span class="token key atrule">alerting</span><span class="token punctuation">:</span>  <span class="token key atrule">alertmanagers</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">static_configs</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">targets</span><span class="token punctuation">:</span>      <span class="token comment" spellcheck="true"># - alertmanager:9093</span><span class="token comment" spellcheck="true"># Load rules once and periodically evaluate them according to the global 'evaluation_interval'.</span><span class="token key atrule">rule_files</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># - "first_rules.yml"</span>  <span class="token comment" spellcheck="true"># - "second_rules.yml"</span><span class="token comment" spellcheck="true"># A scrape configuration containing exactly one endpoint to scrape:</span><span class="token comment" spellcheck="true"># Here it's Prometheus itself.</span><span class="token key atrule">scrape_configs</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># The job name is added as a label `job=&lt;job_name>` to any timeseries scraped from this config.</span>  <span class="token punctuation">-</span> <span class="token key atrule">job_name</span><span class="token punctuation">:</span> <span class="token string">'prometheus'</span>    <span class="token comment" spellcheck="true"># metrics_path defaults to '/metrics'</span>    <span class="token comment" spellcheck="true"># scheme defaults to 'http'.</span>    <span class="token key atrule">static_configs</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">targets</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'127.0.0.1:9090'</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Docker部署"><a href="#Docker部署" class="headerlink" title="Docker部署"></a>Docker部署</h1><pre class="line-numbers language-shell"><code class="language-shell">docker run -d --name "prometheus" -p 9090:9090 \--mount src=prometheus,dst=/etc/prometheus \--mount type=bind,src=/prometheus/prometheus.yml,dst=/etc/prometheus/prometheus.yml prom/prometheus<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h1 id="启动常用命令行参数"><a href="#启动常用命令行参数" class="headerlink" title="启动常用命令行参数"></a>启动常用命令行参数</h1><pre class="line-numbers language-shell"><code class="language-shell">./prometheus -h--config.file="prometheus.yml"    # 指定配置文件--web.listen-address="0.0.0.0:9090"        # 指定端口--log.level=info    # 指定日志级别<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;二进制部署&quot;&gt;&lt;a href=&quot;#二进制部署&quot; class=&quot;headerlink&quot; title=&quot;二进制部署&quot;&gt;&lt;/a&gt;二进制部署&lt;/h1&gt;&lt;pre class=&quot;line-numbers language-shell&quot;&gt;&lt;code class=&quot;languag
      
    
    </summary>
    
    
      <category term="Prometheus" scheme="https://www.missf.top/categories/Prometheus/"/>
    
    
      <category term="云计算" scheme="https://www.missf.top/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
      <category term="Prometheus" scheme="https://www.missf.top/tags/Prometheus/"/>
    
      <category term="监控" scheme="https://www.missf.top/tags/%E7%9B%91%E6%8E%A7/"/>
    
  </entry>
  
  <entry>
    <title>Prometheus概述(2)</title>
    <link href="https://www.missf.top/post/ef0b21f0.html"/>
    <id>https://www.missf.top/post/ef0b21f0.html</id>
    <published>2020-07-14T06:48:33.000Z</published>
    <updated>2020-07-28T08:32:28.730Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Prometheus简介"><a href="#Prometheus简介" class="headerlink" title="Prometheus简介"></a>Prometheus简介</h1><p>Prometheus(普罗米修斯)是一个最初在SoundCloud上构建的监控系统。自2012年成为社区开源项目，拥有非常活跃的开发人员和用户社区。为强调开源及独立维护，Prometheus于2016年加入云原生云计算基金会(CNCF)，成为继Kubernetes之后的第二个托管项目</p><p>可能有些运维小伙伴不知道Prometheus，但是你们一定用过zabbix。现在由于Docker和Kubernetes的兴起，zabbix渐渐的失去了监控的优势，现在Prometheus是用来监控容器的最好实现，只有用到Docker和Kubernetes就离不开Prometheus提供监控支持。以前刚接触zabbix时，配置的微信告警让我开心了一整天，那时候觉得zabbix是世界上最好的监控软件，但是现在却觉得Prometheus才是。可能人总是需要不断向前看、不断向前奔跑的吧！</p><p><a href="https://prometheus.io/" target="_blank" rel="noopener">prometheus官网</a></p><h1 id="Prometheus特点"><a href="#Prometheus特点" class="headerlink" title="Prometheus特点"></a>Prometheus特点</h1><ol><li>多维数据模型(由时序列数据metric和一组key/value组成)</li><li>使用多维度数据完成复杂的语言查询，为prometheus的后期发展奠定基础(PromSQL)</li><li>不依赖分布式存储，单个服务器节点可直接工作</li><li>通过pushgateway进行时序列数据推送(pushing)</li><li>可以通过服务发现或者静态配置去获取要采集的目标服务器</li><li>多种可视化图表及仪表盘支持</li><li>基于HTTP的pull方式采集时间序列数据</li></ol><h1 id="Prometheus-组成及架构"><a href="#Prometheus-组成及架构" class="headerlink" title="Prometheus 组成及架构"></a>Prometheus 组成及架构</h1><p>Prometheus根据配置定时去拉取各个节点的数据，默认使用的拉取方式是pull，也可以使用pushgateway提供的push方式获取各个监控节点的数据。将获取到的数据存入TSDB(时序型数据库)，此时prometheus已经获取到监控数据，可以使用内置的promSQL进行查询。它的报警功能使用alertmanager提供，alertmanager是prometheus的告警管理和发送报警的一个组件。prometheus原生的图表结构过于简单，prometheus的图表展示功能一般由grafana进行统一管理</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://pic.imgdb.cn/item/5f0d6fde14195aa594d4927d.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="Prometheus数据模型"><a href="#Prometheus数据模型" class="headerlink" title="Prometheus数据模型"></a>Prometheus数据模型</h1><p>Prometheus将所有数据存储为时间序列，具有相同度量名称以及标签属于同一个指标。每个时间序列都由度量标准名称和一组键值对(也成为标签)唯一标识</p><pre class="line-numbers language-shell"><code class="language-shell">#  时间序列格式示例 <metric name>{<label name>=<label value>, ...}api_http_requests_total{method="POST", handler="/messages"}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1 id="Prometheus指标类型"><a href="#Prometheus指标类型" class="headerlink" title="Prometheus指标类型"></a>Prometheus指标类型</h1><p>Counter: 递增的计数器</p><p>Gauge: 可以任意变化的数值</p><p>Histogram: 对一段时间范围内数据进行采样，并对所有数值求和与统计数量</p><p>Summary: 与Histogram类似</p><p>不同的指标类型用于渲染不同的图表</p><h1 id="Prometheus作业和实例"><a href="#Prometheus作业和实例" class="headerlink" title="Prometheus作业和实例"></a>Prometheus作业和实例</h1><p>实例: 可以抓取的目标称为实例(Instances)    </p><p>作业: 具有相同目标的实例集合称为作业(Job)</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">scrape_configs</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">job_name</span><span class="token punctuation">:</span> <span class="token string">'prometheus'</span>    <span class="token comment" spellcheck="true"># prometheus这个job作用于localhost:9090这个目标</span>    <span class="token key atrule">static_configs</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">targets</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'localhost:9090'</span><span class="token punctuation">]</span>  <span class="token punctuation">-</span> <span class="token key atrule">job_name</span><span class="token punctuation">:</span> <span class="token string">'node'</span>    <span class="token comment" spellcheck="true"># node这个job作用于192.168.1.10:9090这个目标</span>    <span class="token key atrule">static_configs</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">targets</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'192.168.1.10:9090'</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Prometheus简介&quot;&gt;&lt;a href=&quot;#Prometheus简介&quot; class=&quot;headerlink&quot; title=&quot;Prometheus简介&quot;&gt;&lt;/a&gt;Prometheus简介&lt;/h1&gt;&lt;p&gt;Prometheus(普罗米修斯)是一个最初在SoundCl
      
    
    </summary>
    
    
      <category term="Prometheus" scheme="https://www.missf.top/categories/Prometheus/"/>
    
    
      <category term="云计算" scheme="https://www.missf.top/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
      <category term="Prometheus" scheme="https://www.missf.top/tags/Prometheus/"/>
    
      <category term="监控" scheme="https://www.missf.top/tags/%E7%9B%91%E6%8E%A7/"/>
    
  </entry>
  
  <entry>
    <title>Prometheus监控的意义(1)</title>
    <link href="https://www.missf.top/post/ded057ed.html"/>
    <id>https://www.missf.top/post/ded057ed.html</id>
    <published>2020-07-13T17:28:39.000Z</published>
    <updated>2020-07-27T09:51:54.387Z</updated>
    
    <content type="html"><![CDATA[<h1 id="监控目的"><a href="#监控目的" class="headerlink" title="监控目的"></a>监控目的</h1><p>监控分为白盒监控和黑盒监控。白盒监控: 通过监控内部的运行状态及指标判断接下来可能会发生的问题，从而做出预判或应对的方法。黑盒监控: 监控系统或服务，在发生异常时做出相应的措施。prometheus属于黑盒监控，是在服务发生异常时，我们通过告警信息得知，才去处理异常问题</p><p>监控的目的主要分为以下方面:</p><ol><li>根据历史监控数据，对未来做出预测</li><li>发生异常时即使告警，或做出相应措施</li><li>根据监控报警及时定位问题根源，记录问题出现的证据(记录网络波动)</li><li>通过可视化图表展示，便于直观获取信息</li><li>领导查看数据图表(PV、UV、订单趋势图)</li><li>运维人员能够提前预知风险，避免故障的产生或者在故障发生时能够迅速处理</li></ol><h1 id="怎么监控"><a href="#怎么监控" class="headerlink" title="怎么监控"></a>怎么监控</h1><p>使用传统监控工具，直接调用Linux系统命令去获取服务状态和信息</p><pre class="line-numbers language-shell"><code class="language-shell"># free # vmstat# df# top# ss# iftop...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用监控系统去监控系统和服务，能够整体监控每一项数据</p><pre class="line-numbers language-shell"><code class="language-shell"># zabbix# nagios# prometheus# open-falcon<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h1 id="监控流程"><a href="#监控流程" class="headerlink" title="监控流程"></a>监控流程</h1><p>监控的大概流程分为:数据采集、数据存储、数据分析、以及展示和告警</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://pic.imgdb.cn/item/5f0d66c514195aa594d1f578.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="监控什么"><a href="#监控什么" class="headerlink" title="监控什么"></a>监控什么</h1><table><thead><tr><th>监控类型</th><th>具体参数</th></tr></thead><tbody><tr><td>硬件监控</td><td>硬件参数、温度、故障等</td></tr><tr><td>系统监控</td><td>CPU，内存，硬盘，网卡流量，TCP状态，进程数</td></tr><tr><td>应用监控</td><td>Nginx、Tomcat、PHP、MySQL、Redis等</td></tr><tr><td>日志监控</td><td>系统日志、服务日志、访问日志、错误日志</td></tr><tr><td>安全监控</td><td>WAF，敏感文件监控</td></tr><tr><td>API监控</td><td>可用性，接口请求，响应时间</td></tr><tr><td>业务监控</td><td>例如电商网站，每分钟产生多少订单、注册多少用户、多少活跃用户、推广活动效果</td></tr><tr><td>流量分析</td><td>根据流量获取用户相关信息，例如用户地理位置、某页面访问状况、页面停留时间等</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;监控目的&quot;&gt;&lt;a href=&quot;#监控目的&quot; class=&quot;headerlink&quot; title=&quot;监控目的&quot;&gt;&lt;/a&gt;监控目的&lt;/h1&gt;&lt;p&gt;监控分为白盒监控和黑盒监控。白盒监控: 通过监控内部的运行状态及指标判断接下来可能会发生的问题，从而做出预判或应对的方法。黑
      
    
    </summary>
    
    
      <category term="Prometheus" scheme="https://www.missf.top/categories/Prometheus/"/>
    
    
      <category term="云计算" scheme="https://www.missf.top/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
      <category term="Prometheus" scheme="https://www.missf.top/tags/Prometheus/"/>
    
      <category term="监控" scheme="https://www.missf.top/tags/%E7%9B%91%E6%8E%A7/"/>
    
  </entry>
  
  <entry>
    <title>Docker单机编排利器Docker Compose(9)</title>
    <link href="https://www.missf.top/post/34699079.html"/>
    <id>https://www.missf.top/post/34699079.html</id>
    <published>2020-07-10T06:27:09.000Z</published>
    <updated>2020-07-14T06:45:50.233Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker-Compose-概述"><a href="#Docker-Compose-概述" class="headerlink" title="Docker Compose 概述"></a>Docker Compose 概述</h1><p>Compose是用于定义和运行多容器的工具，通过Compose可以使用YAML文件来配置容器。然后使用一个命令就可以从配置中创建并启动所有服务。其实在刚学习Docker时我就想过，如果我是LNMP架构容器化项目，因为每次都要一个个容器的启动，是否有必要将启停多个容器的命令写成一个shell脚本呢。现在学到Docker Compose，才知道根本没有这个必要，我们现在所有能想到的东西，其实早就有人帮我们实现了。这里不得不敬佩那些为开源项目做出贡献的伟大开发者们</p><p>使用Compose大概分为三个步骤:</p><p>定义Dockerfile，以便可以在任意环境运行</p><p>定义应用程序启动配置文件 docker-compose.yml</p><p>docker-compose启动并管理整个应用程序生命周期</p><h1 id="Linux-安装-Compose"><a href="#Linux-安装-Compose" class="headerlink" title="Linux 安装 Compose"></a>Linux 安装 Compose</h1><p>其实前面我们在学习Harbor时已经安装过docker-compose，这是一个使用python开发的编排工具，国内下载可能会比较慢(你应该知道怎么做了吧…)</p><pre class="line-numbers language-yaml"><code class="language-yaml">curl <span class="token punctuation">-</span>L "https<span class="token punctuation">:</span>//github.com/docker/compose/releases/download/1.26.0/docker<span class="token punctuation">-</span>compose<span class="token punctuation">-</span>$(uname <span class="token punctuation">-</span>s)<span class="token punctuation">-</span>$(uname <span class="token punctuation">-</span>m)"  <span class="token punctuation">-</span>o /usr/bin/docker<span class="token punctuation">-</span>composechmod <span class="token punctuation">,</span>+x ，/usr/bin/docker<span class="token punctuation">-</span>compose ， <span class="token punctuation">,</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1 id="docker-compose-yaml配置文件参数"><a href="#docker-compose-yaml配置文件参数" class="headerlink" title="docker-compose.yaml配置文件参数"></a>docker-compose.yaml配置文件参数</h1><h2 id="build"><a href="#build" class="headerlink" title="build"></a>build</h2><p>使用docker-compose启动容器服务除了可以基于指定的镜像，还可以基于一份Dockerfile，在使用up启动时执行构建镜像的任务，这个构建标签就是build。Compose将会利用它自动构建这个镜像，然后使用这个镜像启动服务容器</p><pre class="line-numbers language-yaml"><code class="language-yaml">version<span class="token punctuation">:</span><span class="token string">"3.7"</span><span class="token key atrule">services</span><span class="token punctuation">:</span>  <span class="token key atrule">web</span><span class="token punctuation">:</span>    context<span class="token punctuation">:</span>./web    dockerfile<span class="token punctuation">:</span>Dockerfile<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="context"><a href="#context" class="headerlink" title="context"></a>context</h2><p>context选项可以是Dockerfile的文件路径，也可以是到链接到git仓库的url。当提供的值是相对路径时，它被解析为相对于撰写文件的路径，此目录也是发送到Docker守护进程的context</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">build</span><span class="token punctuation">:</span>  context<span class="token punctuation">:</span>./dir<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="dockerfile"><a href="#dockerfile" class="headerlink" title="dockerfile"></a>dockerfile</h2><p>使用此dockerfile文件来构建，必须使用context指定构建路径</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">build</span><span class="token punctuation">:</span>  context<span class="token punctuation">:</span>.    <span class="token comment" spellcheck="true"># 知道dockerfile必须要有构建路径,.表示当前路径</span>  dockerfile<span class="token punctuation">:</span>Dockerfile<span class="token punctuation">-</span>alternate<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="image"><a href="#image" class="headerlink" title="image"></a>image</h2><p>指定docker-compose启动容器服务的镜像，可以是存储仓库、标签以及镜像ID，如果镜像不存在，Compose会自动拉去镜像</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">image</span><span class="token punctuation">:</span> redis<span class="token key atrule">image</span><span class="token punctuation">:</span> ubuntu<span class="token punctuation">:</span><span class="token number">14.04</span><span class="token key atrule">image</span><span class="token punctuation">:</span> tutum/influxdb<span class="token key atrule">image</span><span class="token punctuation">:</span> example<span class="token punctuation">-</span>registry.com<span class="token punctuation">:</span>4000/postgresql<span class="token key atrule">image</span><span class="token punctuation">:</span> a4bc65fd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="command"><a href="#command" class="headerlink" title="command"></a>command</h2><p>覆盖容器启动后默认执行的命令</p><pre class="line-numbers language-yaml"><code class="language-yaml">command<span class="token punctuation">:</span>bundle exec thin <span class="token punctuation">-</span>p 3000command<span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token string">"bundle"</span><span class="token punctuation">,</span><span class="token string">"exec"</span><span class="token punctuation">,</span><span class="token string">"thin"</span><span class="token punctuation">,</span><span class="token string">"-p"</span><span class="token punctuation">,</span><span class="token string">"3000"</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="container-name"><a href="#container-name" class="headerlink" title="container_name"></a>container_name</h2><p>指定容器名称，由于容器名称是唯一的，如果指定自定义名称，则无法使用scale</p><pre class="line-numbers language-yaml"><code class="language-yaml">container_name<span class="token punctuation">:</span>my<span class="token punctuation">-</span>web<span class="token punctuation">-</span>container<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="environment"><a href="#environment" class="headerlink" title="environment"></a>environment</h2><p>添加环境变量，可以使用数组或字典。这个标签的作用是设置镜像变量，它可以保存变量到镜像里面，类似ENV指令一样会把变量一直保存在镜像、容器中</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">environment</span><span class="token punctuation">:</span>  RACK_ENV<span class="token punctuation">:</span>development  SHOW<span class="token punctuation">:</span><span class="token string">'true'</span>  <span class="token key atrule">SESSION_SECRET</span><span class="token punctuation">:</span><span class="token key atrule">environment</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span>RACK_ENV=development  <span class="token punctuation">-</span>SHOW=true  <span class="token punctuation">-</span>SESSION_SECRET<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="networks"><a href="#networks" class="headerlink" title="networks"></a>networks</h2><p>加入指定网络</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">networks</span><span class="token punctuation">:</span>   <span class="token punctuation">-</span> lnmp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="ports"><a href="#ports" class="headerlink" title="ports"></a>ports</h2><p>映射端口</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">ports</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span><span class="token string">"3000"</span>  <span class="token punctuation">-</span><span class="token string">"3000-3005"</span>  <span class="token punctuation">-</span><span class="token string">"8000:8000"</span>  <span class="token punctuation">-</span><span class="token string">"9090-9091:8080-8081"</span>  <span class="token punctuation">-</span><span class="token string">"49100:22"</span>  <span class="token punctuation">-</span><span class="token string">"127.0.0.1:8001:8001"</span>  <span class="token punctuation">-</span><span class="token string">"127.0.0.1:5000-5010:5000-5010"</span>        <span class="token comment" spellcheck="true"># 指定IP+端口的话只会监听ipv4的地址</span>  <span class="token punctuation">-</span><span class="token string">"6060:6060/udp"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="expose"><a href="#expose" class="headerlink" title="expose"></a>expose</h2><p>暴露端口，但不映射到宿主机，只被连接的服务访问。这个标签与Dockerfile中的EXPOSE指令一样，用于指定暴露的端口，实际上docker-compose.yml的端口映射还得ports这样的标签</p><h2 id="extra-hosts"><a href="#extra-hosts" class="headerlink" title="extra_hosts"></a>extra_hosts</h2><p>添加主机名的标签，就是往/etc/hosts文件中添加一些记录，与Docker客户端中的–add-host类似</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">extra_hosts</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span><span class="token string">"www.missf.top:124.156.205.241"</span>  <span class="token punctuation">-</span><span class="token string">"mf_missf.gitee.io:212.64.62.174"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="volumes"><a href="#volumes" class="headerlink" title="volumes"></a>volumes</h2><p>挂载一个目录或者一个已存在的数据卷容器</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">volumes</span><span class="token punctuation">:</span>   <span class="token punctuation">-</span> /opt/data<span class="token punctuation">:</span>/var/lib/mysql        <span class="token comment" spellcheck="true"># 挂载宿主机的/opt/data目录到容器的/var/lib/mysql</span>  <span class="token punctuation">-</span> datavolume<span class="token punctuation">:</span>/var/lib/mysq    <span class="token comment" spellcheck="true"># 将容器的/var/lib/mysq挂载到datavolume数据卷</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="restart"><a href="#restart" class="headerlink" title="restart"></a>restart</h2><p>默认值为 no ，即在任何情况下都不会重新启动容器。当值为 always 时，容器总是重新启动。当值为on-failure时，当出现on-failure报错容器退出时，容器重新启动。</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">restart</span><span class="token punctuation">:</span> <span class="token string">"no"</span><span class="token key atrule">restart</span><span class="token punctuation">:</span> always<span class="token key atrule">restart</span><span class="token punctuation">:</span> on<span class="token punctuation">-</span>failure<span class="token key atrule">restart</span><span class="token punctuation">:</span> unless<span class="token punctuation">-</span>stopped<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="hostname"><a href="#hostname" class="headerlink" title="hostname"></a>hostname</h2><p>定义容器主机名</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">hostname</span><span class="token punctuation">:</span> foo<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="Compose-常用选项与命令"><a href="#Compose-常用选项与命令" class="headerlink" title="Compose 常用选项与命令"></a>Compose 常用选项与命令</h1><h2 id="up"><a href="#up" class="headerlink" title="up"></a>up</h2><p>该命令十分强大，它将尝试自动完成包括构建镜像，创建服务，启动服务，并关联服务相关容器的一系列操作</p><p>up选项如下:</p><p>-d: 在后台运行服务容器</p><p>–force-recreate: 强制重新创建容器，不能与–no-recreate同时使用</p><p>–no-recreate: 如果容器已经存在了，则不重新创建，不能与–force-recreate同时使用</p><p>-no-build: 不自动构建缺失的服务镜像</p><p>–no-deps: 不启动服务所链接的容器</p><h2 id="build-1"><a href="#build-1" class="headerlink" title="build"></a>build</h2><p>可以随时在项目目录下运行docker-compose build来重新构建服务</p><p>build选项如下:</p><p>–force-rm: 删除构建过程中的临时容器</p><p>–no-cache: 构建镜像过程中不使用cache(这将加长构建过程)</p><p>–pull: 始终尝试通过pull来获取更新版本的镜像</p><h2 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h2><p>列出项目中目前的所有容器</p><p>ps选项如下:</p><p>-q: 只打印容器的ID信息</p><h2 id="logs"><a href="#logs" class="headerlink" title="logs"></a>logs</h2><p>查看服务容器的输出，默认情况下，docker-compose将对不同的服务输出使用不同的颜色来区分</p><pre class="line-numbers language-shell"><code class="language-shell">docker-compose logs [选项]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h2><p>删除所有(停止状态的)服务容器，推荐先执行docker-compose stop命令来停止容器</p><p>rm选项如下:</p><p>-f/–force: 强制直接删除，包括非停止状态的容器。一般尽量不要使用该选项</p><p>-v: 删除容器所挂载的数据卷</p><h2 id="scale"><a href="#scale" class="headerlink" title="scale"></a>scale</h2><p>设置指定服务运行的容器个数</p><pre class="line-numbers language-shell"><code class="language-shell">docker-compose scale web=3 db=2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="down"><a href="#down" class="headerlink" title="down"></a>down</h2><p>删除容器、网络</p><h2 id="start-stop-restart"><a href="#start-stop-restart" class="headerlink" title="start/stop/restart"></a>start/stop/restart</h2><p>启动/停止/重启服务</p><h1 id="docker-compose编排lnmp容器"><a href="#docker-compose编排lnmp容器" class="headerlink" title="docker-compose编排lnmp容器"></a>docker-compose编排lnmp容器</h1><h2 id="docker-compose目录设计"><a href="#docker-compose目录设计" class="headerlink" title="docker-compose目录设计"></a>docker-compose目录设计</h2><pre class="line-numbers language-shell"><code class="language-shell">tree /docker-compose_lnmp//docker-compose_lnmp/├── docker-compose.yaml├── mysql│   └── start├── nginx│   ├── Dockerfile│   ├── nginx-1.16.1.tar.gz│   ├── nginx.conf│   ├── php.conf│   └── start└── php    ├── Dockerfile    ├── php-7.4.0.tar.gz    ├── php-fpm.conf    ├── php.ini    ├── start    └── www.conf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="docker-compose-yaml"><a href="#docker-compose-yaml" class="headerlink" title="docker-compose.yaml"></a>docker-compose.yaml</h2><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">'3'</span><span class="token key atrule">services</span><span class="token punctuation">:</span>  <span class="token key atrule">php</span><span class="token punctuation">:</span>    <span class="token key atrule">hostname</span><span class="token punctuation">:</span> php    <span class="token key atrule">build</span><span class="token punctuation">:</span>      <span class="token key atrule">context</span><span class="token punctuation">:</span> ./php      <span class="token key atrule">dockerfile</span><span class="token punctuation">:</span> Dockerfile    <span class="token key atrule">networks</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token string">"lnmp"</span>    <span class="token key atrule">volumes</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token string">"nginx:/usr/local/nginx/html"</span>  <span class="token key atrule">nginx</span><span class="token punctuation">:</span>    <span class="token key atrule">hostname</span><span class="token punctuation">:</span> nginx    <span class="token key atrule">build</span><span class="token punctuation">:</span>      <span class="token key atrule">context</span><span class="token punctuation">:</span> ./nginx      <span class="token key atrule">dockerfile</span><span class="token punctuation">:</span> Dockerfile    <span class="token key atrule">ports</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token string">"80:80"</span>      <span class="token punctuation">-</span> <span class="token string">"443:443"</span>    <span class="token key atrule">networks</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token string">"lnmp"</span>    <span class="token key atrule">volumes</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token string">"nginx:/usr/local/nginx/html/"</span>  <span class="token key atrule">mysql</span><span class="token punctuation">:</span>    <span class="token key atrule">hostname</span><span class="token punctuation">:</span> mysql    <span class="token key atrule">image</span><span class="token punctuation">:</span> mysql<span class="token punctuation">:</span><span class="token number">5.7</span>    <span class="token key atrule">ports</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token string">"53306:3306"</span>    <span class="token key atrule">networks</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token string">"lnmp"</span>    <span class="token key atrule">volumes</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token string">"mysql:/var/lib/mysql/"</span>    <span class="token key atrule">command</span><span class="token punctuation">:</span> <span class="token punctuation">-</span><span class="token punctuation">-</span>character<span class="token punctuation">-</span>set<span class="token punctuation">-</span>server=utf8mb4    <span class="token key atrule">environment</span><span class="token punctuation">:</span>      <span class="token key atrule">MYSQL_ROOT_PASSWORD</span><span class="token punctuation">:</span> mwj123456      <span class="token key atrule">MYSQL_DATABASE</span><span class="token punctuation">:</span> wordpress<span class="token key atrule">networks</span><span class="token punctuation">:</span>  <span class="token key atrule">lnmp</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token key atrule">volumes</span><span class="token punctuation">:</span>  <span class="token key atrule">nginx</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token comment" spellcheck="true"># 把php代码放到这个数据卷的目录下</span>  <span class="token key atrule">mysql</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="docker-compose编排nginx反向代理tomcat集群"><a href="#docker-compose编排nginx反向代理tomcat集群" class="headerlink" title="docker-compose编排nginx反向代理tomcat集群"></a>docker-compose编排nginx反向代理tomcat集群</h1><h2 id="docker-compose目录设计-1"><a href="#docker-compose目录设计-1" class="headerlink" title="docker-compose目录设计"></a>docker-compose目录设计</h2><pre class="line-numbers language-shell"><code class="language-shell">tree /docker-compose_lnmt//docker-compose_lnmt/├── docker-compose.yaml├── nginx│   ├── Dockerfile│   ├── nginx-1.16.1.tar.gz│   ├── nginx.conf│   ├── start│   └── tomcat.conf└── tomcat    ├── apache-tomcat-8.5.57.tar.gz    ├── Dockerfile    ├── jdk-8u211-linux-x64.tar.gz    └── start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="docker-compose-yaml-1"><a href="#docker-compose-yaml-1" class="headerlink" title="docker-compose.yaml"></a>docker-compose.yaml</h2><pre class="line-numbers language-yaml"><code class="language-yaml">cat docker<span class="token punctuation">-</span>compose.yaml <span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">'3'</span><span class="token key atrule">services</span><span class="token punctuation">:</span>  <span class="token key atrule">nginx</span><span class="token punctuation">:</span>    <span class="token key atrule">hostname</span><span class="token punctuation">:</span> nginx    <span class="token key atrule">build</span><span class="token punctuation">:</span>      <span class="token key atrule">context</span><span class="token punctuation">:</span> ./nginx      <span class="token key atrule">dockerfile</span><span class="token punctuation">:</span> Dockerfile    <span class="token key atrule">ports</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token string">"80:80"</span>      <span class="token punctuation">-</span> <span class="token string">"443:443"</span>    <span class="token key atrule">networks</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token string">"lnmt"</span>    <span class="token key atrule">volumes</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token string">"webapps:/usr/local/tomcat/webapps/"</span>  <span class="token key atrule">tomcat1</span><span class="token punctuation">:</span>    <span class="token key atrule">hostname</span><span class="token punctuation">:</span> tomcat1    <span class="token key atrule">build</span><span class="token punctuation">:</span>      <span class="token key atrule">context</span><span class="token punctuation">:</span> ./tomcat      <span class="token key atrule">dockerfile</span><span class="token punctuation">:</span> Dockerfile    <span class="token key atrule">networks</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token string">"lnmt"</span>    <span class="token key atrule">volumes</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token string">"webapps:/usr/local/tomcat/webapps/"</span>  <span class="token key atrule">tomcat2</span><span class="token punctuation">:</span>    <span class="token key atrule">hostname</span><span class="token punctuation">:</span> tomcat2    <span class="token key atrule">build</span><span class="token punctuation">:</span>      <span class="token key atrule">context</span><span class="token punctuation">:</span> ./tomcat      <span class="token key atrule">dockerfile</span><span class="token punctuation">:</span> Dockerfile    <span class="token key atrule">networks</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token string">"lnmt"</span>    <span class="token key atrule">volumes</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token string">"webapps:/usr/local/tomcat/webapps/"</span>  <span class="token key atrule">tomcat3</span><span class="token punctuation">:</span>    <span class="token key atrule">hostname</span><span class="token punctuation">:</span> tomcat3    <span class="token key atrule">build</span><span class="token punctuation">:</span>      <span class="token key atrule">context</span><span class="token punctuation">:</span> ./tomcat      <span class="token key atrule">dockerfile</span><span class="token punctuation">:</span> Dockerfile    <span class="token key atrule">networks</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token string">"lnmt"</span>    <span class="token key atrule">volumes</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token string">"webapps:/usr/local/tomcat/webapps/"</span>  <span class="token key atrule">mysql</span><span class="token punctuation">:</span>    <span class="token key atrule">hostname</span><span class="token punctuation">:</span> mysql    <span class="token key atrule">image</span><span class="token punctuation">:</span> mysql<span class="token punctuation">:</span><span class="token number">5.7</span>    <span class="token key atrule">ports</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token string">"53306:3306"</span>    <span class="token key atrule">networks</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token string">"lnmt"</span>    <span class="token key atrule">volumes</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token string">"mysql:/var/lib/mysql/"</span>    <span class="token key atrule">command</span><span class="token punctuation">:</span> <span class="token punctuation">-</span><span class="token punctuation">-</span>character<span class="token punctuation">-</span>set<span class="token punctuation">-</span>server=utf8mb4    <span class="token key atrule">environment</span><span class="token punctuation">:</span>      <span class="token key atrule">MYSQL_ROOT_PASSWORD</span><span class="token punctuation">:</span> mwj123456      <span class="token key atrule">MYSQL_DATABASE</span><span class="token punctuation">:</span> test<span class="token key atrule">volumes</span><span class="token punctuation">:</span>  <span class="token key atrule">webapps</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true"># 把war包放到这个数据卷的目录下,就会自动解压</span>  <span class="token key atrule">mysql</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token key atrule">networks</span><span class="token punctuation">:</span>  <span class="token key atrule">lnmt</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="监听Nginx容器访问日志"><a href="#监听Nginx容器访问日志" class="headerlink" title="监听Nginx容器访问日志"></a>监听Nginx容器访问日志</h2><pre class="line-numbers language-shell"><code class="language-shell">tail -f /usr/local/nginx/logs/access.log     # 点击浏览器刷新页面,可以看到upstream_addr的IP变化,这样就实现了反向代理Tomcat集群{"@timestamp": "2020-07-14T08:03:19+08:00", "clientRealIp": "10.10.110.1", "scheme": "http", "method": "GET", "host": "10.10.110.150", "url": "/", "size": 1056, "referrer": "-", "agent": "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.163 Safari/537.36", "upstream_addr": "192.168.16.3:8080", "request_time": 0.323, "request_length": 450, "upstream_connect_time": "0.003", "upstream_response_time": "0.324", "upstream_status": "200", "status": "200"}{"@timestamp": "2020-07-14T08:03:28+08:00", "clientRealIp": "10.10.110.1", "scheme": "http", "method": "GET", "host": "10.10.110.150", "url": "/", "size": 1056, "referrer": "-", "agent": "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.163 Safari/537.36", "upstream_addr": "192.168.16.6:8080", "request_time": 0.345, "request_length": 450, "upstream_connect_time": "0.000", "upstream_response_time": "0.345", "upstream_status": "200", "status": "200"}{"@timestamp": "2020-07-14T08:03:29+08:00", "clientRealIp": "10.10.110.1", "scheme": "http", "method": "GET", "host": "10.10.110.150", "url": "/", "size": 1056, "referrer": "-", "agent": "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.163 Safari/537.36", "upstream_addr": "192.168.16.4:8080", "request_time": 0.355, "request_length": 450, "upstream_connect_time": "0.000", "upstream_response_time": "0.354", "upstream_status": "200", "status": "200"}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Docker-Compose-概述&quot;&gt;&lt;a href=&quot;#Docker-Compose-概述&quot; class=&quot;headerlink&quot; title=&quot;Docker Compose 概述&quot;&gt;&lt;/a&gt;Docker Compose 概述&lt;/h1&gt;&lt;p&gt;Compose是用于
      
    
    </summary>
    
    
      <category term="Docker" scheme="https://www.missf.top/categories/Docker/"/>
    
    
      <category term="Docker" scheme="https://www.missf.top/tags/Docker/"/>
    
      <category term="容器技术" scheme="https://www.missf.top/tags/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/"/>
    
      <category term="云计算" scheme="https://www.missf.top/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>Docker图形化页面管理(8)</title>
    <link href="https://www.missf.top/post/92368be2.html"/>
    <id>https://www.missf.top/post/92368be2.html</id>
    <published>2020-07-10T02:03:55.000Z</published>
    <updated>2020-07-14T01:21:39.041Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker图形化页面管理"><a href="#Docker图形化页面管理" class="headerlink" title="Docker图形化页面管理"></a>Docker图形化页面管理</h1><h2 id="Portainer概述"><a href="#Portainer概述" class="headerlink" title="Portainer概述"></a>Portainer概述</h2><p>Portainer是Docker的图形化管理工具，portainer通过连接/var/run/docker.sock文件去管理容器，可让你轻松管理不同的Docker环境(Docker主机或Swarm群集)。Portainer提供状态显示面板、应用模板快速部署、容器镜像网络数据卷、事件日志显示、容器控制台操作、登录用户管理和控制等功能。Docker图形化管理界面有很多实现的工具，但生态一直不温不火，这是由于Docker的很多操作都是直接在命令行进行，再加上Docker的操作也比较简单。一般这样的图形化管理平台都是交给开发和测试人员去使用的</p><h2 id="Portainer安装"><a href="#Portainer安装" class="headerlink" title="Portainer安装"></a>Portainer安装</h2><pre class="line-numbers language-shell"><code class="language-shell">docker run -d -p 8000:8000 -p 9000:9000 --name "portainer" --restart=always \-v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer    # 这里portainer通过连接/var/run/docker.sock文件去管理容器,所以需要把宿主机的docker.sock文件挂载到portainer<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="登录Portainer页面"><a href="#登录Portainer页面" class="headerlink" title="登录Portainer页面"></a>登录Portainer页面</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://pic.imgdb.cn/item/5f07e05614195aa594bd5076.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="Portainer连接容器的方式"><a href="#Portainer连接容器的方式" class="headerlink" title="Portainer连接容器的方式"></a>Portainer连接容器的方式</h2><p>Local:管理Portainer所在主机上的Docker主机，需要将宿主机的docker.sock文件挂载到Portainer容器内</p><p>Remote:管理远程主机上的Docker主机，但是要开启远程的Docker主机的Docker API，允许Portainer通过TCP连接</p><p>Agent:直接连接到在Swarm集群中运行的Portainer代理</p><p>Azure:连接到Microsoft Azure</p><p>这里我们先使用Local的方式连接到Portainer所在的主机</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://pic.imgdb.cn/item/5f07e0c714195aa594bd6b94.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="Portainer管理界面"><a href="#Portainer管理界面" class="headerlink" title="Portainer管理界面"></a>Portainer管理界面</h2><p>通过下图可以看到Portainer提供了对容器、镜像、网络、数据卷、变量、主机的操作，App templates是一些供我们下载的公共镜像，我们还可以看到正在运行的容器状态、日志、基于镜像、创建时间、映射端口等</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://pic.imgdb.cn/item/5f07e77714195aa594bf164b.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="Portainer连接远程Docker主机"><a href="#Portainer连接远程Docker主机" class="headerlink" title="Portainer连接远程Docker主机"></a>Portainer连接远程Docker主机</h2><p>首先需要在远程Docker主机上开启Docker API</p><pre class="line-numbers language-shell"><code class="language-shell">vim /usr/lib/systemd/system/docker.serviceExecStart=/usr/bin/dockerd -H tcp://0.0.0.0:2375    # 表示所有地址都能连接到Docker API,也可以指定IP连接,默认端口是2375systemctl daemon-reloadsystemctl restart docker.service<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>然后在Portainer再创建一个连接远程Docker主机API的节点</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://pic.imgdb.cn/item/5f08078d14195aa594c7af99.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>这时候我们可以使用Portainer去管理本地和远程主机上的Docker资源了</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://pic.imgdb.cn/item/5f0807e114195aa594c7cc1f.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Docker图形化页面管理&quot;&gt;&lt;a href=&quot;#Docker图形化页面管理&quot; class=&quot;headerlink&quot; title=&quot;Docker图形化页面管理&quot;&gt;&lt;/a&gt;Docker图形化页面管理&lt;/h1&gt;&lt;h2 id=&quot;Portainer概述&quot;&gt;&lt;a href=
      
    
    </summary>
    
    
      <category term="Docker" scheme="https://www.missf.top/categories/Docker/"/>
    
    
      <category term="Docker" scheme="https://www.missf.top/tags/Docker/"/>
    
      <category term="容器技术" scheme="https://www.missf.top/tags/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/"/>
    
      <category term="云计算" scheme="https://www.missf.top/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>Docker企业级镜像仓库Harbor(7)</title>
    <link href="https://www.missf.top/post/d46af348.html"/>
    <id>https://www.missf.top/post/d46af348.html</id>
    <published>2020-07-08T05:33:50.000Z</published>
    <updated>2020-07-21T01:44:09.867Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Harbor-概述"><a href="#Harbor-概述" class="headerlink" title="Harbor 概述"></a>Harbor 概述</h1><p>Harbor是由VMWare公司开源的容器镜像仓库。事实上，Harbor是在Docker Registry上进行了相应的企业级扩展，从而获得了更加广泛的应用，这些新的企业级特性包括：管理用户界面，基于角色的访问控制 ，AD/LDAP集成以及审计日志等，足以满足基本企业需求</p><p><a href="https://goharbor.io/" target="_blank" rel="noopener">Harbor 官网</a></p><p><a href="https://github.com/goharbor/harbor/releases" target="_blank" rel="noopener">Harbor GitHub 地址</a></p><h1 id="Harbor-部署条件"><a href="#Harbor-部署条件" class="headerlink" title="Harbor 部署条件"></a>Harbor 部署条件</h1><h2 id="服务器硬件配置"><a href="#服务器硬件配置" class="headerlink" title="服务器硬件配置"></a>服务器硬件配置</h2><p>最低要求:CPU2核/内存4G/硬盘40GB</p><p>推荐:CPU4核/内存8G/硬盘160GB</p><h2 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h2><p>Docker 17.06版本+ </p><p>Docker Compose 1.18版本+</p><h2 id="安装方式"><a href="#安装方式" class="headerlink" title="安装方式"></a>安装方式</h2><p>在线安装:从Docker Hub下载Harbor相关镜像，因此安装软件包非常小 </p><p>离线安装:安装包包含部署的相关镜像，因此安装包比较大</p><h1 id="docker-compose安装"><a href="#docker-compose安装" class="headerlink" title="docker-compose安装"></a>docker-compose安装</h1><h2 id="下载二进制文件"><a href="#下载二进制文件" class="headerlink" title="下载二进制文件"></a>下载二进制文件</h2><pre class="line-numbers language-shell"><code class="language-shell">https://github.com/docker/compose/releases    # docker-compose下载地址# 下载docker-compose-Linux-x86_64这个二进制文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="配置二进制文件"><a href="#配置二进制文件" class="headerlink" title="配置二进制文件"></a>配置二进制文件</h2><pre class="line-numbers language-shell"><code class="language-shell">mv docker-compose-Linux-x86_64 /usr/bin/docker-composechmod +x /usr/bin/docker-composedocker-compose --help  # 安装完成<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h1 id="Harbor-HTTP部署"><a href="#Harbor-HTTP部署" class="headerlink" title="Harbor HTTP部署"></a>Harbor HTTP部署</h1><h2 id="下载Harbor安装包"><a href="#下载Harbor安装包" class="headerlink" title="下载Harbor安装包"></a>下载Harbor安装包</h2><pre class="line-numbers language-shell"><code class="language-shell">wget https://github.com/goharbor/harbor/releases/download/v2.0.1/harbor-offline-installer-v2.0.1.tgz<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="解压安装包"><a href="#解压安装包" class="headerlink" title="解压安装包"></a>解压安装包</h2><pre class="line-numbers language-shell"><code class="language-shell">tar xf harbor-offline-installer-v2.0.1.tgz<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h2><pre class="line-numbers language-shell"><code class="language-shell">cp harbor.yml.tmpl harbor.ymlvim harbor.ymlhostname: reg.missf.com        # 修改Harbor默认域名https:     # 先注释https相关配置harbor_admin_password: MF-yihan        # 修改Harbor的密码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="部署Harbor"><a href="#部署Harbor" class="headerlink" title="部署Harbor"></a>部署Harbor</h2><pre class="line-numbers language-shell"><code class="language-shell">./prepare    # 做一系列的准备工作./install.sh    # 利用docker-compose拉取一系列的镜像,安装好之后就会直接启动<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="访问Harbor"><a href="#访问Harbor" class="headerlink" title="访问Harbor"></a>访问Harbor</h2><pre class="line-numbers language-shell"><code class="language-shell"># 通过本地电脑配置hosts,然后在浏览器访问我们的域名reg.missf.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>{% image https://pic.imgdb.cn/item/5f05980114195aa5940c513f.jpg '' '' %}<h2 id="登录Harbor"><a href="#登录Harbor" class="headerlink" title="登录Harbor"></a>登录Harbor</h2><pre class="line-numbers language-shell"><code class="language-shell">vim /etc/hosts    # 添加解析,登录时可以直接访问域名10.10.110.151 reg.missf.comvim /etc/docker/daemon.json     # 配置域名可信任,因为现在没有配置https,而docker默认是使用https协议去连接的,不配置不能登录成功{        "registry-mirrors": ["https://265wemgl.mirror.aliyuncs.com"],        "insecure registries": ["reg.missf.com"]}systemctl restart docker.service    # 修改了daemon.json需要重启dockerdocker-compose down && docker-compose up -d        # 重启docker之后容器有些会退出,重启harbor重启把容器拉起来 docker login reg.missf.com    # 登录成功Username: adminPassword: WARNING! Your password will be stored unencrypted in /root/.docker/config.json.Configure a credential helper to remove this warning. Seehttps://docs.docker.com/engine/reference/commandline/login/#credentials-storeLogin Succeeded<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="推送镜像到Harbor仓库"><a href="#推送镜像到Harbor仓库" class="headerlink" title="推送镜像到Harbor仓库"></a>推送镜像到Harbor仓库</h2><pre class="line-numbers language-shell"><code class="language-shell">docker tag nginx:1.0 reg.missf.com/library/nginx:1.0    # 推送之前修改镜像的标签(镜像中心/项目/镜像:标签)docker push reg.missf.com/library/nginx:1.0        # 推送镜像，pull拉取镜像也是使用这个标签去拉取The push refers to repository [reg.missf.com/library/nginx]b1b653ec37ba: Pushed fe503a975c26: Pushed 60165efe909a: Pushed e098d2f9f0dd: Pushed ae9b67129281: Pushed d2039520c249: Pushed 034f282942cd: Pushed 1.0: digest: sha256:a4c155ecb6b7eee5d332764057c29a74d8965de19f9d739f1792cf479c2bf030 size: 1786<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="查看Harbor上推送成功的镜像"><a href="#查看Harbor上推送成功的镜像" class="headerlink" title="查看Harbor上推送成功的镜像"></a>查看Harbor上推送成功的镜像</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://pic.imgdb.cn/item/5f068ad814195aa5945965c5.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="Harbor-HTTPS部署"><a href="#Harbor-HTTPS部署" class="headerlink" title="Harbor HTTPS部署"></a>Harbor HTTPS部署</h1><p>由于Harbor不附带任何证书，它默认使用HTTP来提供注册表请求。但是强烈建议为生产环境配置ssl证书。这里我们由于是实验测试，使用自签名证书，到时候生产环境配置可以去阿里云购买ssl证书。</p><h2 id="生成自签名ssl证书"><a href="#生成自签名ssl证书" class="headerlink" title="生成自签名ssl证书"></a>生成自签名ssl证书</h2><p>由于kubernetes使用cfssl自签证书,这里我们也使用cfssl生成自签证书</p><pre class="line-numbers language-shell"><code class="language-shell"># 执行这个脚本,安装cfssl并将命令放到/usr/bin/下供我们直接使用cat cfssl.sh     wget https://pkg.cfssl.org/R1.2/cfssl_linux-amd64wget https://pkg.cfssl.org/R1.2/cfssljson_linux-amd64wget https://pkg.cfssl.org/R1.2/cfssl-certinfo_linux-amd64chmod +x cfssl*mv cfssl_linux-amd64 /usr/bin/cfsslmv cfssljson_linux-amd64 /usr/bin/cfssljsonmv cfssl-certinfo_linux-amd64 /usr/bin/cfssl-certinfo# 执行这个脚本,生成两个json的ca配置文件并自动生成证书,cfssl是根据json的配置文件去生成ca证书的cat certs.sh     cat > ca-config.json <<EOF{  "signing": {    "default": {      "expiry": "87600h"    },    "profiles": {      "kubernetes": {         "expiry": "87600h",         "usages": [            "signing",            "key encipherment",            "server auth",            "client auth"        ]      }    }  }}EOFcat > ca-csr.json <<EOF{    "CN": "kubernetes",    "key": {        "algo": "rsa",        "size": 2048    },    "names": [        {            "C": "CN",            "L": "Beijing",            "ST": "Beijing"        }    ]}EOFcfssl gencert -initca ca-csr.json | cfssljson -bare ca -    # 初始化ca配置文件cat > reg.missf.com-csr.json <<EOF{  "CN": "reg.missf.com",  "hosts": [],  "key": {    "algo": "rsa",    "size": 2048  },  "names": [    {      "C": "CN",      "L": "BeiJing",      "ST": "BeiJing"    }  ]}EOFcfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes reg.missf.com-csr.json | cfssljson -bare reg.missf.com    # 生成ca证书# 执行完上面两个脚本之后我们会得到下面这两个文件reg.missf.com-key.pemreg.missf.com.pem<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Harbor启用HTTPS"><a href="#Harbor启用HTTPS" class="headerlink" title="Harbor启用HTTPS"></a>Harbor启用HTTPS</h2><pre class="line-numbers language-shell"><code class="language-shell">https:  # https port for harbor, default is 443  port: 443  # The path of cert and key files for nginx  certificate: /root/ssh/reg.missf.com.pem  private_key: /root/ssh/reg.missf.com-key.pem<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="重新配置并部署Harbor"><a href="#重新配置并部署Harbor" class="headerlink" title="重新配置并部署Harbor"></a>重新配置并部署Harbor</h2><pre class="line-numbers language-shell"><code class="language-shell">systemctl restart docker.service./preparedocker-compose downdocker-compose up –d    # 重新打开Harbor页面会自动跳转到https,但是由于是自签证书,所以仍会显示不安全<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="其他Docker主机连接Harbor仓库"><a href="#其他Docker主机连接Harbor仓库" class="headerlink" title="其他Docker主机连接Harbor仓库"></a>其他Docker主机连接Harbor仓库</h2><p>一般Harbor仓库都是自己公司内部使用,但是有时候也会开放给别的Docker主机去pull镜像，如果其他的Docker主机需要连接Harbor，必须要有证书才能连接</p><pre class="line-numbers language-shell"><code class="language-shell"># 复制Harbor主机的证书到需要连接Harbor仓库的Docker主机上mkdir -p /etc/docker/certs.d/reg.missf.com/        # 在Docker主机上创建目录cp reg.missf.com.pem /etc/docker/certs.d/reg.missf.com/reg.missf.com.crt    # 将Harbor主机的证书复制到Docker主机echo "10.10.110.151 reg.missf.com" >> /etc/hosts    # 这里由于是实验环境,需要配置域名解析docker login reg.missf.com    # 在其他的docker主机登录到Harbor,就可以pull拉取Harbor仓库的镜像了Username: adminPassword: WARNING! Your password will be stored unencrypted in /root/.docker/config.json.Configure a credential helper to remove this warning. Seehttps://docs.docker.com/engine/reference/commandline/login/#credentials-storeLogin Succeeded<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Harbor主从复制"><a href="#Harbor主从复制" class="headerlink" title="Harbor主从复制"></a>Harbor主从复制</h1><h2 id="Harbor主从复制的三种方式"><a href="#Harbor主从复制的三种方式" class="headerlink" title="Harbor主从复制的三种方式"></a>Harbor主从复制的三种方式</h2><p>学习过MySQL主从的同学可以看出，其实Harbor的主从复制和MySQL的主从复制方式非常相似</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://pic.imgdb.cn/item/5f06efe214195aa59476a2a7.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="主节点的仓库管理新建目标"><a href="#主节点的仓库管理新建目标" class="headerlink" title="主节点的仓库管理新建目标"></a>主节点的仓库管理新建目标</h2><p>新建一个目标，就代表本地Harbor可以连接到这个远程Harbor，当我们配置复制管理的目的Registry时，可以从新建目标里面填写复制镜像到那个Harbor节点</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://pic.imgdb.cn/item/5f06ef9014195aa5947687f2.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="主节点的复制管理新建规则"><a href="#主节点的复制管理新建规则" class="headerlink" title="主节点的复制管理新建规则"></a>主节点的复制管理新建规则</h2><p>配置复制模式和目的Registry，将本地Harbor主节点上的镜像(可以使用过滤器进行选择性推送)推送到备用Harbor节点上</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://pic.imgdb.cn/item/5f07bcfc14195aa594b4097d.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="推送验证"><a href="#推送验证" class="headerlink" title="推送验证"></a>推送验证</h2><p>这时候只有有镜像被推送到Harbor的主节点，那么Harbor主节点就会把镜像push到Harbor的备用节点，可以查看复制记录</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://pic.imgdb.cn/item/5f07c1be14195aa594b536af.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="Harbor运行维护"><a href="#Harbor运行维护" class="headerlink" title="Harbor运行维护"></a>Harbor运行维护</h1><h2 id="Harbor容器功能介绍"><a href="#Harbor容器功能介绍" class="headerlink" title="Harbor容器功能介绍"></a>Harbor容器功能介绍</h2><table><thead><tr><th>容器</th><th>功能</th></tr></thead><tbody><tr><td>harbor-core</td><td>配置管理中心</td></tr><tr><td>harbor-jobservice</td><td>负责镜像复制</td></tr><tr><td>harbor-log</td><td>记录操作日志</td></tr><tr><td>harbor-portal</td><td>Web管理页面和API</td></tr><tr><td>harbor-db</td><td>PG数据库</td></tr><tr><td>registryctl</td><td>镜像存储</td></tr><tr><td>nginx</td><td>前端代理，负责前端页面和镜像上传/下载转发</td></tr><tr><td>redis</td><td>会话</td></tr></tbody></table><p>Harbor容器数据持久化目录:/data(这个目录需要定时备份)</p><p>日志文件目录:/var/log/harbor</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Harbor-概述&quot;&gt;&lt;a href=&quot;#Harbor-概述&quot; class=&quot;headerlink&quot; title=&quot;Harbor 概述&quot;&gt;&lt;/a&gt;Harbor 概述&lt;/h1&gt;&lt;p&gt;Harbor是由VMWare公司开源的容器镜像仓库。事实上，Harbor是在Dock
      
    
    </summary>
    
    
      <category term="Docker" scheme="https://www.missf.top/categories/Docker/"/>
    
    
      <category term="Docker" scheme="https://www.missf.top/tags/Docker/"/>
    
      <category term="容器技术" scheme="https://www.missf.top/tags/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/"/>
    
      <category term="云计算" scheme="https://www.missf.top/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>Dockerfile定制容器镜像(6)</title>
    <link href="https://www.missf.top/post/44241b5a.html"/>
    <id>https://www.missf.top/post/44241b5a.html</id>
    <published>2020-06-30T05:33:50.000Z</published>
    <updated>2020-07-30T08:23:20.027Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Dockerfile-介绍"><a href="#Dockerfile-介绍" class="headerlink" title="Dockerfile 介绍"></a>Dockerfile 介绍</h1><p>Dockerfile是由一行一行的命令语句组成，并且从上到下执行，支持以#注释行。一般Dockerfile的内容分为四个部分，基础镜像信息、维护者信息、镜像操作指令、容器启动时执行指令</p><h1 id="Dockerfile-常用指令"><a href="#Dockerfile-常用指令" class="headerlink" title="Dockerfile 常用指令"></a>Dockerfile 常用指令</h1><table><thead><tr><th>指令</th><th>描述</th></tr></thead><tbody><tr><td>FROM</td><td>指定构建新镜像时是基于那个镜像，Dockerfile的第一条指令必须为FROM指令，如果在同一个Dockerfile中创建多个镜像可以使用多个FROM指令</td></tr><tr><td>LABEL</td><td>为镜像添加标签</td></tr><tr><td>RUN</td><td>每条RUN指令将在当前镜像的基础上执行指定shell命令，并提交为新的镜像</td></tr><tr><td>COPY</td><td>拷贝宿主机(Dockerfile所在目录的相对路径)的文件或目录到镜像中</td></tr><tr><td>ADD</td><td>复制指定的&lt;src&gt;到容器中的&lt;dest&gt;，&lt;src&gt;可以是Dockerfile所在目录的文件或目录，可以是一个URL，还可以是一个tar文件(自动解压缩)</td></tr><tr><td>ENV</td><td>指定一个环境变量，会被后续RUN指令使用，并在容器运行时保持</td></tr><tr><td>USER</td><td>指定运行容器时的用户名或UID，后续的RUN也会使用指定用户</td></tr><tr><td>EXPOSE</td><td>声明容器运行的服务端口，启动容器时可以将这些端口转发到宿主机或者指定宿主机那个端口映射过来</td></tr><tr><td>WORKDIR</td><td>为后续的RUN、CMD、ENTRYPOINT指令配置工作目录</td></tr><tr><td>VOLUME</td><td>在镜像中创建挂载点，这样只要通过该镜像创建的容器都有了挂载点，查看容器详细信息可以看到容器挂载点映射到宿主机的目录</td></tr><tr><td>CMD</td><td>容器启动时执行指令，每个Dockerfile只能有一条CMD指令，如果有多个CMD指令只有最后一个生效</td></tr><tr><td>ENTRYPOINT</td><td>ENTRYPOINT如果与CMD一起使用，CMD将作为ENTRYPOINT的默认参数，如果有多个ENTRYPOINT指令只有最后一个生效</td></tr></tbody></table><h1 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h1><h2 id="Dockerfile-demo"><a href="#Dockerfile-demo" class="headerlink" title="Dockerfile demo"></a>Dockerfile demo</h2><pre class="line-numbers language-dockerfile"><code class="language-dockerfile"># This dockerfile demo for project build to docker imagesFROM centos:7LABEL maintainer www.missf.topUSER rootRUN yum install -y nginxEXPOSE 80 443VOLUME ["/usr/local/nginx/"]CMD ["/usr/local/nginx/bin"]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Docker-build构建镜像"><a href="#Docker-build构建镜像" class="headerlink" title="Docker build构建镜像"></a>Docker build构建镜像</h2><pre class="line-numbers language-dockerfile"><code class="language-dockerfile"># 在Dockerfile所在的目录下构建镜像,后面的"."表示当前目录docker build -t demo:1.0 .# 构建过程如下Sending build context to Docker daemon  2.048kBStep 1/8 : FROM centos:77: Pulling from library/centos524b0c1e57f8: Pull complete Digest: sha256:e9ce0b76f29f942502facd849f3e468232492b259b9d9f076f71b392293f1582Status: Downloaded newer image for centos:7 ---> b5b4d78bc90cStep 2/8 : LABEL maintainer mownejie ---> Running in 7dbcab7ef3ceRemoving intermediate container 7dbcab7ef3ce ---> 4db1e9da6977Step 3/8 : ENV JAVA_HOME /usr/local/java ---> Running in b896cedee458Removing intermediate container b896cedee458 ---> f8991838d97eStep 4/8 : USER root ---> Running in 8252457198f0Removing intermediate container 8252457198f0 ---> 96ef213928adStep 5/8 : RUN yum install -y nginx ---> Running in 8807973810c5......# -t 指定这个镜像的tag# -f 指定这个Dockerfile文件的位置<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="CMD-与-ENTRYPOINT-区别"><a href="#CMD-与-ENTRYPOINT-区别" class="headerlink" title="CMD 与 ENTRYPOINT 区别"></a>CMD 与 ENTRYPOINT 区别</h1><h2 id="CMD用法"><a href="#CMD用法" class="headerlink" title="CMD用法"></a>CMD用法</h2><pre class="line-numbers language-dockerfile"><code class="language-dockerfile"># exec形式,首选形式,传参不支持引用变量CMD ["executable", "param1", "param2"]# CMD作为ENTRYPOINT的默认参数CMD ["param1", "param2"]# Shell形式CMD command param1 param2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="ENTRYPOINT用法"><a href="#ENTRYPOINT用法" class="headerlink" title="ENTRYPOINT用法"></a>ENTRYPOINT用法</h2><pre class="line-numbers language-dockerfile"><code class="language-dockerfile">ENTRYPOINT ["executable", "param1", "param2"]    # 假如配合CMD一起使用,那么["param1", "param2"]可以写在CMD作为ENTRYPOINT的默认参数ENTRYPOINT command param1 param2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><pre class="line-numbers language-shell"><code class="language-shell">1. CMD和ENTRYPOINT指令都可以用来定义运行容器时所使用的命令2. Dockerfile至少指定一个CMD或ENTRYPOINT3. CMD可以用作ENTRYPOINT默认参数，或者用作容器的默认命令4. docker run启动容器时指定<command>，将会覆盖dockerfile定义的CMD<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h1 id="构建Nginx容器镜像"><a href="#构建Nginx容器镜像" class="headerlink" title="构建Nginx容器镜像"></a>构建Nginx容器镜像</h1><h2 id="dockerfile内容"><a href="#dockerfile内容" class="headerlink" title="dockerfile内容"></a>dockerfile内容</h2><pre class="line-numbers language-dockerfile"><code class="language-dockerfile">FROM centos:7.7.1908LABEL maintainer www.missf.topRUN yum install -y gcc gcc-c++ make \    openssl-devel pcre-devel gd-devel \    iproute net-tools telnet wget curl && \    yum clean all && rm -rf /var/cache/yum/*ADD nginx-1.16.1.tar.gz /RUN cd nginx-1.16.1 && \    ./configure --user=nginx --group=nginx \    --prefix=/usr/local/nginx \    --with-http_stub_status_module \    --with-http_ssl_module \    --with-http_gzip_static_module \    --with-http_sub_module && \    make -j4 && make install && \    mkdir /usr/local/nginx/conf/vhost && \    cd / && rm -rf nginx* && \    ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtimeRUN useradd -s /sbin/nologin nginxENV PATH $PATH:/usr/local/nginx/sbinENV LANG="en_US.utf8"COPY nginx.conf /usr/local/nginx/conf/nginx.confCOPY php.conf /usr/local/nginx/conf/vhost/php.confWORKDIR /usr/local/nginxEXPOSE 80 443CMD ["nginx", "-g", "daemon off;"]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><pre class="line-numbers language-shell"><code class="language-shell">[root@localhost /Dockerfile/nginx]# lltotal 1028-rw-r--r-- 1 root root     890 Jul  6 18:58 Dockerfile-rw-r--r-- 1 root root 1032630 Jan 14 09:53 nginx-1.16.1.tar.gz-rw-r--r-- 1 root root    3297 Jul  6 18:46 nginx.conf-rw-r--r-- 1 root root     362 Jul  6 20:13 php.conf-rw-r--r-- 1 root root     128 Jul  6 18:51 start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="构建PHP容器镜像"><a href="#构建PHP容器镜像" class="headerlink" title="构建PHP容器镜像"></a>构建PHP容器镜像</h1><h2 id="dockerfile内容-1"><a href="#dockerfile内容-1" class="headerlink" title="dockerfile内容"></a>dockerfile内容</h2><pre class="line-numbers language-dockerfile"><code class="language-dockerfile">FROM centos:7.7.1908LABEL maintainer www.missf.topRUN yum install -y epel-release && \    yum install -y sqlite-devel libmcrypt-devel mhash-devel libxslt-devel \    libjpeg-devel libpng libpng-devel freetype freetype-devel \    libxml2 libxml2-devel zlib zlib-devel glibc glibc-devel libjpeg \    glib2 glib2-develbzip2 bzip2-devel ncurses ncurses-devel \    curl-devel e2fsprogs e2fsprogs-devel krb5 gcc krb5-devel libidn \    openssl-devel libsqlite3x-devel oniguruma-devel openssl libidn-devel \    iproute net-tools telnet wget curl && \    yum clean all && rm -rf /var/cache/yum/*ADD php-7.4.0.tar.gz /RUN cd /php-7.4.0 && \    ./configure --prefix=/usr/local/php \    --with-config-file-path=/usr/local/php/etc \    --enable-opcache --with-curl --enable-fpm \    --enable-gd --with-iconv --enable-mbstring \    --with-mysqli --with-openssl --enable-static \    --enable-sockets --enable-inline-optimization \    --with-zlib --disable-ipv6 --disable-fileinfo \    --with-mcrypt --enable-hash --with-jpeg-dir --with-png-dir \    --with-freetype-dir --with-pdo-mysql --disable-debug && \    make -j 4 && make install && \    cp /php-7.4.0/php.ini-production /usr/local/php/etc/php.ini && \    cp /usr/local/php/etc/php-fpm.conf.default /usr/local/php/etc/php-fpm.conf && \    cp /usr/local/php/etc/php-fpm.d/www.conf.default /usr/local/php/etc/php-fpm.d/www.conf && \    sed -i "90a \daemonize = no" /usr/local/php/etc/php-fpm.conf && \    mkdir /usr/local/php/log && \    cd / && rm -rf php* && \    ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtimeENV PATH $PATH:/usr/local/php/sbinENV LANG="en_US.utf8"COPY php.ini /usr/local/php/etc/COPY php-fpm.conf /usr/local/php/etc/COPY www.conf /usr/local/php/etc/php-fpm.d/WORKDIR /usr/local/phpEXPOSE 9000CMD ["php-fpm"]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="目录结构-1"><a href="#目录结构-1" class="headerlink" title="目录结构"></a>目录结构</h2><pre class="line-numbers language-shell"><code class="language-shell">[root@localhost /Dockerfile/php]# lltotal 16144-rw-r--r-- 1 root root     1758 Jul  6 18:53 Dockerfile-rw-r--r-- 1 root root 16418792 Jul  1 10:39 php-7.4.0.tar.gz-rw-r--r-- 1 root root     5394 Jul  1 21:51 php-fpm.conf-rw-r--r-- 1 root root    72953 Jul  1 22:09 php.ini-rw-r--r-- 1 root root       93 Jul  6 18:56 start-rw-r--r-- 1 root root    19616 Jul  6 18:53 www.conf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="容器化搭建个人博客"><a href="#容器化搭建个人博客" class="headerlink" title="容器化搭建个人博客"></a>容器化搭建个人博客</h1><h2 id="自定义网络"><a href="#自定义网络" class="headerlink" title="自定义网络"></a>自定义网络</h2><pre class="line-numbers language-shell"><code class="language-shell">docker network create lnmp    # 将多个容器加入到一个自定义网络<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="创建MySQL容器"><a href="#创建MySQL容器" class="headerlink" title="创建MySQL容器"></a>创建MySQL容器</h2><pre class="line-numbers language-shell"><code class="language-shell">docker volume create mysqldocker run -e MYSQL_ROOT_PASSWORD=mwj123456 -e MYSQL_DATABASE=wordpress -p 53306:3306 --name "mysql" --network lnmp --mount src=mysql,dst=/var/lib/mysql/ -d mysql:5.7# 将MySQL数据库的数据持久化到mysql这个数据卷<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="创建PHP容器"><a href="#创建PHP容器" class="headerlink" title="创建PHP容器"></a>创建PHP容器</h2><pre class="line-numbers language-shell"><code class="language-shell">docker volume create nginxdocker run --name php --network lnmp --mount src=nginx,dst=/usr/local/nginx/html/ -d php:1.0    # 这里先启动PHP容器再启动Nginx容器,因为Nginx要去连接PHP容器,如果PHP容器没有启动,那Nginx就因为无法连接到PHP所有退出了# 这里需要把Nginx代码也挂载到PHP容器内,而且容器内的路径要与Nginx配置文件路径一致# 因为Nginx配置文件将所有*.php的请求都通过fastcgi_pass代理到PHP容器去处理,所有需要把代码也挂载到PHP容器内,不然访问php文件会提示未找到文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="创建Nginx容器"><a href="#创建Nginx容器" class="headerlink" title="创建Nginx容器"></a>创建Nginx容器</h2><pre class="line-numbers language-shell"><code class="language-shell">docker container run --name "nginx" --mount src=nginx,dst=/usr/local/nginx/html --network lnmp -p 80:80 -p 443:443 -d nginx:1.0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="部署WordPress代码"><a href="#部署WordPress代码" class="headerlink" title="部署WordPress代码"></a>部署WordPress代码</h2><pre class="line-numbers language-shell"><code class="language-shell">docker volume inspect nginx        # 先查看数据卷在宿主机上的目录,然后把代码解压到对应的目录下tar xf wordpress-5.4.2-zh_CN.tar.gz -C /var/lib/docker/volumes/nginx/_data/# 这时候通过访问宿主机的IP就能看到WordPress的安装页面了,如果无法对wp-config.php文件写入,就手动创建并写入<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="构建Tomcat容器镜像"><a href="#构建Tomcat容器镜像" class="headerlink" title="构建Tomcat容器镜像"></a>构建Tomcat容器镜像</h1><h2 id="dockerfile内容-2"><a href="#dockerfile内容-2" class="headerlink" title="dockerfile内容"></a>dockerfile内容</h2><pre class="line-numbers language-dockerfile"><code class="language-dockerfile">FROM centos:7.7.1908LABEL maintainer www.missf.topADD jdk-8u211-linux-x64.tar.gz /usr/local/ADD apache-tomcat-8.5.57.tar.gz /usr/local/RUN mv /usr/local/jdk1.8.0_211 /usr/local/jdk && \    mv /usr/local/apache-tomcat-8.5.57 /usr/local/tomcat && \    rm -rf /usr/local/tomcat/webapps/*ENV JAVA_HOME /usr/local/jdkENV CLASSPATH ${JAVA_HOME}/lib/dt.jar:${JAVA_HOME}/lib/tools.jarENV CATALINA_HOME /usr/local/tomcatENV PATH $PATH:${JAVA_HOME}/bin:${CATALINA_HOME}/lib:${CATALINA_HOME}/binRUN sed -i '1a JAVA_OPTS="-Djava.security.egd=file:/dev/./urandom"' ${CATALINA_HOME}/bin/catalina.sh && \    ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtimeWORKDIR ${CATALINA_HOME}EXPOSE 8080CMD ["catalina.sh", "run"]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="目录结构-2"><a href="#目录结构-2" class="headerlink" title="目录结构"></a>目录结构</h2><pre class="line-numbers language-shell"><code class="language-shell">[root@localhost /Dockerfile/tomcat]# lltotal 200568-rw-r--r-- 1 root root  10379806 Jul  7 11:19 apache-tomcat-8.5.57.tar.gz-rw-r--r-- 1 root root       728 Jul  7 19:41 Dockerfile-rw-r--r-- 1 root root 194990602 Jul  2  2019 jdk-8u211-linux-x64.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="部署测试代码"><a href="#部署测试代码" class="headerlink" title="部署测试代码"></a>部署测试代码</h2><pre class="line-numbers language-shell"><code class="language-shell">docker volume inspect tomcat    # 查看Tomcat容器代码目录持久化到宿主机的目录ll /var/lib/docker/volumes/tomcat/_data        # 放到这个目录的war包会被自动解压total 17840drwxr-x--- 4 root root       37 Jul  7 21:34 ROOT-rw-r--r-- 1 root root 18265402 Jun 20 13:08 ROOT.war<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="构建java微服务项目镜像"><a href="#构建java微服务项目镜像" class="headerlink" title="构建java微服务项目镜像"></a>构建java微服务项目镜像</h1><h2 id="dockerfile内容-3"><a href="#dockerfile内容-3" class="headerlink" title="dockerfile内容"></a>dockerfile内容</h2><pre class="line-numbers language-dockerfile"><code class="language-dockerfile"># 一个容器内只跑一个jar包FROM java:8-jdk-alpineLABEL maintainer www.missf.topENV JAVA_OPTS="$JAVA_OPTS -Dfile.encoding=UTF8 -Duser.timezone=GMT+08 -Xms128m -Xmx128m"RUN sed -i 's/dl-cdn.alpinelinux.org/mirrors.aliyun.com/g' /etc/apk/repositories && \    apk add -U tzdata && \    mkdir /projects && \    ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtimeCOPY hello.jar /projects/EXPOSE 8888CMD ["/bin/sh", "-c", "java -jar $JAVA_OPTS /projects/hello.jar"]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Dockerfile-最佳实践"><a href="#Dockerfile-最佳实践" class="headerlink" title="Dockerfile 最佳实践"></a>Dockerfile 最佳实践</h1><h2 id="减少镜像层"><a href="#减少镜像层" class="headerlink" title="减少镜像层"></a>减少镜像层</h2><p>一次RUN指令形成新的一层镜像，shell命令尽量写在一行，减少镜像层</p><h2 id="优化镜像大小"><a href="#优化镜像大小" class="headerlink" title="优化镜像大小"></a>优化镜像大小</h2><p>在形成新的一层镜像之后，如果没有在同一层删除缓存或者没用的文件，那么这些文件都会被带到下一层，所有要在每一层清理对应的残留数据，减少镜像大小</p><h2 id="减少网络传输"><a href="#减少网络传输" class="headerlink" title="减少网络传输"></a>减少网络传输</h2><p>例如镜像所需要下载的软件包，mvn仓库</p><h2 id="多阶段构建"><a href="#多阶段构建" class="headerlink" title="多阶段构建"></a>多阶段构建</h2><p>代码编译、部署在一个Dockerfile完成，只会保留部署阶段产生的数据</p><h2 id="选择最小的基础镜像"><a href="#选择最小的基础镜像" class="headerlink" title="选择最小的基础镜像"></a>选择最小的基础镜像</h2><p>例如alpine</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Dockerfile-介绍&quot;&gt;&lt;a href=&quot;#Dockerfile-介绍&quot; class=&quot;headerlink&quot; title=&quot;Dockerfile 介绍&quot;&gt;&lt;/a&gt;Dockerfile 介绍&lt;/h1&gt;&lt;p&gt;Dockerfile是由一行一行的命令语句组成，并且
      
    
    </summary>
    
    
      <category term="Docker" scheme="https://www.missf.top/categories/Docker/"/>
    
    
      <category term="Docker" scheme="https://www.missf.top/tags/Docker/"/>
    
      <category term="容器技术" scheme="https://www.missf.top/tags/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/"/>
    
      <category term="云计算" scheme="https://www.missf.top/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>Docker容器网络(5)</title>
    <link href="https://www.missf.top/post/bc1d2f66.html"/>
    <id>https://www.missf.top/post/bc1d2f66.html</id>
    <published>2020-06-23T01:49:44.000Z</published>
    <updated>2020-07-14T01:20:15.112Z</updated>
    
    <content type="html"><![CDATA[<h1 id="容器的四种网络模式"><a href="#容器的四种网络模式" class="headerlink" title="容器的四种网络模式"></a>容器的四种网络模式</h1><h2 id="bridge-模式"><a href="#bridge-模式" class="headerlink" title="bridge 模式"></a>bridge 模式</h2><p>当启动docker进程之后，docker会默认创建一个名为docker0的虚拟网桥，创建容器时如果不指定网络，默认就是添加到这个网桥中。这样docker主机上的所有容器都可以通过交换机的方式连接在一个二层网络中。创建容器时，docker会先创建容器的虚拟网卡，容器的虚拟网卡去连接docker主机的docker0虚拟网桥，相当于用一根网线将容器和docker主机连接起来。虚拟网卡连接到docker0子网后，由docker0虚拟网桥分配IP给容器的虚拟网卡使用，并设置docker0虚拟网桥的IP地址为容器的默认网关。除了docker启动时默认创建的bridge默认网络，我们还可以自定义bridge网络。相比默认的具备内部DNS发现，bridge网络模式还可以通过容器名去实现容器之间的网络通信</p><p>查看docker宿主机上的docker0虚拟网桥，默认网段是172.17.0.1，安装docker之后默认创建的</p><pre class="line-numbers language-shell"><code class="language-shell">ip a s docker03: docker0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP group default     link/ether 02:42:9f:dc:ee:74 brd ff:ff:ff:ff:ff:ff    inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0       valid_lft forever preferred_lft forever    inet6 fe80::42:9fff:fedc:ee74/64 scope link        valid_lft forever preferred_lft forever<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>查看默认定义好的网络模式,这里没有container模式是因为container是启动容器时直接指定的</p><pre class="line-numbers language-shell"><code class="language-shell">docker network lsNETWORK ID          NAME                DRIVER              SCOPEa42d2b0e12ec        bridge              bridge              local168bbf4b0447        host                host                localec481d03e2a1        none                null                local21be62f7b97e        webserver           bridge              local<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>查看bridge网络模式的详细信息</p><pre class="line-numbers language-shell"><code class="language-shell">docker network inspect bridge[    {        "Name": "bridge",        "Id": "a42d2b0e12ec0e039e7c4686099468585b88c8df8b639eaa780700980adb9e1b",        "Created": "2020-06-23T17:16:25.717600267+08:00",        "Scope": "local",        "Driver": "bridge",        "EnableIPv6": false,        "IPAM": {            "Driver": "default",            "Options": null,            "Config": [                {                    "Subnet": "172.17.0.0/16",                    "Gateway": "172.17.0.1"                }            ]        },        "Internal": false,        "Attachable": false,        "Ingress": false,        "ConfigFrom": {            "Network": ""        },        "ConfigOnly": false,        "Containers": {            "253d0d8f196182eccaa52238068513cebfbf2abe69d2a7980e40d8c136b53960": {                "Name": "nginx",                "EndpointID": "7fd4576f90bc1d0fd966ed5794710dd43461d077ea32f99e54a8b3c56ba1de08",                "MacAddress": "02:42:ac:11:00:02",                "IPv4Address": "172.17.0.2/16",                "IPv6Address": ""            },            "8652448b6f9a99d9b9a6c70277ea23924b21df57289d4deb29a146974ad4c4dd": {                "Name": "centos7",                "EndpointID": "e112927463f07a606a3a019f3af7400c711b9a903fec19c130b27c7d5f53d359",                "MacAddress": "02:42:ac:11:00:03",                "IPv4Address": "172.17.0.3/16",                "IPv6Address": ""            }        },        "Options": {            "com.docker.network.bridge.default_bridge": "true",            "com.docker.network.bridge.enable_icc": "true",            "com.docker.network.bridge.enable_ip_masquerade": "true",            "com.docker.network.bridge.host_binding_ipv4": "0.0.0.0",            "com.docker.network.bridge.name": "docker0",            "com.docker.network.driver.mtu": "1500"        },        "Labels": {}    }]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>安装网桥管理工具包</p><pre class="line-numbers language-shell"><code class="language-shell">yum install -y bridge-utils.x86_64<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看虚拟网桥上的接口信息</p><pre class="line-numbers language-shell"><code class="language-shell">brctl show docker0bridge name    bridge id                STP enabled        interfacesdocker0        8000.02429fdcee74        no                veth81bdc19                                                    vetha8f66a7<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>创建类型为bridge的自定义网桥</p><pre class="line-numbers language-shell"><code class="language-shell">docker network create webserver21be62f7b97ebfc9ce6f6a1aaaffd59a4a220c6b778f36a98c72162023b5c5e5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>启动容器时指定使用自定义创建的webserver网桥(具备DNS发现)</p><pre class="line-numbers language-shell"><code class="language-shell">docker container run -itd --name "app1" --network webserver centos:7.7.1908 98efd7fb3c63c0bd487039b7ef00925d786e0499f10d76003afa2277cc93b404docker container run -itd --name "app2" --network webserver centos:7.7.1908 c81e58db50ca74111d46f460ff322378b45414a36804738597559ec3c06cf542docker container run -itd --name "app3" --network webserver centos:7.7.190841fb1a7dd161c03a158a104da54dcfa3b226035feceecabd003f7a18e91bff61<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>查看容器的IP地址</p><pre class="line-numbers language-shell"><code class="language-shell">docker inspect --format='{{.NetworkSettings.Networks.webserver.IPAddress}}' app1172.18.0.2docker inspect --format='{{.NetworkSettings.Networks.webserver.IPAddress}}' app2172.18.0.3docker inspect --format='{{.NetworkSettings.Networks.webserver.IPAddress}}' app3172.18.0.4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>容器之间的通信测试，自定义的bridge网桥相比默认的bridge网桥具备内部DNS发现， IP和主机名都是可以PING通</p><pre class="line-numbers language-shell"><code class="language-shell">ping 172.18.0.2PING 172.18.0.2 (172.18.0.2) 56(84) bytes of data.64 bytes from 172.18.0.2: icmp_seq=1 ttl=64 time=0.203 ms64 bytes from 172.18.0.2: icmp_seq=2 ttl=64 time=0.085 msping 98efd7fb3c63    # 如果启动容器时不指定自定义的网桥,那就会使用默认的bridge模式,这样是不能PING通主机名的PING 98efd7fb3c63 (172.18.0.2) 56(84) bytes of data.64 bytes from app1.webserver (172.18.0.2): icmp_seq=1 ttl=64 time=0.402 ms64 bytes from app1.webserver (172.18.0.2): icmp_seq=2 ttl=64 time=0.100 ms<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="host模式"><a href="#host模式" class="headerlink" title="host模式"></a>host模式</h2><p>如果启动容器时指定host模式，那么这个容器将不会获得一个独立的Network namespace，而是和宿主机共用一个Network namespace。容器不会虚拟出自己的网卡，而是使用宿主机的IP和端口。这种无需NAT转换的网络模式无需再映射容器与宿主机之间的端口，在提高网络传输性能的同时，造成了网络环境隔离性弱化。容器之间不再拥有隔离独立的网络，docker host上已使用的端口就不能再用了</p><p>启动一个nginx容器，再查看宿主机上的80端口是否被使用</p><pre class="line-numbers language-shell"><code class="language-shell">docker container run -itd --name "host_nginx" --network=host nginx:1.1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看宿主机上的80端口是否被nginx容器所使用</p><pre class="line-numbers language-shell"><code class="language-shell">netstat -lntup | grep 80tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      7358/nginx: master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>查看宿主机上nginx进程的父进程是否为docker</p><pre class="line-numbers language-shell"><code class="language-shell">ps -afx | grep containerd -A 1  1100 ?        Ssl    1:18 /usr/bin/containerd  7341 ?        Sl     0:00  \_ containerd-shim -namespace moby -workdir /var/lib/containerd/io.containerd.runtime.v1.linux/moby/adf66250b1fcd95c2531f04f8504bea614dd90903f4f074e150ce6202895a023 -address /run/containerd/containerd.sock -containerd-binary /usr/bin/containerd -runtime-root /var/run/docker/runtime-runc  7358 pts/0    Ss+    0:00      \_ nginx: master process nginx -g daemon off;    # 这个nginx进程是容器中启动的nginx进程,这也正如我们前面所说,使用host模式启动容器,容器会和宿主机共用一个Network namespace<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>进入容器中查看网卡信息，可以看到宿主机上的网卡也会显示，这就是共用了一个Network namespace的结果</p><pre class="line-numbers language-shell"><code class="language-shell">ifconfigbr-21be62f7b97e: flags=4099<UP,BROADCAST,MULTICAST>  mtu 1500        inet 172.18.0.1  netmask 255.255.0.0  broadcast 172.18.255.255        inet6 fe80::42:6fff:fe77:c9f0  prefixlen 64  scopeid 0x20<link>        ether 02:42:6f:77:c9:f0  txqueuelen 0  (Ethernet)        RX packets 0  bytes 0 (0.0 B)        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 0  bytes 0 (0.0 B)        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0docker0: flags=4099<UP,BROADCAST,MULTICAST>  mtu 1500        inet 172.17.0.1  netmask 255.255.0.0  broadcast 172.17.255.255        inet6 fe80::42:9fff:fedc:ee74  prefixlen 64  scopeid 0x20<link>        ether 02:42:9f:dc:ee:74  txqueuelen 0  (Ethernet)        RX packets 3  bytes 114 (114.0 B)        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 8  bytes 677 (677.0 B)        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0ens32: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500        inet 10.10.110.150  netmask 255.255.255.0  broadcast 10.10.110.255        inet6 fe80::20c:29ff:fec4:cbac  prefixlen 64  scopeid 0x20<link>        ether 00:0c:29:c4:cb:ac  txqueuelen 1000  (Ethernet)        RX packets 91694  bytes 118390130 (112.9 MiB)        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 41857  bytes 2875558 (2.7 MiB)        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0lo: flags=73<UP,LOOPBACK,RUNNING>  mtu 65536        inet 127.0.0.1  netmask 255.0.0.0        inet6 ::1  prefixlen 128  scopeid 0x10<host>        loop  txqueuelen 1000  (Local Loopback)        RX packets 0  bytes 0 (0.0 B)        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 0  bytes 0 (0.0 B)        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="none模式"><a href="#none模式" class="headerlink" title="none模式"></a>none模式</h2><p>容器启动时指定none模式是获取独立的Network namespace，但不为容器进行任何网络配置。容器内部只有loopback网络设备不会再有其他的网络资源，将网络创建的责任完全交给用户。作为 Docker 开发者，才能在这基础做其他无限多可能的网络定制开发，这种方式可以实现更加灵活复杂的网络，同时也体现了Docker设计理念的开放</p><p>启动一个none模式的容器</p><pre class="line-numbers language-shell"><code class="language-shell">docker container run -itd --name "none_centos" --network=none centos:7.7.1908<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>进入容器查看网卡设备信息</p><pre class="line-numbers language-shell"><code class="language-shell">docker container exec -it none_centos /bin/bashifconfig    # 这里只有一个回环口地址,因为none模式不会对容器进行任何网络配置lo: flags=73<UP,LOOPBACK,RUNNING>  mtu 65536        inet 127.0.0.1  netmask 255.0.0.0        inet6 ::1  prefixlen 128  scopeid 0x10<host>        loop  txqueuelen 1000  (Local Loopback)        RX packets 0  bytes 0 (0.0 B)        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 0  bytes 0 (0.0 B)        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="container模式"><a href="#container模式" class="headerlink" title="container模式"></a>container模式</h2><p>创建新的容器时指定和已存在的容器共享一个Network namespace，这些容器之间共享IP、端口范围等网络配置，容器之间传输效率高。两个容器除了网络资源共享之外，其他资源还是隔离的。虽然多个容器共享网络环境，但是多个容器形成的整体依然与宿主机以及其他容器形成网络隔离</p><p>启动一个名为server1的容器</p><pre class="line-numbers language-shell"><code class="language-shell">docker container run -itd --name "server1" centos:7.7.1908<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>再启动两个容器，把它们加入到server1这个容器的Network namespace</p><pre class="line-numbers language-shell"><code class="language-shell">docker container run -itd --name "server2" --network=container:server1 centos:7.7.1908docker container run -itd --name "server3" --network=container:server1 centos:7.7.1908<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>查看各个容器的IP地址</p><pre class="line-numbers language-shell"><code class="language-shell">docker inspect --format='{{.NetworkSettings.Networks.bridge.IPAddress}}' server1172.17.0.3docker inspect --format='{{.NetworkSettings.Networks.bridge.IPAddress}}' server2<no value>docker inspect --format='{{.NetworkSettings.Networks.bridge.IPAddress}}' server3<no value><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里我们在查看server2和server3容器IP时，显示为&lt;no value&gt;，其实它们是和server1共用一个Network namespace的</p><pre class="line-numbers language-shell"><code class="language-shell">docker container exec -it server2 /bin/bash[root@41436b0be6f7 /]# ifconfigeth0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500        inet 172.17.0.3  netmask 255.255.0.0  broadcast 172.17.255.255        ether 02:42:ac:11:00:03  txqueuelen 0  (Ethernet)        RX packets 10969  bytes 20985758 (20.0 MiB)        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 6234  bytes 344851 (336.7 KiB)        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0docker container exec -it server3 /bin/bash[root@41436b0be6f7 /]# ifconfigeth0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500        inet 172.17.0.3  netmask 255.255.0.0  broadcast 172.17.255.255        ether 02:42:ac:11:00:03  txqueuelen 0  (Ethernet)        RX packets 10969  bytes 20985758 (20.0 MiB)        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 6234  bytes 344851 (336.7 KiB)        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0# 两个容器的IP、主机名都相同<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="容器虚拟网卡和docker0网桥的veth-pair配对"><a href="#容器虚拟网卡和docker0网桥的veth-pair配对" class="headerlink" title="容器虚拟网卡和docker0网桥的veth pair配对"></a>容器虚拟网卡和docker0网桥的veth pair配对</h1><p>veth是成对出现的虚拟网络设备， 发送到veth一端虚拟设备的请求会从另一端的虚拟设备中发出。创建一个容器的同时会为这个容器创建一对虚拟网卡veth pair，这个成对出现的虚拟网卡veth pair，分别放到宿主机和容器中，宿主机一端桥接到默认的docker0或者自定义的网桥上，容器一端放到新创建容器的Network namespace中，并把名字修改为eth0。虚拟网卡veth pair就像是一根网线，将宿主机的docker0和容器连接起来</p><pre class="line-numbers language-shell"><code class="language-shell">docker container run -itd --name "server1" centos:7.7.1908    # 创建容器brctl show docker0    # 查看宿主机上的docker0网桥bridge name    bridge id        STP enabled    interfacesdocker0        8000.02429fdcee74    no        veth7459cf7ip a s veth7459cf7    # 这是虚拟网卡veth pair在宿主机上的一端34: veth7459cf7@if33: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue master docker0 state UP group default     link/ether 86:54:3c:c6:70:6b brd ff:ff:ff:ff:ff:ff link-netnsid 0    inet6 fe80::8454:3cff:fec6:706b/64 scope link        valid_lft forever preferred_lft forever[root@ec94bfbd724f /]# ifconfig        # 容器内部的eth0网卡是虚拟网卡veth pair在容器中的一端eth0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500        inet 172.17.0.2  netmask 255.255.0.0  broadcast 172.17.255.255        ether 02:42:ac:11:00:02  txqueuelen 0  (Ethernet)        RX packets 5495  bytes 10346440 (9.8 MiB)        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 3386  bytes 186731 (182.3 KiB)        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="容器网络访问原理图"><a href="#容器网络访问原理图" class="headerlink" title="容器网络访问原理图"></a>容器网络访问原理图</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://pic.imgdb.cn/item/5ef9619814195aa5940901bf.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="容器网络实现的核心技术-iptables"><a href="#容器网络实现的核心技术-iptables" class="headerlink" title="容器网络实现的核心技术: iptables"></a>容器网络实现的核心技术: iptables</h1><p>docker容器的跨网络隔离与通信，是使用iptables去实现的</p><h2 id="源IP地址变换规则"><a href="#源IP地址变换规则" class="headerlink" title="源IP地址变换规则"></a>源IP地址变换规则</h2><p>docker在安装完成后，将默认在宿主机上增加一些iptables规则，以用于docker容器和容器之间的隔离与通信，可以使用使用iptables-save命令查看</p><pre class="line-numbers language-shell"><code class="language-shell">iptables-save | grep docker-A POSTROUTING -s 172.17.0.0/16 ! -o docker0 -j MASQUERADE参数说明:-s:源地址172.17.0.0/16-o:指定数据报文流出接口为docker0-j:动作为MASQUERADE(地址伪装)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面这条规则关系着docker容器和外界的通信，含义是源地址为172.17.0.0/16的数据包(即docker容器发出的数据)，当不是从docker0网卡发出时做SNAT(源地址转换)。这样使得docker容器访问外网的流量，在外界看来就是从宿主机上发出的，外界感觉不到docker容器的存在</p><h2 id="目标IP地址变换规则"><a href="#目标IP地址变换规则" class="headerlink" title="目标IP地址变换规则"></a>目标IP地址变换规则</h2><p>从docker容器访问外网的流量，在外部看来就是从宿主机上发出的，外部感觉不到docker容器的存在。其实这也是由相应的iptables规则去实现的</p><pre class="line-numbers language-shell"><code class="language-shell">docker container run -itd --name "nginx" -p 80:80 nginx:1.17<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看创建容器之后生成的iptables规则</p><pre class="line-numbers language-shell"><code class="language-shell">iptables-save | grep docker-A DOCKER ! -i docker0 -p tcp -m tcp --dport 80 -j DNAT --to-destination 172.17.0.2:80-A DOCKER -d 172.17.0.2/32 ! -i docker0 -o docker0 -p tcp -m tcp --dport 80 -j ACCEPT<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这两条规则将访问宿主机的80端口的流量转发到了172.17.0.2的80端口上(即真正提供服务的docker容器的IP+端口)，所以外界访问docker容器是通过iptables做DNAT(目的地址转换)实现的</p><h1 id="etcd-和-flannel-实现-docker-跨主机通信"><a href="#etcd-和-flannel-实现-docker-跨主机通信" class="headerlink" title="etcd 和 flannel 实现 docker 跨主机通信"></a>etcd 和 flannel 实现 docker 跨主机通信</h1><p>flannel是一种基于overlay网络的跨主机容器网络解决方案，也就是将TCP数据包封装在另一种网络包里面进行路由转发和通信，flannel是CoreOS团队针对Kubernetes设计的一个网络规划服务，让集群中的不同节点主机创建的容器都具有全集群唯一的虚拟ip地址，flannel使用go语言编写</p><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>flannel为每个host分配一个subnet，容器从这个subnet中分配ip，这些ip可以在host间路由，容器间无需使用nat和端口映射即可实现跨主机通信。每个subnet都是从一个更大的ip池中划分的，flannel会在每个主机上运行一个叫flanneld的agent，其职责就是从池子中分配subnet。etcd相当于一个数据库，flannel使用etcd存放网络配置、已分配的subnet、host的IP等信息</p><h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><table><thead><tr><th>节点</th><th>安装软件</th><th>系统</th><th>内核版本</th><th>docker版本</th></tr></thead><tbody><tr><td>10.10.110.150(master)</td><td>etcd、flannel、docker</td><td>CentOS7.7.1908</td><td>3.10.0-1062.el7.x86_64</td><td>19.03.12</td></tr><tr><td>10.10.110.151(slave)</td><td>flannel、docker</td><td>CentOS7.7.1908</td><td>3.10.0-1062.el7.x86_64</td><td>19.03.12</td></tr></tbody></table><h2 id="master节点配置"><a href="#master节点配置" class="headerlink" title="master节点配置"></a>master节点配置</h2><p>安装配置etcd</p><pre class="line-numbers language-shell"><code class="language-shell">yum install -y etcd        # 安装etcd,由于不配置etcd集群,所以只在10.10.110.150节点安装etcd就行了sed -i "s/localhost/10.10.110.150/g" /etc/etcd/etcd.conf    # 修改etcd配置文件systemctl start etcd.service    # 启动etcd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>安装配置flannel</p><pre class="line-numbers language-shell"><code class="language-shell">yum install -y flannelsed -i "s/127.0.0.1/10.10.110.150/g" /etc/sysconfig/flanneld    # flannel连接到etcd,slave连接也是填写master的IPetcdctl --endpoints="http://10.10.110.150:2379" set /atomic.io/network/config '{ "Network":"172.17.0.0/16", "Backend": {"Type": "vxlan"}} '        # 配置etcd的子网,如果这一步不配置,那么etcd无法启动systemctl start flanneld.service    # 启动flannel<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="slave节点配置"><a href="#slave节点配置" class="headerlink" title="slave节点配置"></a>slave节点配置</h2><p>安装配置flannel</p><pre class="line-numbers language-shell"><code class="language-shell">yum install -y flannelsed -i "s/127.0.0.1/10.10.110.150/g" /etc/sysconfig/flanneld    # 这里是填写master节点的IP,让slave连接到master的etcd,多slave也一样systemctl start flanneld.service    # 确保slave节点能连接到master节点的etcd,如果不关闭防火墙,那必须打开2379端口<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="配置docker使用flannel的网络"><a href="#配置docker使用flannel的网络" class="headerlink" title="配置docker使用flannel的网络"></a>配置docker使用flannel的网络</h2><p>master节点</p><pre class="line-numbers language-shell"><code class="language-shell">vim /usr/lib/systemd/system/docker.serviceEnvironmentFile=/run/flannel/docker        # 加载这个文件里面的变量,这个文件记录了flannel分配给master节点的子网信息(slave也会有自己的子网)ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock $DOCKER_NETWORK_OPTIONS    # 这个变量是上面文件中定义的,意思是在启动容器时指定使用flannel分配的子网去配置容器的网络iptables -P FORWARD ACCEPT        # 开启iptables转发,如不开启即使配置成功也不能通信systemctl daemon-reloadsystemctl restart flanneld.service    # 这里必须先重启flannel再重启docker,这时候启动容器就会使用flannel去配置容器的网络systemctl restart docker.service<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>slave节点配置</p><pre class="line-numbers language-shell"><code class="language-shell">vim /usr/lib/systemd/system/docker.serviceEnvironmentFile=/run/flannel/docker        # 查看slave节点上这个文件,网段是和master节点不一样的ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock $DOCKER_NETWORK_OPTIONSiptables -P FORWARD ACCEPTsystemctl daemon-reloadsystemctl restart flanneld.servicesystemctl restart docker.service<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="查看宿主机的IP变化"><a href="#查看宿主机的IP变化" class="headerlink" title="查看宿主机的IP变化"></a>查看宿主机的IP变化</h2><p>master节点</p><pre class="line-numbers language-shell"><code class="language-shell">ip a3: docker0: <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc noqueue state DOWN group default     link/ether 02:42:e3:89:96:4e brd ff:ff:ff:ff:ff:ff    inet 172.17.98.1/24 brd 172.17.98.255 scope global docker0       valid_lft forever preferred_lft forever4: flannel.1: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1450 qdisc noqueue state UNKNOWN group default     link/ether 02:6f:fa:71:67:f7 brd ff:ff:ff:ff:ff:ff    inet 172.17.98.0/32 scope global flannel.1       valid_lft forever preferred_lft forever    inet6 fe80::6f:faff:fe71:67f7/64 scope link        valid_lft forever preferred_lft forever    # docker0虚拟网卡和flannel虚拟网卡已经在同一网段，这时候说明配置成功<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>slave节点</p><pre class="line-numbers language-shell"><code class="language-shell">ip a3: docker0: <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc noqueue state DOWN group default     link/ether 02:42:f2:30:ba:34 brd ff:ff:ff:ff:ff:ff    inet 172.17.75.1/24 brd 172.17.75.255 scope global docker0       valid_lft forever preferred_lft forever4: flannel.1: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1450 qdisc noqueue state UNKNOWN group default     link/ether f6:ae:d1:c0:e1:a7 brd ff:ff:ff:ff:ff:ff    inet 172.17.75.0/32 scope global flannel.1       valid_lft forever preferred_lft forever    inet6 fe80::f4ae:d1ff:fec0:e1a7/64 scope link        valid_lft forever preferred_lft forever<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="在两个节点创建容器相互ping验证"><a href="#在两个节点创建容器相互ping验证" class="headerlink" title="在两个节点创建容器相互ping验证"></a>在两个节点创建容器相互ping验证</h2><p>master节点</p><pre class="line-numbers language-shell"><code class="language-shell">docker run -it busybox sh/ # ifconfigeth0      Link encap:Ethernet  HWaddr 02:42:AC:11:62:02            inet addr:172.17.98.2  Bcast:172.17.98.255  Mask:255.255.255.0          UP BROADCAST RUNNING MULTICAST  MTU:1450  Metric:1          RX packets:8 errors:0 dropped:0 overruns:0 frame:0          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0          collisions:0 txqueuelen:0           RX bytes:656 (656.0 B)  TX bytes:0 (0.0 B)lo        Link encap:Local Loopback            inet addr:127.0.0.1  Mask:255.0.0.0          UP LOOPBACK RUNNING  MTU:65536  Metric:1          RX packets:0 errors:0 dropped:0 overruns:0 frame:0          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0          collisions:0 txqueuelen:1000           RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)/ # ping 172.17.75.2PING 172.17.75.2 (172.17.75.2): 56 data bytes64 bytes from 172.17.75.2: seq=0 ttl=62 time=0.492 ms64 bytes from 172.17.75.2: seq=1 ttl=62 time=0.353 ms64 bytes from 172.17.75.2: seq=2 ttl=62 time=0.342 ms<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>slave节点</p><pre class="line-numbers language-shell"><code class="language-shell">docker run -it busybox sh/ # ifconfigeth0      Link encap:Ethernet  HWaddr 02:42:AC:11:4B:02            inet addr:172.17.75.2  Bcast:172.17.75.255  Mask:255.255.255.0          UP BROADCAST RUNNING MULTICAST  MTU:1450  Metric:1          RX packets:6 errors:0 dropped:0 overruns:0 frame:0          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0          collisions:0 txqueuelen:0           RX bytes:516 (516.0 B)  TX bytes:0 (0.0 B)lo        Link encap:Local Loopback            inet addr:127.0.0.1  Mask:255.0.0.0          UP LOOPBACK RUNNING  MTU:65536  Metric:1          RX packets:0 errors:0 dropped:0 overruns:0 frame:0          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0          collisions:0 txqueuelen:1000           RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)/ # ping 172.17.98.2PING 172.17.98.2 (172.17.98.2): 56 data bytes64 bytes from 172.17.98.2: seq=0 ttl=62 time=1.945 ms64 bytes from 172.17.98.2: seq=1 ttl=62 time=0.344 ms64 bytes from 172.17.98.2: seq=2 ttl=62 time=0.384 ms<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>注意:如果不能ping通，先重启flannel再重启docker试试</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;容器的四种网络模式&quot;&gt;&lt;a href=&quot;#容器的四种网络模式&quot; class=&quot;headerlink&quot; title=&quot;容器的四种网络模式&quot;&gt;&lt;/a&gt;容器的四种网络模式&lt;/h1&gt;&lt;h2 id=&quot;bridge-模式&quot;&gt;&lt;a href=&quot;#bridge-模式&quot; class
      
    
    </summary>
    
    
      <category term="Docker" scheme="https://www.missf.top/categories/Docker/"/>
    
    
      <category term="Docker" scheme="https://www.missf.top/tags/Docker/"/>
    
      <category term="容器技术" scheme="https://www.missf.top/tags/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/"/>
    
      <category term="云计算" scheme="https://www.missf.top/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>Docker容器数据持久化(4)</title>
    <link href="https://www.missf.top/post/a7b8d397.html"/>
    <id>https://www.missf.top/post/a7b8d397.html</id>
    <published>2020-06-19T02:14:10.000Z</published>
    <updated>2020-07-14T01:17:51.495Z</updated>
    
    <content type="html"><![CDATA[<h1 id="容器数据持久化的三种方式"><a href="#容器数据持久化的三种方式" class="headerlink" title="容器数据持久化的三种方式"></a>容器数据持久化的三种方式</h1><p>由于容器的镜像分层机制，我们在容器里面创建文件或者修改文件，结果都会保存在容器的可读写层中，一旦容器被销毁，那么这个读写层也会随着容器销毁而消失。而且当一个容器需要和其他容器的读写层进行数据交互时，也会显得非常困难。于是在将容器数据持久化到宿主机方面，docker为我们提供了三种持久化的方式</p><h2 id="volumes"><a href="#volumes" class="headerlink" title="volumes"></a>volumes</h2><p>volumes由docker负责创建、管理。用户可以显式的调用命令docker volume create创建volume，也可以通过container、service的启动隐式创建</p><p>docker创建的volumes本质上还是宿主机文件系统中的一个目录，一个volumes可以供多个容器使用，即使没有容器使用此volumes，它也不会自动删除，除非用户明确删除它</p><p>如果用户显式创建volumes则需要给它一个名称，如果是隐式创建volumes则docker会为它分配一个在宿主机范围内唯一的名字</p><p>通过使用第三方提供的volume driver，用户可以将数据持久到远程主机或者云存储中，也就是说存储空间可以不由宿主机提供</p><pre class="line-numbers language-shell"><code class="language-shell"># 创建volumesdocker volume create nginx_volumes# 查看volumesdocker volume ls# 查看卷详细信息docker volume inspect nginx_volumes [    {        "CreatedAt": "2020-06-19T18:47:49+08:00",        "Driver": "local",        "Labels": {},        "Mountpoint": "/var/lib/docker/volumes/nginx_volumes/_data",    # 这是volumes在宿主机上的真实路径        "Name": "nginx_volumes",        "Options": {},        "Scope": "local"    }]# 清理volumesdocker volume rm nginx_volumes<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将nginx容器的html目录映射到宿主机的nginx_volumes目录</p><pre class="line-numbers language-shell"><code class="language-shell"># 创建数据持久化的容器,如果卷不存在则自动创建docker container run -itd --name "nginx1" -p 80:80 -v nginx_volumes:/usr/share/nginx/html nginx:1.17    # -v方式docker container run -itd --name "nginx1" -p 80:80 --mount src=nginx_volumes,dst=/usr/share/nginx/html nginx:1.17 # --mount方式# 查看nginx_volumes在宿主机的真实目录ll /var/lib/docker/volumes/nginx_volumes/_datatotal 8-rw-r--r-- 1 root root 494 Apr 14 22:19 50x.html    # 这时候nginx容器内部的文件已经被映射到宿主机上了-rw-r--r-- 1 root root 612 Apr 14 22:19 index.html# 修改宿主机上的index.html文件echo "nginx_volumes test" > /var/lib/docker/volumes/nginx_volumes/_data/index.html# 访问宿主机的80端口(前面启动容器时将容器的80端口绑定到宿主机的80端了)curl 10.10.110.150nginx_volumes test    # nginx容器内的文件确实被修改成功<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="bind-mounts"><a href="#bind-mounts" class="headerlink" title="bind mounts"></a>bind mounts</h2><p>bind mounts本质上是容器共享宿主机文件系统，比如docker将宿主机的/etc/resov.conf文件bind mount到容器里，两者会使用相同的dns服务器</p><pre class="line-numbers language-shell"><code class="language-shell"># 创建容器,将宿主机的/nginx/app绑定到容器的/usr/share/nginx/html目录 docker container run -itd --name "nginx1" --mount type=bind,src=/nginx/app,dst=/usr/share/nginx/html nginx:1.17docker container run -itd --name "nginx1" -v /nginx/app:/usr/share/nginx/html nginx:1.17# 查看宿主机和容器的目录ls /nginx/appdocker exec -it nginx1 ls /usr/share/nginx/html        # 两个目录都为空,这是因为bind mounts是将宿主机的目录绑定到容器的目录,容器目录已有的内容会被隐藏(bind mounts以宿主机目录为主)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>注意: 如果源文件或源目录不存在，则不会自动创建。如果容器目录为非空目录，则容器目录现有内容会被宿主机目录内容所隐藏。</code></p><h2 id="tmpfs"><a href="#tmpfs" class="headerlink" title="tmpfs"></a>tmpfs</h2><p>出于安全原因，或者容器性能优化的原因有时候不需要容器的数据长久保存时可以使用这种方式。将容器数据挂载存储在宿主机的内存中，避免写入容器可写层，提高容器性能</p><h1 id="volumes-和-bind-mounts-的使用场景和区别"><a href="#volumes-和-bind-mounts-的使用场景和区别" class="headerlink" title="volumes 和 bind mounts 的使用场景和区别"></a>volumes 和 bind mounts 的使用场景和区别</h1><p>volumes适合多个容器需要共享数据、将数据保存到远程主机或云上等场景。bind mounts适合将宿主机的系统配置文件共享给容器。volumes是将容器内部的数据映射到宿主机对应的volumes目录，如果容器内部是一个非空目录，volumes目录也是一个非空目录，那么两个目录的文件会合并。而bind mounts是将宿主机上任意位置的目录或文件挂载到容器中，如果宿主机的目录非空，那么容器目录的数据将会被宿主机目录的数据隐藏，容器内的数据要卸除挂载后才会恢复</p><p>Bind mounts和volumes都可以通过使用标志-v或–volume来挂载到容器中，只是格式有些许不同。然而，在Docker17.06及其以上版本中，我们推荐使用–mount来对容器或服务进行这三种方式的挂载，因为这种格式更加清晰</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;容器数据持久化的三种方式&quot;&gt;&lt;a href=&quot;#容器数据持久化的三种方式&quot; class=&quot;headerlink&quot; title=&quot;容器数据持久化的三种方式&quot;&gt;&lt;/a&gt;容器数据持久化的三种方式&lt;/h1&gt;&lt;p&gt;由于容器的镜像分层机制，我们在容器里面创建文件或者修改文件，
      
    
    </summary>
    
    
      <category term="Docker" scheme="https://www.missf.top/categories/Docker/"/>
    
    
      <category term="Docker" scheme="https://www.missf.top/tags/Docker/"/>
    
      <category term="容器技术" scheme="https://www.missf.top/tags/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/"/>
    
      <category term="云计算" scheme="https://www.missf.top/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>Docker容器管理(3)</title>
    <link href="https://www.missf.top/post/39a5b294.html"/>
    <id>https://www.missf.top/post/39a5b294.html</id>
    <published>2020-06-17T08:23:38.000Z</published>
    <updated>2020-07-21T18:08:37.893Z</updated>
    
    <content type="html"><![CDATA[<h1 id="创建容器常用选项"><a href="#创建容器常用选项" class="headerlink" title="创建容器常用选项"></a>创建容器常用选项</h1><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>-i, –interactive</td><td>交互式</td></tr><tr><td>-t, –tty</td><td>分配一个伪终端</td></tr><tr><td>-d, –detach</td><td>运行容器到后台</td></tr><tr><td>-e, –env</td><td>设置环境变量</td></tr><tr><td>-p, –publish list</td><td>发布容器端口到主机</td></tr><tr><td>-P, –publish-all</td><td>发布容器所有EXPOSE的端口到宿主机随机端口</td></tr><tr><td>–name string</td><td>指定容器名称</td></tr><tr><td>-h, –hostname</td><td>设置容器主机名</td></tr><tr><td>–ip string</td><td>指定容器IP,只能用于自定义网络</td></tr><tr><td>–network</td><td>连接容器到一个网络</td></tr><tr><td>–mount mount</td><td>将文件系统附加到容器</td></tr><tr><td>-v, –volume list</td><td>绑定挂载一个卷</td></tr><tr><td>–restart string</td><td>容器退出时重启策略,默认no,可选值:[always<strong>|</strong>on-failure]</td></tr></tbody></table><h2 id="创建容器示例"><a href="#创建容器示例" class="headerlink" title="创建容器示例"></a>创建容器示例</h2><pre class="line-numbers language-shell"><code class="language-shell"># 启动一个nginx容器,指定名字、映射端口、设置重启# 如果不加-it分配一个交互式的伪终端,容器就会直接退出了,容器内的第一个程序必须一直处于前台运行(必须hang住)docker container run -itd --name "nginx" -p 80:80 --restart always nginx:1.17<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h1 id="容器资源限制"><a href="#容器资源限制" class="headerlink" title="容器资源限制"></a>容器资源限制</h1><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>-m，–memory</td><td>容器可以使用的最大内存量</td></tr><tr><td>–memory-swap</td><td>允许交换到磁盘的内存量</td></tr><tr><td>–memory-swappiness=&lt;0-100&gt;</td><td>容器使用SWAP分区交换的百分比(0-100，默认为-1)</td></tr><tr><td>–oom-kill-disable</td><td>禁用OOM Killer</td></tr><tr><td>–cpus</td><td>可以使用的CPU数量</td></tr><tr><td>–cpuset-cpus</td><td>限制容器使用特定的CPU核心，如(0-3, 0,1)</td></tr><tr><td>–cpu-shares</td><td>CPU共享(相对权重)</td></tr></tbody></table><h2 id="内存限额示例"><a href="#内存限额示例" class="headerlink" title="内存限额示例"></a>内存限额示例</h2><pre class="line-numbers language-shell"><code class="language-shell"># 允许容器最多使用500M内存和600M的swap,并禁用OOM Killerdocker container run -d --name "nginx1" --memory="500M" --memory-swap="600M" --oom-kill-disable nginx:1.17<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="CPU限额示例"><a href="#CPU限额示例" class="headerlink" title="CPU限额示例"></a>CPU限额示例</h2><pre class="line-numbers language-shell"><code class="language-shell"># 允许容器最多使用两个的CPUdocker container run -d --name "nginx2" --cpus="2" nginx:1.17# 允许容器最多使用50%的CPUdocker container run -d --name "nginx3" --cpus=".5" nginx:1.17<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h1 id="容器资源配额扩容"><a href="#容器资源配额扩容" class="headerlink" title="容器资源配额扩容"></a>容器资源配额扩容</h1><pre class="line-numbers language-shell"><code class="language-shell"># 容器资源可更新选项docker update --helpUsage:    docker update [OPTIONS] CONTAINER [CONTAINER...]Update configuration of one or more containersOptions:      --blkio-weight uint16        Block IO (relative weight), between 10 and 1000, or 0 to disable (default 0)      --cpu-period int             Limit CPU CFS (Completely Fair Scheduler) period      --cpu-quota int              Limit CPU CFS (Completely Fair Scheduler) quota      --cpu-rt-period int          Limit the CPU real-time period in microseconds      --cpu-rt-runtime int         Limit the CPU real-time runtime in microseconds  -c, --cpu-shares int             CPU shares (relative weight)      --cpus decimal               Number of CPUs      --cpuset-cpus string         CPUs in which to allow execution (0-3, 0,1)      --cpuset-mems string         MEMs in which to allow execution (0-3, 0,1)      --kernel-memory bytes        Kernel memory limit  -m, --memory bytes               Memory limit      --memory-reservation bytes   Memory soft limit      --memory-swap bytes          Swap limit equal to memory plus swap: '-1' to enable unlimited swap      --pids-limit int             Tune container pids limit (set -1 for unlimited)      --restart string             Restart policy to apply when a container exits# 更新正在运行中的容器内存限额docker update --memory="400M" --memory-swap="500M" --restart="on-failure" 4e860294d239<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="管理容器常用命令"><a href="#管理容器常用命令" class="headerlink" title="管理容器常用命令"></a>管理容器常用命令</h1><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>ls</td><td>列出容器</td></tr><tr><td>inspect</td><td>查看一个或多个容器详细信息</td></tr><tr><td>exec</td><td>在运行容器中执行命令</td></tr><tr><td>commit</td><td>创建一个新镜像来自一个容器</td></tr><tr><td>cp</td><td>拷贝文件/文件夹到一个容器</td></tr><tr><td>logs</td><td>获取一个容器日志</td></tr><tr><td>port</td><td>列出或指定容器端口映射</td></tr><tr><td>top</td><td>显示一个容器运行的进程</td></tr><tr><td>stats</td><td>显示容器资源使用统计</td></tr><tr><td>stop/start/restart</td><td>停止/启动一个或多个容器</td></tr><tr><td>rm</td><td>删除一个或多个容器</td></tr><tr><td>prune</td><td>移除已停止的容器</td></tr></tbody></table><h2 id="管理容器示例"><a href="#管理容器示例" class="headerlink" title="管理容器示例"></a>管理容器示例</h2><pre class="line-numbers language-shell"><code class="language-shell"># 列出真正运行的所有容器docker container ls -a# 获取一个容器日志docker container logs --tail="5" nginx        # 仅列出最新N条容器log信息docker container logs -f nginx        # 跟踪log信息输出docker logs --since="2020-06-18" --tail="10" nginx      # 显示某个时间之后的最新十条log信息# 进入正在运行的容器中执行命令docker container exec -it nginx /bin/bash# 显示一个容器运行的进程docker container top nginx# 删除一个或删除全部容器docker container rm -f nginxdocker container rm -f $(docker container ls -q)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="容器实现核心技术-Namespace"><a href="#容器实现核心技术-Namespace" class="headerlink" title="容器实现核心技术: Namespace"></a>容器实现核心技术: Namespace</h1><p>在容器化中，一台物理计算机可以运行多个不同操作系统(一个容器就类似于一个系统)，那就需要解决”隔离性”，让彼此感知不到对方的存在，出现问题也互不影响</p><p>Linux内核从2.4.19版本开始引入了namespace概念，其目的是将特定的全局系统资源通过抽象方法使得namespace中的进程看起来拥有自己隔离的资源。Docker就是借助这个机制实现了容器资源隔离</p><p>Linux的namespace机制提供了6种不同的命名空间:</p><p>IPC: 隔离进程间通信</p><p>MOUNT: 隔离文件系统挂载点</p><p>NET: 隔离网络协议栈</p><p>PID: 隔离进程号，容器命名空间对父进程空间可见</p><p>USER: 隔离用户</p><p>UTS: 隔离主机名和域名</p><h1 id="容器实现核心技术-CGroups"><a href="#容器实现核心技术-CGroups" class="headerlink" title="容器实现核心技术: CGroups"></a>容器实现核心技术: CGroups</h1><p>Docker利用namespace实现了容器之间资源隔离，但是namespace不能对容器资源限制，比如CPU、内存。如果某一个容器属于CPU密集型任务，那么会影响其他容器使用CPU，导致多个容器相互影响并且抢占资源。如何对多个容器的资源使用进行限制就成了容器化的主要问题。所以容器引入了Control Groups(简称CGroups)，限制容器资源</p><p>CGroups 以某种标准讲一组进程为目标进行资源分配和控制，例如CPU、内存、带宽等，并且可以动态配置:</p><p>限制进程组使用的资源数量(Resource limitation ):可以为进程组设定资源使用上限，例如内存</p><p>进程组优先级控制( Prioritization):可以为进程组分配特定CPU、磁盘IO吞吐量</p><p>记录进程组使用的资源数量(Accounting ):例如使用记录某个进程组使用的CPU时间</p><p>进程组控制(Control ):可以将进程组挂起和恢复</p><h2 id="查看cgroups可控制的资源"><a href="#查看cgroups可控制的资源" class="headerlink" title="查看cgroups可控制的资源"></a>查看cgroups可控制的资源</h2><table><thead><tr><th>资源</th><th>描述</th></tr></thead><tbody><tr><td>blkio</td><td>对块设备的IO进行限制</td></tr><tr><td>cpu</td><td>限制CPU时间片的分配，与cpuacct挂载同一目录</td></tr><tr><td>cpuacct</td><td>生成cgroup中的任务占用CPU资源的报告，与cpu挂载同一目录</td></tr><tr><td>cpuset</td><td>给cgroup中的任务分配独立的CPU(多核处理器)和内存节点</td></tr><tr><td>devices</td><td>允许或者拒绝 cgroup 中的任务访问设备</td></tr><tr><td>freezer</td><td>暂停/恢复 cgroup 中的任务</td></tr><tr><td>hugetlb</td><td>限制使用的内存页数量</td></tr><tr><td>memory</td><td>对cgroup中任务的可用内存进行限制，并自动生成资源占用报告</td></tr><tr><td>net_cls</td><td>使用等级识别符(classid)标记网络数据包，这让 Linux 流量控制程序(tc)可以识别来自特定从cgroup任务的数据包，并进行网络限制</td></tr><tr><td>net_prio</td><td>允许基于cgroup设置网络流量的优先级</td></tr><tr><td>perf_event</td><td>允许使用perf工具来监控cgroup</td></tr><tr><td>pids</td><td>限制任务的数量</td></tr></tbody></table><h2 id="资源控制在容器中的实际位置"><a href="#资源控制在容器中的实际位置" class="headerlink" title="资源控制在容器中的实际位置"></a>资源控制在容器中的实际位置</h2><pre class="line-numbers language-shell"><code class="language-shell">ll /sys/fs/cgroup/"资源名"/docker/"容器ID"/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="Docker核心组件之间关系"><a href="#Docker核心组件之间关系" class="headerlink" title="Docker核心组件之间关系"></a>Docker核心组件之间关系</h1><p>我们使用docker client运行一个容器，其实容器运行时底层是需要依赖一系列组件的，我们完全可以通过调用这些组件去启动一个容器，而不使用docker引擎的方式去启动。主要的组件有docker client、docker daemon、containerd、container-shim、runC</p><h2 id="docker-client"><a href="#docker-client" class="headerlink" title="docker client"></a>docker client</h2><p>docker客户端程序，负责发送用户的请求给docker daemon</p><h2 id="docker-daemon"><a href="#docker-daemon" class="headerlink" title="docker daemon"></a>docker daemon</h2><p>docker daemon守护进程，也称docker engine，负责处理docker client的请求，并返回处理结果</p><h2 id="containerd"><a href="#containerd" class="headerlink" title="containerd"></a>containerd</h2><p>containerd是一个工业级标准的容器运行时，它强调简单性、健壮性和可移植性。Containerd可以在宿主机中管理完整的容器生命周期:容器镜像的传输和存储、容器的执行和管理、存储和网络等。为docker daemon提供接口去管理容器，docker对容器的管理和操作基本都是通过containerd完成的。但是要注意的是:containerd被设计成嵌入到一个更大的系统中，而不是直接由开发人员或终端用户使用</p><h2 id="container-shim"><a href="#container-shim" class="headerlink" title="container-shim"></a>container-shim</h2><p>container-shim是containerd的组件，是容器的运行时载体，我们在docker宿主机上看到的shim也正是代表着一个个通过调用containerd启动的docker容器</p><pre class="line-numbers language-shell"><code class="language-shell">ps axf | grep docker -A 110191 ?        Sl     0:01  \_ containerd-shim -namespace moby -workdir /var/lib/containerd/io.containerd.runtime.v1.linux/moby/4dffa5d5861899400770d6470618e4e051c5f1bf0c53034999b13821fc3fe93f -address /run/containerd/containerd.sock -containerd-binary /usr/bin/containerd -runtime-root /var/run/docker/runtime-runc10208 ?        Ss     0:00      \_ nginx: master process nginx -g daemon off;--4215 ?        Ssl    2:06 /usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="runC"><a href="#runC" class="headerlink" title="runC"></a>runC</h2><p>RunC 是一个轻量级的工具，它是用来运行容器的。我们可以认为它就是个命令行小工具，可以不用通过 docker 引擎，直接运行容器。事实上runC 是标准化的产物，它根据 OCI 标准来创建和运行容器。而 <a href="https://www.opencontainers.org/" target="_blank" rel="noopener">OCI(Open Container Initiative)</a>组织，旨在围绕容器格式和运行时制定一个开放的工业化标准</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;创建容器常用选项&quot;&gt;&lt;a href=&quot;#创建容器常用选项&quot; class=&quot;headerlink&quot; title=&quot;创建容器常用选项&quot;&gt;&lt;/a&gt;创建容器常用选项&lt;/h1&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;选项&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr
      
    
    </summary>
    
    
      <category term="Docker" scheme="https://www.missf.top/categories/Docker/"/>
    
    
      <category term="Docker" scheme="https://www.missf.top/tags/Docker/"/>
    
      <category term="容器技术" scheme="https://www.missf.top/tags/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/"/>
    
      <category term="云计算" scheme="https://www.missf.top/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>Docker镜像管理(2)</title>
    <link href="https://www.missf.top/post/ce2c2968.html"/>
    <id>https://www.missf.top/post/ce2c2968.html</id>
    <published>2020-06-16T07:00:10.000Z</published>
    <updated>2020-07-28T08:32:00.380Z</updated>
    
    <content type="html"><![CDATA[<h1 id="镜像概述"><a href="#镜像概述" class="headerlink" title="镜像概述"></a>镜像概述</h1><p>镜像是一个分层存储的文件</p><p>镜像就是一个软件的运行环境</p><p>一个镜像可以重复使用，创建无数个容器</p><p>一个不包含Linux内核而又精简的Linux操作系统</p><p>镜像是一种标准化的交付，镜像内包含代码以及软件的运行环境</p><h1 id="配置镜像加速"><a href="#配置镜像加速" class="headerlink" title="配置镜像加速"></a>配置镜像加速</h1><p>阿里云为每一个开通容器镜像服务的用户免费提供一个镜像加速地址</p><pre class="line-numbers language-shell"><code class="language-shell"># 配置镜像加速tee /etc/docker/daemon.json << EOF{    "registry-mirrors": ["https://265wemgl.mirror.aliyuncs.com"]}EOFsystemctl daemon-reloadsystemctl restart docker.service<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h1><p>我们拉取镜像一般是默认从Docker Hub拉取的，但是国内访问Docker Hub速度很慢，所以我们在前面配置了阿里云的镜像加速。在拉取镜像时，直接从阿里云的docker镜像仓库拉取。我们假如要拉取一个镜像，但是不知道仓库中是否有这个镜像时，我们可以先搜索这个镜像名字，看是否有对应的镜像</p><pre class="line-numbers language-shell"><code class="language-shell"># 搜索镜像docker search nginx# 拉取镜像,如果不指定版本号,默认拉取最新(latest)docker pull nginx:1.17<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>镜像拉取到宿主机本地之后，会以分层的文件形式存储，下面是镜像的存放目录</p><pre class="line-numbers language-shell"><code class="language-shell">[root@localhost ~]# ll /var/lib/docker/overlay2/total 0drwx------ 4 root root     55 Jun 17 19:04 5f4badc01c88554e78d4aaec269a84fb5e2028d42278d5f131dda81c4209622cdrwx------ 3 root root     47 Jun 17 19:04 658e3b564ce9017b0bd507f1853702f6cdda4642fdc6fbf4b4d06e34cf9a8c25drwx------ 3 root root     30 Jun 17 19:09 6d57028d1a60a66afc6959b02e0005ea424182908fadf6aa5ac90f3868c014f7brw------- 1 root root 253, 0 Jun 17 18:31 backingFsBlockDevdrwx------ 4 root root     72 Jun 17 19:04 d56648ebd71c9bdb68226b4021ec008db3ed537072b3c4f9e77afc51f8108c07drwx------ 2 root root    142 Jun 17 19:09 l<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="镜像与容器的联系"><a href="#镜像与容器的联系" class="headerlink" title="镜像与容器的联系"></a>镜像与容器的联系</h1><p>当启动一个新容器时，docker只加载只读镜像，并在这个只读镜像上面添加一个读写层，即容器层。但我们需要修改容器里面的文件时，会先从镜像层把这个文件拷贝到读写层，然后再执行修改操作</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://pic.imgdb.cn/item/5ee9acc8a240b370e3c19f7e.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="镜像存储核心技术-联合文件系统-UnionFS"><a href="#镜像存储核心技术-联合文件系统-UnionFS" class="headerlink" title="镜像存储核心技术:联合文件系统(UnionFS)"></a>镜像存储核心技术:联合文件系统(UnionFS)</h1><p>联合文件系统（UnionFS）是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下(uniteseveral directories into a single virtual filesystem)。联合文件系统是 Docker 镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。另外，不同 Docker 容器就可以共享一些基础的文件系统层，同时再加上自己独有的改动层，大大提高了存储的效率</p><p>Docker 中使用的 AUFS（AnotherUnionFS）就是一种联合文件系统。 AUFS 支持为每一个成员目录（类似 Git 的分支）设定只读（readonly）、读写（readwrite）和写出（whiteout-able）权限, 同时 AUFS 里有一个类似分层的概念, 对只读权限的分支可以逻辑上进行增量地修改(不影响只读部分的)</p><p>Docker 目前支持的联合文件系统包括 OverlayFS , AUFS , Btrfs , VFS , ZFS 和 DeviceMapper </p><h1 id="镜像存储核心技术-写时复制-COW"><a href="#镜像存储核心技术-写时复制-COW" class="headerlink" title="镜像存储核心技术:写时复制(COW)"></a>镜像存储核心技术:写时复制(COW)</h1><p>docker镜像由多个只读层叠加而成，启动容器时，docker会加载只读镜像层并在镜像层顶部添加一个读写层。如果运行中的容器修改了一个已存在的文件，那么该文件将会从只读层复制到读写层，该文件的只读版本任然存在，只是已经被读写层中该文件的副本所隐藏，这就是写时复制机制</p><h1 id="镜像常用管理命令"><a href="#镜像常用管理命令" class="headerlink" title="镜像常用管理命令"></a>镜像常用管理命令</h1><pre class="line-numbers language-shell"><code class="language-shell"># 列出镜像,-a显示所有镜像docker image ls# 在当前目录通过Dockerfile构建镜像docker build -t "nginx_tomcat" .# 查看镜像历史docker image history nginx:1.17# 显示镜像的详细信息docker inspect nginx:1.17# 从镜像仓库拉取镜像docker pull nginx:1.17# 推送镜像到镜像仓库docker pull centos:7.6.1810# 移除一个或多个镜像docker image rm centos    docker image rm $(docker image ls -q)    # 删除全部镜像# 删除没有被标记或没有被任何容器引用的镜像docker image prune -af# 创建一个引用源镜像标记目标镜像docker tag centos:latest coentos:v1        # 为centos:latest这个镜像打一个标签为coentos:v1# 导出容器文件系统为tar归档文件docker export -o centos-export.tar [CONTAINER ID]# 导入容器文件系统tar归档文件来创建镜像docker import centos-export.tar# 保存一个或多个镜像到一个tar归档文件docker save -o database.tar redis mysql# 加载镜像来自tar归档或标准输入docker load -i database.tar<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>相信许多的初学者看到这里肯定有疑问，这里说明一下export &amp; import和save &amp; load的区别在哪里</p><h2 id="export-amp-import"><a href="#export-amp-import" class="headerlink" title="export &amp; import"></a>export &amp; import</h2><p>export的应用场景主要用来制作基础镜像，比如你从一个centos镜像启动一个容器，然后安装一些软件和进行一些设置后，使用docker export保存为一个基础镜像。然后把这个镜像分发给其他人使用，比如作为基础的开发环境</p><pre class="line-numbers language-shell"><code class="language-shell">export:将容器导出为tar归档文件,生成的是该容器的快照，复刻了容器当前的Linux系统环境import:将tar归档文件导入为镜像整个过程即:容器-->tar归档文件-->镜像<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="save-amp-load"><a href="#save-amp-load" class="headerlink" title="save &amp; load"></a>save &amp; load</h2><p>如果你的应用是使用docker-compose.yml编排的多个镜像组合，但你要部署的客户服务器并不能连外网。这时，你可以使用docker save将用到的镜像打个包，然后拷贝到客户服务器上使用docker load载入</p><pre class="line-numbers language-shell"><code class="language-shell">save:将镜像导出为tar归档文件,该命令也可以作用于容器,但导出的是容器背后的imagesload:将tar归档文件导入为镜像<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>注意: save命令生成的tar包比export命令生成的tar包大很多，两组命令不可交叉互用</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;镜像概述&quot;&gt;&lt;a href=&quot;#镜像概述&quot; class=&quot;headerlink&quot; title=&quot;镜像概述&quot;&gt;&lt;/a&gt;镜像概述&lt;/h1&gt;&lt;p&gt;镜像是一个分层存储的文件&lt;/p&gt;
&lt;p&gt;镜像就是一个软件的运行环境&lt;/p&gt;
&lt;p&gt;一个镜像可以重复使用，创建无数个容器&lt;/p
      
    
    </summary>
    
    
      <category term="Docker" scheme="https://www.missf.top/categories/Docker/"/>
    
    
      <category term="Docker" scheme="https://www.missf.top/tags/Docker/"/>
    
      <category term="容器技术" scheme="https://www.missf.top/tags/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/"/>
    
      <category term="云计算" scheme="https://www.missf.top/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>Docker核心概念与安装(1)</title>
    <link href="https://www.missf.top/post/f7aff4ce.html"/>
    <id>https://www.missf.top/post/f7aff4ce.html</id>
    <published>2020-06-15T02:56:03.000Z</published>
    <updated>2020-07-14T01:03:22.575Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么使用容器"><a href="#为什么使用容器" class="headerlink" title="为什么使用容器"></a>为什么使用容器</h1><p>提供简单轻量的建模方式，非常容易上手，运行速度非常快</p><p>使开发和运维的职责分离，开发只需要关心容器中的程序，运维只需要管理容器</p><p>快速高效的开发生命周期，开发环境和生产环境一致，避免了额外的调试有效缩短上线时间</p><p>鼓励使用面向服务的架构，docker推荐单个容器只运行一个应用程序，使分布式扩展和调试变得简单</p><h1 id="Docker-是什么"><a href="#Docker-是什么" class="headerlink" title="Docker 是什么"></a>Docker 是什么</h1><h2 id="容器技术"><a href="#容器技术" class="headerlink" title="容器技术"></a>容器技术</h2><p>想要了解docker，首先要知道什么是容器。最早的容器技术来自于BSD的jail技术(jail一词是监狱的意思，这个技术的隔离思想来源于监狱的启发)，目的就是为了实现进程隔离，使得一个进程被攻陷后不会影响到其他进程，这是出于安全的目的。</p><h2 id="使用最为广泛的开源容器引擎"><a href="#使用最为广泛的开源容器引擎" class="headerlink" title="使用最为广泛的开源容器引擎"></a>使用最为广泛的开源容器引擎</h2><p>在近几年来，docker是一个非常火的名词。事实上docker只是众多容器引擎其中一款优秀的容器引擎，但是它却几乎成为了容器的代名词。许多业外人士觉得docker就是容器，这里大家要明白，docker只是属于容器技术的一种。</p><h2 id="容器是一种操作系统级别的虚拟化技术"><a href="#容器是一种操作系统级别的虚拟化技术" class="headerlink" title="容器是一种操作系统级别的虚拟化技术"></a>容器是一种操作系统级别的虚拟化技术</h2><p>使用docker创建的容器，以特殊进程的方式在宿主机上运行，运行一个容器就像运行一个进程一样，宿主机上可以运行多个容器，容器间的资源是互相隔离的。</p><h2 id="依赖于Linux内核特性-Namespace-amp-Cgroups"><a href="#依赖于Linux内核特性-Namespace-amp-Cgroups" class="headerlink" title="依赖于Linux内核特性 Namespace &amp; Cgroups"></a>依赖于Linux内核特性 Namespace &amp; Cgroups</h2><p>容器之间运行的是一个隔离的环境，也可以理解类似于一个沙盒，使用Namespace进行资源的隔离，使用Cgroups进行资源的控制。</p><h1 id="Docker-基本组成"><a href="#Docker-基本组成" class="headerlink" title="Docker 基本组成"></a>Docker 基本组成</h1><h2 id="Docker-Client-客户端"><a href="#Docker-Client-客户端" class="headerlink" title="Docker Client 客户端"></a>Docker Client 客户端</h2><p>docker采用C/S架构</p><p>docker客户端和docker服务器之间的通信访问可以是本地方式也可以是远程方式</p><p>docker客户端向守护进程发送请求，守护进程的执行结果会传回给客户端</p><h2 id="Docker-Daemon-守护进程"><a href="#Docker-Daemon-守护进程" class="headerlink" title="Docker Daemon 守护进程"></a>Docker Daemon 守护进程</h2><p>docker采用C/S架构</p><p>docker客户端和docker服务器之间的通信访问可以是本地方式也可以是远程方式</p><p>docker客户端向守护进程发送请求，守护进程的执行结果会传回给客户端</p><h2 id="Docker-Image-镜像"><a href="#Docker-Image-镜像" class="headerlink" title="Docker Image 镜像"></a>Docker Image 镜像</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://pic.imgdb.cn/item/5ee713d4c2a9a83be5ea9ce7.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>镜像是容器的基石，镜像包含了容器启动的一切条件，容器基于镜像去启动。镜像是层叠的只读文件系统，底层是bootfs引导文件系统，rootfs文件系统永远是只读状态，使用同一个镜像无论启动多少个容器，或者容器被如何修改，镜像都不会被改变。一个镜像可以放到一个镜像的顶部，最下面的镜像称为基础镜像，就是图中的centos/Ubuntu层。这里使用了写时复制技术(copy on write)，即通过一个镜像启动一个容器实例，这个镜像是以只读形式挂载的，即不允许任何修改操作，当在容器实例中修改一个文件时，会首先从镜像里把这个文件拷贝到可写层，然后执行更新操作。</p><h2 id="Docker-Container-容器"><a href="#Docker-Container-容器" class="headerlink" title="Docker Container 容器"></a>Docker Container 容器</h2><p>容器通过镜像启动</p><p>docker守护进程执行命令就是在容器实例中执行</p><p>应用部署在容器中</p><p>在启动容器时会在镜像的最上层创建一个读写层，读写层加上下面的多个只读层从而构成一个容器</p><h2 id="Docker-Registry-仓库"><a href="#Docker-Registry-仓库" class="headerlink" title="Docker Registry 仓库"></a>Docker Registry 仓库</h2><p>随着我们项目的增加，我们构建的镜像也会越来越多。而镜像也是像代码一样的，需要一个镜像仓库来进行管理的，镜像仓库里面保存着我们构建的镜像。镜像仓库还分为公有仓库和私有仓库。公有仓库一般指<a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker Hub</a>，Docker Hub 是一个由 Docker 公司运行和管理的基于云的存储库，它是一个在线存储库，Docker 镜像可以由其他用户发布和使用。而私有仓库一般是我们公司的组织内部拥有的一个私有仓库，仅允许公司内部用户使用。</p><h2 id="容器的关系图"><a href="#容器的关系图" class="headerlink" title="容器的关系图"></a>容器的关系图</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://pic.imgdb.cn/item/5ee6faeec2a9a83be5c7194e.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="容器-VS-虚拟机"><a href="#容器-VS-虚拟机" class="headerlink" title="容器 VS 虚拟机"></a>容器 VS 虚拟机</h1><p>虚拟机是系统级别的虚拟化，而容器是进程级别的虚拟化，这是虚拟机和容器最核心的区别。虚拟机提供了物理机硬件级别的操作系统隔离，使用虚拟机部署应用，除了应用和应用依赖的库文件，还需要虚拟完整的操作系统，每个虚拟机拥有自己独立的内核，这会大量占用系统的硬件资源。而容器是进程级别的虚拟化，当我们运行docker容器时，此时容器本身只是操作系统中的一个进程，利用了Linux系统的内核特性(Namespace &amp; Cgroups)实现了进程之间网络、空间、权限等隔离，使多个容器进程互相不知道彼此的存在。在这个追求速度的互联网时代，容器在许多方面要比虚拟机优秀。但是不意味着传统的虚拟机技术就过时了，虚拟机的操作系统级别隔离是容器无法替代的，容器的意义在于运行单个应用，如果在容器里面添加越来越多的功能，那不如一开始就直接使用虚拟机。</p><h2 id="虚拟技术的核心区别"><a href="#虚拟技术的核心区别" class="headerlink" title="虚拟技术的核心区别"></a>虚拟技术的核心区别</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://pic.imgdb.cn/item/5ee8394d2cb53f50fe53b66c.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="容器-VS-虚拟机详细对比"><a href="#容器-VS-虚拟机详细对比" class="headerlink" title="容器 VS 虚拟机详细对比"></a>容器 VS 虚拟机详细对比</h2><table><thead><tr><th></th><th><strong>Container</strong></th><th><strong>VM</strong></th></tr></thead><tbody><tr><td><strong>启动速度</strong></td><td>秒级</td><td>分钟级</td></tr><tr><td><strong>运行性能</strong></td><td>接近原生</td><td>5%左右损失</td></tr><tr><td><strong>磁盘占用</strong></td><td>MB</td><td>GB</td></tr><tr><td><strong>数量</strong></td><td>成百上千</td><td>一般几十台</td></tr><tr><td><strong>隔离性</strong></td><td>进程级</td><td>系统级(更彻底)</td></tr><tr><td><strong>操作系统</strong></td><td>主要支持Linux</td><td>几乎所有</td></tr><tr><td><strong>封装程度</strong></td><td>只打包项目代码和依赖关系，共享宿主机内核</td><td>完整的操作系统</td></tr></tbody></table><h1 id="Docker应用场景"><a href="#Docker应用场景" class="headerlink" title="Docker应用场景"></a>Docker应用场景</h1><p>应用程序打包和发布</p><p>应用程序环境隔离</p><p>持续集成</p><p>部署微服务</p><p>快速搭建测试环境</p><p>提供Pass产品(平台即服务)</p><h1 id="Linux-安装-Docker"><a href="#Linux-安装-Docker" class="headerlink" title="Linux 安装 Docker"></a>Linux 安装 Docker</h1><pre class="line-numbers language-shell"><code class="language-shell"># 安装依赖包yum install -y yum-utils device-mapper-persistent-data lvm2# 添加Docker软件源yum-config-manager \--add-repo \https://download.docker.com/linux/centos/docker-ce.repo# 安装Docker CEyum install -y docker-ce# 启动Docker服务并设置开机启动systemctl start dockersystemctl enable docker# 查看docker版本docker --versionDocker version 19.03.11, build 42e35e61f3# 查看更详细的信息docker info<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;为什么使用容器&quot;&gt;&lt;a href=&quot;#为什么使用容器&quot; class=&quot;headerlink&quot; title=&quot;为什么使用容器&quot;&gt;&lt;/a&gt;为什么使用容器&lt;/h1&gt;&lt;p&gt;提供简单轻量的建模方式，非常容易上手，运行速度非常快&lt;/p&gt;
&lt;p&gt;使开发和运维的职责分离，开发只需
      
    
    </summary>
    
    
      <category term="Docker" scheme="https://www.missf.top/categories/Docker/"/>
    
    
      <category term="Docker" scheme="https://www.missf.top/tags/Docker/"/>
    
      <category term="容器技术" scheme="https://www.missf.top/tags/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/"/>
    
      <category term="云计算" scheme="https://www.missf.top/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>ansible的jinja2模板(16)</title>
    <link href="https://www.missf.top/post/62ac8f71.html"/>
    <id>https://www.missf.top/post/62ac8f71.html</id>
    <published>2020-06-10T12:56:59.000Z</published>
    <updated>2020-07-14T06:29:45.252Z</updated>
    
    <content type="html"><![CDATA[<p><strong>我曾踏足山巅，也曾进入低谷，二者都让我受益良多。</strong></p><p>​                                                                                                                                                                      <strong>——塔里克</strong></p><h1 id="ansible的jinja2模板"><a href="#ansible的jinja2模板" class="headerlink" title="ansible的jinja2模板"></a>ansible的jinja2模板</h1><p>我们在多个管理节点部署服务时，很多服务的配置文件都是需要监听服务所在主机的IP地址，这时候就需要使用到ansible的jinja2模板去分发动态的配置文件。我们先创建一份模板文件，将IP配置部分使用ansible变量进行替换，然后使用template模块对模版文件进行渲染，将根据我们定义的变量而生成不同的配置文件发送到对应的管理节点</p><p>下面我们以安装redis为示例，为不同的管理节点分发动态配置文件</p><pre class="line-numbers language-shell"><code class="language-shell">cat /etc/redis/conf/redis.confbind {{ ansible_host }}     # 将默认的127.0.0.1改为管理节点本机的IP，这样就能生成各自的管理节点的配置文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>准备模板配置文件之后，下面就来编写一个playbook，完成模板配置文件的渲染和分发</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token punctuation">-</span> <span class="token key atrule">hosts</span><span class="token punctuation">:</span> all  <span class="token key atrule">remote_user</span><span class="token punctuation">:</span> root  <span class="token key atrule">tasks</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">template</span><span class="token punctuation">:</span>      <span class="token key atrule">src</span><span class="token punctuation">:</span> /root/playbook/redis.conf    <span class="token comment" spellcheck="true"># 控制节点上的模板文件,定义好变量,通过template模块进行渲染</span>      <span class="token key atrule">dest</span><span class="token punctuation">:</span> /etc/redis.conf        <span class="token comment" spellcheck="true"># 管理节点上这个文件将被控制节点上的模板文件所替换</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="jinja2语法"><a href="#jinja2语法" class="headerlink" title="jinja2语法"></a>jinja2语法</h1><p>Ansible使用<a href="https://jinja.palletsprojects.com/" target="_blank" rel="noopener">Jinja2</a>模板来启用动态表达式和对变量的访问，就是说ansible使用Jinja模板对含有动态表达式和变量的文件进行解析个渲染</p><h2 id="变量-amp-表达式"><a href="#变量-amp-表达式" class="headerlink" title="变量&amp;表达式"></a>变量&amp;表达式</h2><p>可以使用点.来访问变量的属性，也可以使用下标语法[]，下面2种方式效果是一样的</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token punctuation">{</span><span class="token punctuation">{</span> foo.bar <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token punctuation">{</span> foo<span class="token punctuation">[</span><span class="token string">'bar'</span><span class="token punctuation">]</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true"># 如果变量或属性不存在，会返回一个未定义值。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>除了变量， {{}} 中还可以包含一些表达式</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token punctuation">{</span><span class="token punctuation">{</span> 1 == 1 <span class="token punctuation">}</span><span class="token punctuation">}</span>    <span class="token punctuation">{</span><span class="token punctuation">{</span> 2 <span class="token tag">!=</span> 3 <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token punctuation">{</span> 2 <span class="token punctuation">></span> 3 <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token punctuation">{</span> 4 &lt;= 3 <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true"># 根据对应的表达式返回true或false</span><span class="token punctuation">{</span><span class="token punctuation">{</span> 3 + 2 <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token punctuation">{</span> 3 <span class="token punctuation">-</span> <span class="token number">4 </span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token punctuation">{</span> 3 * 5 <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token punctuation">{</span> 2 ** 3 <span class="token punctuation">}</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true"># 2的3次方</span><span class="token comment" spellcheck="true"># 根据算术运算返回结果</span><span class="token comment" spellcheck="true"># 字符串、数值、列表、元组、字典、布尔值等数据类型均可在"{{  }}"使用</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="控制"><a href="#控制" class="headerlink" title="控制"></a>控制</h2><p>用来装载控制语句，比如 if 控制结构，for循环控制结构</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token punctuation">{</span>% for item in seq %<span class="token punctuation">}</span>```<span class="token comment" spellcheck="true">## 注释</span>要把模板中一行的部分注释掉```yaml<span class="token punctuation">{</span><span class="token comment" spellcheck="true"># 这是被注释的内容 #}</span>```<span class="token comment" spellcheck="true">## 转义</span>简单的使用单引号('')进行转义，对于较大的段落，使用raw进行转义```yaml<span class="token punctuation">{</span>% raw %<span class="token punctuation">}</span>     &lt;ul<span class="token punctuation">></span>     <span class="token punctuation">{</span>% for item in seq %<span class="token punctuation">}</span>         &lt;li<span class="token punctuation">></span><span class="token punctuation">{</span><span class="token punctuation">{</span> item <span class="token punctuation">}</span><span class="token punctuation">}</span>&lt;/li<span class="token punctuation">></span>     <span class="token punctuation">{</span>% endfor %<span class="token punctuation">}</span>     &lt;/ul<span class="token punctuation">></span> <span class="token punctuation">{</span>% endraw %<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="执行命令时传入变量"><a href="#执行命令时传入变量" class="headerlink" title="执行命令时传入变量"></a>执行命令时传入变量</h2><pre class="line-numbers language-shell"><code class="language-shell">cat /root/test.j2my blog is {{ site }}ansible dbserver -m template -e "site=missf.top" -a "src=/root/test.j2 dest=/opt/test"cat /opt/testmy blog is missf.top<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="if"><a href="#if" class="headerlink" title="if"></a>if</h2><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token punctuation">{</span>% if num <span class="token punctuation">></span> 3 %<span class="token punctuation">}</span>gtfr derew pllu<span class="token punctuation">{</span>% endif %<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>使用template模板进行渲染</p><pre class="line-numbers language-shell"><code class="language-shell">ansible dbserver -m template -e "num=4" -a "src=/root/test.j2 dest=/opt/test"# 渲染后的输出结果cat /opt/testgtfr derew pllu<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><p>jinja2模板的for语法示例</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token punctuation">{</span>% if num <span class="token punctuation">></span> 3 %<span class="token punctuation">}</span><span class="token punctuation">{</span>% for i in <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">65</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">23</span><span class="token punctuation">]</span> %<span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token punctuation">{</span> i <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">{</span>% endfor %<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>使用template模板进行渲染</p><pre class="line-numbers language-shell"><code class="language-shell">ansible dbserver -m template -a "src=/root/test.j2 dest=/opt/test"# 渲染后的输出结果cat /opt/test565723<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="控制空白"><a href="#控制空白" class="headerlink" title="控制空白"></a>控制空白</h2><p>从for循环的结果看出，使用template模板进行渲染时不会去处理空格或者换行符，在开始或结束放置一个减号(-)，可以移除块前或块后的空白</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token punctuation">{</span>% for i in <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">65</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">23</span><span class="token punctuation">]</span> <span class="token punctuation">-</span>%<span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token punctuation">{</span> i <span class="token punctuation">}</span><span class="token punctuation">}</span>        <span class="token comment" spellcheck="true"># 这里可以使用{{ i }}{{' '}}定义分割符</span><span class="token punctuation">{</span>%<span class="token punctuation">-</span> endfor %<span class="token punctuation">}</span>ansible dbserver <span class="token punctuation">-</span>m template <span class="token punctuation">-</span>a "src=/root/test.j2 dest=/opt/test"cat /opt/test565723        <span class="token comment" spellcheck="true"># 将换行符和空白都移除了</span>5 65 7 23    <span class="token comment" spellcheck="true"># 定义分割符的效果</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    我要去重新学习梳理Docker了，Ansible就先到这里吧！等到有空了，再重启吧</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;我曾踏足山巅，也曾进入低谷，二者都让我受益良多。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​                                                                                       
      
    
    </summary>
    
    
      <category term="ansible" scheme="https://www.missf.top/categories/ansible/"/>
    
    
      <category term="ansible" scheme="https://www.missf.top/tags/ansible/"/>
    
      <category term="自动化运维" scheme="https://www.missf.top/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>ansible的include(15)</title>
    <link href="https://www.missf.top/post/fa9ef74f.html"/>
    <id>https://www.missf.top/post/fa9ef74f.html</id>
    <published>2020-06-10T11:56:59.000Z</published>
    <updated>2020-07-14T06:29:06.501Z</updated>
    
    <content type="html"><![CDATA[<p><strong>我曾踏足山巅，也曾进入低谷，二者都让我受益良多。</strong></p><p>​                                                                                                                                                                      <strong>——塔里克</strong></p><h1 id="ansible的include"><a href="#ansible的include" class="headerlink" title="ansible的include"></a>ansible的include</h1><p>在所有的编程语言中，在处理重复代码的时候，都会将重复的代码提取出来作为一个逻辑单元，这个逻辑单元通常被称为函数或者方法，这样可以让我们更加方便的、重复的调用这段代码。而且如果需要修改这段代码，只需要修改这段代码本身，那么在调用这段代码的地方的逻辑就会随之改变。同时，使用函数的方式编写代码，能让我们的逻辑更清晰，通过函数的名称，大概能推算出程序的主体作用和逻辑</p><p>在ansible中，其实也有类似的功能，这种功能被称之为include。通过include，我们可以在playbook中包含另一个文件，以便实现我们刚才所说的函数效果</p><p>在配置环境的时候，我们经常会有一些需要重复使用的playbook，就像下面的LAMP环境和LNMP环境</p><pre class="line-numbers language-yaml"><code class="language-yaml">cat lamp.yaml <span class="token punctuation">---</span><span class="token punctuation">-</span> <span class="token key atrule">hosts</span><span class="token punctuation">:</span> dbserver  <span class="token key atrule">remote_user</span><span class="token punctuation">:</span> root  <span class="token key atrule">tasks</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> install lamp      <span class="token key atrule">yum</span><span class="token punctuation">:</span>        <span class="token key atrule">name</span><span class="token punctuation">:</span>          <span class="token punctuation">-</span> mysql          <span class="token punctuation">-</span> php<span class="token punctuation">-</span>fpm          <span class="token punctuation">-</span> httpd        <span class="token key atrule">state</span><span class="token punctuation">:</span> presentcat lnmp.yaml <span class="token punctuation">---</span><span class="token punctuation">-</span> <span class="token key atrule">hosts</span><span class="token punctuation">:</span> dbserver  <span class="token key atrule">remote_user</span><span class="token punctuation">:</span> root  <span class="token key atrule">tasks</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> install lnmp      <span class="token key atrule">yum</span><span class="token punctuation">:</span>        <span class="token key atrule">name</span><span class="token punctuation">:</span>          <span class="token punctuation">-</span> mysql          <span class="token punctuation">-</span> php<span class="token punctuation">-</span>fpm          <span class="token punctuation">-</span> nginx        <span class="token key atrule">state</span><span class="token punctuation">:</span> present<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以把上面的两个playbook改写层下面这样，便于我们直接调用</p><pre class="line-numbers language-yaml"><code class="language-yaml">cat lamp.yaml<span class="token punctuation">-</span> <span class="token key atrule">yum</span><span class="token punctuation">:</span>    <span class="token key atrule">name</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> mysql      <span class="token punctuation">-</span> php<span class="token punctuation">-</span>fpm      <span class="token punctuation">-</span> httpd    <span class="token key atrule">state</span><span class="token punctuation">:</span> presentcat lnmp.yaml <span class="token punctuation">-</span> <span class="token key atrule">yum</span><span class="token punctuation">:</span>    <span class="token key atrule">name</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> mysql      <span class="token punctuation">-</span> php<span class="token punctuation">-</span>fpm      <span class="token punctuation">-</span> nginx    <span class="token key atrule">state</span><span class="token punctuation">:</span> present<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当我们需要执行这两个playbook时，直接使用include调用，playbook中的任务就会在被调用处执行</p><pre class="line-numbers language-yaml"><code class="language-yaml">cat lamp_lnmp.yaml<span class="token punctuation">-</span> <span class="token key atrule">hosts</span><span class="token punctuation">:</span> webserver  <span class="token key atrule">remote_user</span><span class="token punctuation">:</span> root  <span class="token key atrule">tasks</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> install lamp      <span class="token key atrule">include_tasks</span><span class="token punctuation">:</span> lamp.yaml    <span class="token comment" spellcheck="true"># 这里执行的是lamp.yaml的内容</span><span class="token punctuation">-</span> <span class="token key atrule">hosts</span><span class="token punctuation">:</span> dbserver  <span class="token key atrule">remote_user</span><span class="token punctuation">:</span> root  <span class="token key atrule">tasks</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> install lnmp      <span class="token key atrule">include_tasks</span><span class="token punctuation">:</span> lnmp.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="给include文件传参"><a href="#给include文件传参" class="headerlink" title="给include文件传参"></a>给include文件传参</h1><pre class="line-numbers language-yaml"><code class="language-yaml">cat baidu.yaml <span class="token punctuation">-</span> <span class="token key atrule">shell</span><span class="token punctuation">:</span> ping <span class="token punctuation">-</span>c 3 "<span class="token punctuation">{</span><span class="token punctuation">{</span> baidu <span class="token punctuation">}</span><span class="token punctuation">}</span>"    <span class="token comment" spellcheck="true"># 在include文件使用变量</span>cat include_baidu.yaml <span class="token punctuation">---</span><span class="token punctuation">-</span> <span class="token key atrule">hosts</span><span class="token punctuation">:</span> dbserver  <span class="token key atrule">remote_user</span><span class="token punctuation">:</span> root  <span class="token key atrule">vars</span><span class="token punctuation">:</span>    <span class="token key atrule">baidu</span><span class="token punctuation">:</span> <span class="token string">"www.baidu.com"</span>    <span class="token comment" spellcheck="true"># 定义include文件所需要的变量</span>  <span class="token key atrule">tasks</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> ping baidu      <span class="token key atrule">include_tasks</span><span class="token punctuation">:</span> baidu.yaml        <span class="token comment" spellcheck="true"># 调用执行include文件</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="import-playbook"><a href="#import-playbook" class="headerlink" title="import_playbook"></a>import_playbook</h1><p>我们使用include关键字可以调用任务列表，但如果想要调用整个playbook，则需要import_playbook模块代替include模块</p><pre class="line-numbers language-yaml"><code class="language-yaml">cat import_test.yaml<span class="token punctuation">---</span><span class="token punctuation">-</span> <span class="token key atrule">hosts</span><span class="token punctuation">:</span> dbserver  <span class="token key atrule">remote_user</span><span class="token punctuation">:</span> root  <span class="token key atrule">tasks</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">debug</span><span class="token punctuation">:</span>      <span class="token key atrule">msg</span><span class="token punctuation">:</span> <span class="token string">"test task cat import_test.yaml"</span><span class="token punctuation">-</span> <span class="token key atrule">import_playbook</span><span class="token punctuation">:</span> intest7.yaml        <span class="token comment" spellcheck="true"># 调用intest7.yaml整个yaml</span>cat intest7.yaml<span class="token punctuation">---</span><span class="token punctuation">-</span> <span class="token key atrule">hosts</span><span class="token punctuation">:</span> webserver  <span class="token key atrule">remote_user</span><span class="token punctuation">:</span> root  <span class="token key atrule">tasks</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">debug</span><span class="token punctuation">:</span>      <span class="token key atrule">msg</span><span class="token punctuation">:</span> <span class="token string">"test task cat intest7.yaml"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;我曾踏足山巅，也曾进入低谷，二者都让我受益良多。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​                                                                                       
      
    
    </summary>
    
    
      <category term="ansible" scheme="https://www.missf.top/categories/ansible/"/>
    
    
      <category term="ansible" scheme="https://www.missf.top/tags/ansible/"/>
    
      <category term="自动化运维" scheme="https://www.missf.top/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>ansible的lookups插件(14)</title>
    <link href="https://www.missf.top/post/de181bd8.html"/>
    <id>https://www.missf.top/post/de181bd8.html</id>
    <published>2020-06-10T11:46:58.000Z</published>
    <updated>2020-07-14T06:28:18.689Z</updated>
    
    <content type="html"><![CDATA[<p><strong>我曾踏足山巅，也曾进入低谷，二者都让我受益良多。</strong></p><p>​                                                                                                                                                                      <strong>——塔里克</strong></p><h1 id="ansible的lookups插件"><a href="#ansible的lookups插件" class="headerlink" title="ansible的lookups插件"></a>ansible的lookups插件</h1><p>过滤器其实是ansible中的一种插件，除了过滤器之外，ansible中还有很多其他种类的插件。而且我们一直都在使用这些插件，比如我们在配置ansible的主机清单时，就用到了Inventory种类的插件。lookups其实也是插件的一种，lookups的所有操作都是在控制节点上进行的，与管理节点无关。ansible官网为我们总结了各个插件的作用，并且按照这些插件功能进行了分类。<a href="https://docs.ansible.com/ansible/latest/plugins/plugins.html" target="_blank" rel="noopener">官网插件地址</a></p><h2 id="lookups-file"><a href="#lookups-file" class="headerlink" title="lookups file"></a>lookups file</h2><p>file插件可以读取文件，插件的源码是使用Python读取文件然后把结果返回给变量</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token punctuation">-</span> <span class="token key atrule">hosts</span><span class="token punctuation">:</span> dbserver  <span class="token key atrule">remote_user</span><span class="token punctuation">:</span> root  <span class="token key atrule">vars</span><span class="token punctuation">:</span>    <span class="token key atrule">contents</span><span class="token punctuation">:</span> <span class="token string">"{{ lookup('file','/etc/hostname') }}"</span>  <span class="token key atrule">tasks</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> debug lookup file      <span class="token key atrule">debug</span><span class="token punctuation">:</span>        <span class="token key atrule">msg</span><span class="token punctuation">:</span> <span class="token string">"the contents is {{ contents }}"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果不想将所有文件的内容变成一整个字符串，而是获取一个字符串列表，可以使用wantlist参数</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token punctuation">-</span> <span class="token key atrule">hosts</span><span class="token punctuation">:</span> dbserver  <span class="token key atrule">remote_user</span><span class="token punctuation">:</span> root  <span class="token key atrule">vars</span><span class="token punctuation">:</span>    <span class="token key atrule">contents</span><span class="token punctuation">:</span> <span class="token string">"{{ lookup('file','/etc/hostname',wantlist=true) }}"</span>  <span class="token key atrule">tasks</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> debug lookup file      <span class="token key atrule">debug</span><span class="token punctuation">:</span>        <span class="token key atrule">msg</span><span class="token punctuation">:</span> <span class="token string">"the contents is {{ contents }}"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="lookups-password"><a href="#lookups-password" class="headerlink" title="lookups password"></a>lookups password</h2><p>passwd插件会对传入的内容进行加密处理</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token punctuation">-</span> <span class="token key atrule">hosts</span><span class="token punctuation">:</span> dbserver  <span class="token key atrule">vars</span><span class="token punctuation">:</span>    <span class="token key atrule">contents</span><span class="token punctuation">:</span> <span class="token string">"{{ lookup('password','ansible') }}"</span>        <span class="token comment" spellcheck="true"># 将ansible这个字符串进行加密处理</span>  <span class="token key atrule">tasks</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> debug lookups      <span class="token key atrule">debug</span><span class="token punctuation">:</span>        <span class="token key atrule">msg</span><span class="token punctuation">:</span> <span class="token string">"the contents is {{ contents }}"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="lookups-pipe"><a href="#lookups-pipe" class="headerlink" title="lookups pipe"></a>lookups pipe</h2><p>pipe插件运行命令并返回结果，pipe这个插件底层是使用Python的subprocess库实现的</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token punctuation">-</span> <span class="token key atrule">hosts</span><span class="token punctuation">:</span> dbserver  <span class="token key atrule">remote_user</span><span class="token punctuation">:</span> root  <span class="token key atrule">vars</span><span class="token punctuation">:</span>    <span class="token key atrule">contents</span><span class="token punctuation">:</span> <span class="token string">"{{ lookup('pipe','hostname') }}"</span>  <span class="token key atrule">tasks</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> debug lookup pipe      <span class="token key atrule">debug</span><span class="token punctuation">:</span>        <span class="token key atrule">msg</span><span class="token punctuation">:</span> <span class="token string">"the contents is {{ contents }}"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="lookups-redis-kv"><a href="#lookups-redis-kv" class="headerlink" title="lookups redis_kv"></a>lookups redis_kv</h2><p>redis_kv插件是用来从本地redis中读取数据的</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token punctuation">-</span> <span class="token key atrule">hosts</span><span class="token punctuation">:</span> dbserver  <span class="token key atrule">remote_user</span><span class="token punctuation">:</span> root  <span class="token key atrule">vars</span><span class="token punctuation">:</span>    <span class="token key atrule">contents</span><span class="token punctuation">:</span> <span class="token string">"{{ lookup('redis_kv', 'redis://127.0.0.1:6379,ansible') }}"</span>     <span class="token comment" spellcheck="true"># 获取本地redis数据库ansible这个键的值</span>  <span class="token key atrule">tasks</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> debug lookup redis_kv      <span class="token key atrule">debug</span><span class="token punctuation">:</span>        <span class="token key atrule">msg</span><span class="token punctuation">:</span> <span class="token string">"the contents is {{ contents }}"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="lookups-dict"><a href="#lookups-dict" class="headerlink" title="lookups dict"></a>lookups dict</h2><p>dict插件是用来获取变量的键值对</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token punctuation">-</span> <span class="token key atrule">hosts</span><span class="token punctuation">:</span> dbserver  <span class="token key atrule">vars</span><span class="token punctuation">:</span>    <span class="token key atrule">users</span><span class="token punctuation">:</span>      <span class="token key atrule">alice</span><span class="token punctuation">:</span> female      <span class="token key atrule">bob</span><span class="token punctuation">:</span> male  <span class="token key atrule">tasks</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">debug</span><span class="token punctuation">:</span>      <span class="token key atrule">msg</span><span class="token punctuation">:</span> <span class="token string">"{{ item.key }} = {{ item.value }}"</span>    <span class="token key atrule">loop</span><span class="token punctuation">:</span> <span class="token string">"{{ lookup('dict',users) }}"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="lookups-env"><a href="#lookups-env" class="headerlink" title="lookups env"></a>lookups env</h2><p>env插件可以获取ansible主机中指定变量的值</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token punctuation">-</span> <span class="token key atrule">hosts</span><span class="token punctuation">:</span> dbserver  <span class="token key atrule">remote_user</span><span class="token punctuation">:</span> root  <span class="token key atrule">tasks</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">debug</span><span class="token punctuation">:</span>      <span class="token key atrule">msg</span><span class="token punctuation">:</span> <span class="token string">"{{ lookup('env','PATH') }}"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="lookups-first-found"><a href="#lookups-first-found" class="headerlink" title="lookups first_found"></a>lookups first_found</h2><p>first_found插件可以获取列表中第一个找到的文件，如果列表中的所有文件都没有找到，可以添加errors=ignore忽略报错</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token punctuation">-</span> <span class="token key atrule">hosts</span><span class="token punctuation">:</span> master  <span class="token key atrule">remote_user</span><span class="token punctuation">:</span> root  <span class="token key atrule">tasks</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> debug lookup first found    <span class="token key atrule">debug</span><span class="token punctuation">:</span>       <span class="token key atrule">msg</span><span class="token punctuation">:</span> <span class="token string">"{{ lookup('first_found',looklist,errors='ignore') }}"</span>    <span class="token key atrule">vars</span><span class="token punctuation">:</span>      <span class="token key atrule">looklist</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token string">"/abc.txt"</span>        <span class="token punctuation">-</span> <span class="token string">"/tmp/str.txt"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="lookups-dig"><a href="#lookups-dig" class="headerlink" title="lookups dig"></a>lookups dig</h2><p>dig插件可以获取指定域名的IP地址，需要Python安装dnspython库</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token punctuation">-</span> <span class="token key atrule">hosts</span><span class="token punctuation">:</span> master  <span class="token key atrule">remote_user</span><span class="token punctuation">:</span> root  <span class="token key atrule">tasks</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">debug</span><span class="token punctuation">:</span>      <span class="token key atrule">msg</span><span class="token punctuation">:</span> <span class="token string">"{{ lookup('dig','www.baidu.com',wantlist=true) }}"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;我曾踏足山巅，也曾进入低谷，二者都让我受益良多。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​                                                                                       
      
    
    </summary>
    
    
      <category term="ansible" scheme="https://www.missf.top/categories/ansible/"/>
    
    
      <category term="ansible" scheme="https://www.missf.top/tags/ansible/"/>
    
      <category term="自动化运维" scheme="https://www.missf.top/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
</feed>
